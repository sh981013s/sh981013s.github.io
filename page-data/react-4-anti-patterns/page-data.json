{"componentChunkName":"component---src-templates-post-jsx","path":"/react-4-anti-patterns/","result":{"data":{"site":{"siteMetadata":{"title":"Jason Lee"}},"markdownRemark":{"id":"2de45d5f-9115-5e85-a7a4-199ed24049b7","excerpt":"서론 항상 나는 리액트라는 를 올바르게 사용하고 있는지에 대한 고민이 있다.\n망치를 가지고 있다고 가정하였을때 망치 손잡이를 잡을지 아니면 망치 머리 가까이에 손을 위치할지 결정할 수 있다. \n망치 제작자들은 방법을 하지 않지만, 더  방법은 존재하리라 믿는다. 이는 리액트에도 해당되지 않을까 싶다.  본고에서는 단순히 리액트를 사용한다는 관점을 넘어서 …","html":"<h2>서론</h2>\n<p>항상 나는 리액트라는 <code class=\"language-text\">도구</code>를 올바르게 사용하고 있는지에 대한 고민이 있다.\n망치를 가지고 있다고 가정하였을때 망치 손잡이를 잡을지 아니면 망치 머리 가까이에 손을 위치할지 결정할 수 있다.\n망치 제작자들은 방법을 <code class=\"language-text\">명시</code>하지 않지만, 더 <code class=\"language-text\">효율적인</code> 방법은 존재하리라 믿는다. 이는 리액트에도 해당되지 않을까 싶다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 307px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/44d822b1078dd628de69636b5d75b840/ca17f/647cf611.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 68.82352941176471%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACQElEQVQ4y4WU3UtTYRzHDyFEdRPUVXXhX9BNV2FCdDFIYTNfKAapNBxEaNmck95w0FUX4kUhRb6wqzRQQq1MltOE7EUw88rVtqZtmebRnJ6a55xPZ8dt7bV+8OM8z+/5PZ/n9z3Pi4BmqqrqntrO9MSYLMs7MdLjCRMyQfksdSzWVhQlazEdmCs5X4VLS0sMPxvOuVASmEtqbPWEJ/ox8/l9lJlK6HZ1MR/w8WNNzIIKqbAdiIwib6PGXNWA2rgSFyBqALu9kcqqM7TebsXV18umJGVXqChxmLwDSJcka0SJiBiif6CPhiv1lFeYsFw4j625iZmPs3peQo2QlJoASGG2w5NEvf1EP3QRnWoj6nGy0luH1XiMUlMZZvNZLJYa6hsuMfX2TTaQuDRvj4NQ2xFCnUX42ovx3ilm7vpRXlsPMWEScJ7aj7m2BkeLnWaHjRs3rxFcCCaBSclqvDN6y8LgCYH3tQfwVO7hqbGAAYPA45MCz88d5lWnkwcP73O5/iJWax1NdhtPhgbTNjUOlPVgYHqCR0X7cBsKGDHuZah0Ny+rC5nvbiHyza/neNyjVBhP67CrtkbGxsfSgfC3wvVl7ZxVFeIu2cWLyoNMOctZfDfCyvcwC/55At45xt0jNGkb09FxD49nDEnaSt/lmPbNyAZf/V5mJt3crTbQYz7OpKudT7PThL98ZjUUZENcIfJzjV9bm3lvUVJyDCppieury4iiSET6zb8s9fBnXoz4TVFzTFL0X6F///NgpM7/A/5248dp7QQfAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='647cf611' title='647cf611' src='/static/44d822b1078dd628de69636b5d75b840/ca17f/647cf611.png' srcset='/static/44d822b1078dd628de69636b5d75b840/e7570/647cf611.png 170w,\n/static/44d822b1078dd628de69636b5d75b840/ca17f/647cf611.png 307w' sizes='(max-width: 307px) 100vw, 307px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>본고에서는 단순히 리액트를 사용한다는 관점을 넘어서 어떻게 더 <code class=\"language-text\">효율적으로</code> 리액트를 사용하기 위하여 피해야하는 세가지의 <code class=\"language-text\">안티패턴</code> 에 대하여 다룰 것이다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 360px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/6136fcbe9aa248bf8638d1b578fcdbc7/53918/69fdc17c.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 52.352941176470594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA8klEQVQoz2NQUlL6j4EVFcFYEcSWlfmvJCcHwUC2IpI8Nr0M6AIgDYowwxQU/suZW/+XNzQGYxAbJIaihpCBcJfJy/1X0NT6L+UX9l8sKQ+MQWyQGEgO7lKiXAhVLOPg9l+4tOW/YOPk/wJADGKDxGCWKhLrZSV5+f8K2rr/JcIT/oulFf0XaJsBxiA2SAwkB1JDtIFghXKy/2Utbf+L5Nf+Fy5vB2MQGyQGkiPahUpIEaKoqvZf2jPgv3hcJhiD2CAxWMQQHYaIiJH/L29g9F9RXQOMQWy4V4mOZQxD5cAuAmOk2MVmGF4DkTUq4hDDphcAtUUkH8cbnW0AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='69fdc17c' title='69fdc17c' src='/static/6136fcbe9aa248bf8638d1b578fcdbc7/53918/69fdc17c.png' srcset='/static/6136fcbe9aa248bf8638d1b578fcdbc7/e7570/69fdc17c.png 170w,\n/static/6136fcbe9aa248bf8638d1b578fcdbc7/f46e7/69fdc17c.png 340w,\n/static/6136fcbe9aa248bf8638d1b578fcdbc7/53918/69fdc17c.png 360w' sizes='(max-width: 360px) 100vw, 360px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<hr>\n<h2>본론</h2>\n<h3>1. 단일 컴포넌트 내부의 거대한 트리 구조 지양</h3>\n<p>리액트를 처음 시작했을 때 흔히 <code class=\"language-text\">구조</code>와 <code class=\"language-text\">구조 정리</code> 등 많은 부분을 고려하지 않고 로직에 따라 <code class=\"language-text\">하나의</code> 거대한 컴포넌트를 생성 후 내부에 수많은 조건과 로직이 담겨있는 <code class=\"language-text\">복잡한</code> 코드를 짜게 될 수 있다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 515px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/5b30fe707bad8dc5ebd7ad019ff852c2/70021/abb52135.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 137.05882352941177%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAACiklEQVRIx6VV63qiQAz1fVaLwDAgN0FQ1FZr3/9hsudEhqofFbf7I2acS5KTk4RZsNqJyQ9ii4MUzafkm7NKWp9UYuybdCer9buk1YfqpDyKzfeqo6wTL6plEa7lzVQy8+xGgrSTCBcyGAhWWzHFUcXiQZC0evENj6j52OvXj0KjMx4yQh8P/yxzmQelzP0Cuuh1qRcX1Dy7kUV43dNzFyEXJjtIXJ0Q1UFCRBpSA4qusz2cbXUdYI8pIGzDfaTLnftxc42QP4wyQd4sIBvmpSL0HS4BbrSBZ8BEaih8yDQssWYalrYZ0qAGHX5ejgA9rd6RaESWtvCOCECIzTv9H2BNEnQNhy5vd5DdpodIVlXPsLJ5lLz9VKK4tnCUbk6ohIs6ZmSjpKgx/AnBNCN49Dol7r4zOuTQlh8wutfNgcGHhz+Vyu3/AfISySYxEViMya6SAiKiSuWV6IYI3YEpD5IgR1n7JUV7QU47SSp0Sb1HmbA0ajCMRkiaUWMPpNTKqIeS8NEtjNjH46WtNdIwa3B+FRq8bbdxyCwblIlJt6PEzAN2Sy/PILtNspw3X4B5eomMScgs1Lg+a+mEPWQHa5yQJxG6gwhtl3CEgZAcOlnDCaXs4KBn3Lo2qwajoxFSs+FDdAENm5wjrdU2o7blVnVUYG/VTkNmKxlA9UGOFnbwTcQ8+AUpzGG2ueiUng85+g9SyHICgzTsRtO1DZ/38I8RUkeYKjEizPqJYwt8DvLvnE1Fd2+QrUdCUIcsnwTjKl5v1agtd6qVHGgO2EmDhOkuDt8MR8a/Qy7VYIGhwK/fVIc8hewGQ7w+6wfH6yfxYng4buQp5Ou07u4hvNDLowaZt8dR9BtDTv4CQTp+TDk6nL4AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='abb52135' title='abb52135' src='/static/5b30fe707bad8dc5ebd7ad019ff852c2/70021/abb52135.png' srcset='/static/5b30fe707bad8dc5ebd7ad019ff852c2/e7570/abb52135.png 170w,\n/static/5b30fe707bad8dc5ebd7ad019ff852c2/f46e7/abb52135.png 340w,\n/static/5b30fe707bad8dc5ebd7ad019ff852c2/70021/abb52135.png 515w' sizes='(max-width: 515px) 100vw, 515px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>척보기에도 보기 거북한? 코드임을 느낄 수 있다. 위 코드에 대하여 몇가지의 개선점을 제시할 수 있다.</p>\n<ul>\n<li><code class=\"language-text\">컴포넌트 트리</code> 내부 긴 조건문을 따로 <code class=\"language-text\">변수</code>를 사용하는 방식으로 <code class=\"language-text\">리팩토링</code>한다.</li>\n<li>트리의 각각의 조각들을 작은 <code class=\"language-text\">컴포넌트</code>로 <code class=\"language-text\">분리</code>한다.</li>\n<li>이벤트에 매핑할 <code class=\"language-text\">함수</code> 를 컴포넌트 트리로부터 <code class=\"language-text\">분리</code>한다.</li>\n</ul>\n<p>위 사항들을 적용한 개선 코드는 아래와 같다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 524px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/69a861464c6e529d899ed1fd7cb9e71e/6d924/ad8f2640.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 135.88235294117646%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAACvElEQVRIx51V6ZqbMAzM+7QJAWMImCMQyLXJdo/3fxZ3RtgsyWZpvv4QPpFG0kherNPOhpveZtXZbiAR5nG+t0lxlFGbYa7NQe6tk9YuVW1X8fahLALd2KS62E19kcvDQWPXmtLaYDL6n2YV8jCAorz9Y4v2arP6xeoCqOqzjYsDRiAtIUBJb5aqmlW6GA4am9ZXm1YncS+FAireuLVGKHRxcgofK/L74nLs4uMPvKzU/fpnV0eFYbqTi7/C0v6Oqm8yVTgnXumCyDSSkiIpzeHD1v27LSFF92ZLCF1ntjma5upCcZZQ+LNp5hf8UKnK9ojdCbTpbIRLEcLARHA9l9VpmG4UMo759iLWGVcFZYoGsK+QEDHq1hGMc06DBv8QKUMnLotCXKBCHnqUdIVz7y6NqfwA93azmRbaUGG2e7cZYmTaV6GIIhIoJtoQMQrTL3LPJWbhJymITTE7JKJB4BsoBTq6roHOx3Ka0YcIOVFZ/9CyXCQqL+PPM6XHDxtCcPPD9kfXnqplZZixk13eE3mGKvPNAd3E7D/tBoROkBhdoUGUL4jhEXTpnq6WMYackFNMSoImkSAJ0m1AG/ZBLdzrpPtEoA6rRBJm9sIGjTX32LXGLOviLH0xck2C5bQGWWWEBH4NCf3+ZC09AV1rREj3lBlcpGUSPZbKOAoqle+AEGKopJExNt2wj9HTalTICqj6T8gH3Buyzr3AoeM6SJzorTuf7jVThRWqpQeZEUPUMhFq11ilpok272xS9gOabIfzTuZEqhHbO4W1xKJAleTN6/C2OBRfxN4OiBxfB5SDfKsUqWckI2/fgBB0gUWNZ0Cz3yGORBmbHj2zx71WkGmHNin3Umk37UsWsEyESXl+olNv/9UcGokfK4YkX/1Hhdw1h/34RN7XrH+s5h6mm0dq7Sjh39tnHvM5+QuV2IH3KV9vyAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='ad8f2640' title='ad8f2640' src='/static/69a861464c6e529d899ed1fd7cb9e71e/6d924/ad8f2640.png' srcset='/static/69a861464c6e529d899ed1fd7cb9e71e/e7570/ad8f2640.png 170w,\n/static/69a861464c6e529d899ed1fd7cb9e71e/f46e7/ad8f2640.png 340w,\n/static/69a861464c6e529d899ed1fd7cb9e71e/6d924/ad8f2640.png 524w' sizes='(max-width: 524px) 100vw, 524px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<blockquote>\n<p>핵심: 컴포넌트 트리의 가독성을 가능한 최대한 향상시켜 해당 컴포넌트가 정확히 무엇을 하는지, 무엇을 렌더링하는지, 언제 하는지에 대해 파악을 쉽게 해야한다.</p>\n</blockquote>\n<h3>2. 글로벌 스코프 단위의 Context 지양</h3>\n<p>많은 상황에서 <code class=\"language-text\">상태(state)</code>와 <code class=\"language-text\">컨텍스트(context)</code> 의 경계가 모호해지는 경우가 많다. 하지만 엄연히 이 둘은 다르며 컨텍스트를 <code class=\"language-text\">전체 상태관리(global state management)</code> 용도로 사용하는 구조를 지양해야한다.</p>\n<blockquote>\n<p>컨텍스트(context)는 관계있는 컴포넌트간 prop 을 공유할 수 있게 해주고, 프롭 드릴다운 이펙트(prop drill down effect) 에 대한 방어수단으로 사용할 수 있다.</p>\n</blockquote>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 493px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/04842e6ba646609e3f553736109082e1/cf20c/72c53bbb.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 45.294117647058826%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABSUlEQVQoz41S2XKCQBD0//+LGAERolWKGrwPEBDwPjt0J1qVl8Spanpmdq7doXK/30H8JY+Y/0Cp8NNqtWAYBtrtNprNJjzPE6rVquzr9YpXhEVV8Hg8Yrvd4nA4YL/fC/Ttdjvp5/MZp9PpFxOXy0U2Yx+igmEYYjweYzabIQgC6ZPJBP1+XzoxGAx0RiZGo5HsXq8npGmK2+32XXCxWCiZgd1uV/pwOITv+/IxodPpYD6fI45jNV6tVrIJDkTmtCrIqyZJgs1mg/V6LVAvikKc57l8r7ylCiqhHJld4xJZmZyUk7Dzcrn89pc2eTqdSudEPOPtoihS7HMp/mcAw7RRtR1Y3gfMhos3q473uoOG48C2bW29VqvB+bEtyxK7rgvTNNXoOWFRbjMsu8blZGleIEpSIc3y55XJfBb+DVwAfVmWyU/78Rxfbk+ndZoIcO0AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='72c53bbb' title='72c53bbb' src='/static/04842e6ba646609e3f553736109082e1/cf20c/72c53bbb.png' srcset='/static/04842e6ba646609e3f553736109082e1/e7570/72c53bbb.png 170w,\n/static/04842e6ba646609e3f553736109082e1/f46e7/72c53bbb.png 340w,\n/static/04842e6ba646609e3f553736109082e1/cf20c/72c53bbb.png 493w' sizes='(max-width: 493px) 100vw, 493px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>실제 리액트 공식문서에서도 컨텍스트의 주된 용도는 다양한 레벨에 네스팅된 컴포넌트들에게 데이터를 전달하는 것이며, 컨텍스트를 사용하면 컴포넌트를 재사용하기 <code class=\"language-text\">어려워지므로</code> 꼭 필요할 때만 쓰라고 명시가 되어있다.</p>\n<p>많은 레퍼런스를 찾아본 결과, 글로벌 상태(global state)는 전체 application의 상태들을 관리하기 위해 존재하지만, 전체 상태 관리를 위해 <code class=\"language-text\">context provider</code> 를 통해 전체 application 을 래핑(wrap)하는 구조는 피해야 한다고 하였다.</p>\n<blockquote>\n<p>핵심: <code class=\"language-text\">전역</code>으로 상태관리를 해야하는 상황이라면 리덕스(redux), 리코일(recoil)과 같은 3rd party library 를 사용하고, Context API는 경계가 확실한 aplication 에서 각각의 파트에서 범위를 좁혀 사용하여야 한다.  </p>\n</blockquote>\n<h3>3. 컴포넌트 트리 내에서 <code class=\"language-text\">.map()</code> 의 <code class=\"language-text\">키(key)</code>를 변수 <code class=\"language-text\">인덱스(index)</code> 를 사용하는 렌더링 지양</h3>\n<p>몇몇 개발자들의 코드를 보면 아래와 같이 <code class=\"language-text\">.map()</code> 을 사용할 때 키 값으로 단순히 요소의 <code class=\"language-text\">index</code> 를 사용하는 경우가 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">ListOfUsers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> users <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Pete'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Jhon'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Sarah'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n            <span class=\"token punctuation\">{</span>users<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> index</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span> index <span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>과연 괜찮은 방법일까...? 아니라고 생각한다.</h4>\n<p>이유는 보통 컴포넌트 트리 내에서 <code class=\"language-text\">.map()</code> 을 사용할 때, 항상 <code class=\"language-text\">불변</code>의 <code class=\"language-text\">간단한</code> 배열만 사용한다는 보장이 없기 때문이다.\n리액트는 각 요소에 유니크(unique)한 key 값을 부여해 해당 요소가 추가되거나, 변경되거나 삭제되는 상황을 <code class=\"language-text\">식별</code>한다.</p>\n<p>예시로 위와 같은 코드 형식에서 리스트에 <code class=\"language-text\">첫번째</code> 인덱스에 요소를 추가한다면 리액트는 예측되지 못한 행동으로 인식하여 매우 혼란스러워 한다.\n가능한 엘리먼트의 index 값보다는 실제 고유의 값을 사용하는 것이 바람직하다.</p>\n<hr>\n<h2>결론</h2>\n<p>리액트는 하나의 문제를 해결할때도 많은 방식을 허용하기에 매력적이지만, 높은 퍼포먼스를 가진 application 을 만들기 위해서는 <code class=\"language-text\">안티패턴</code>을 최대한 피해야한다.  </p>","frontmatter":{"title":"리액트에서 피해야할 안티패턴","date":"May 01, 2022","update":"May 01, 2022","tags":["React","패턴"],"series":null},"fields":{"slug":"/react-4-anti-patterns/","readingTime":{"minutes":6.185}}},"seriesList":{"edges":[{"node":{"id":"45bc678e-7703-5acd-aafd-a7c0fa93a80c","fields":{"slug":"/baekjoon-1654/"},"frontmatter":{"title":"[BOJ] 1654 랜선 자르기 (Node.js)"}}},{"node":{"id":"028e9080-86df-53bb-a1e9-dbc398328921","fields":{"slug":"/vainllajs-registration-form/"},"frontmatter":{"title":"회원가입 폼 with Vanilla JS"}}},{"node":{"id":"d736c4dd-4d23-5481-97d4-a12694b7fd0c","fields":{"slug":"/movie-seat-booking/"},"frontmatter":{"title":"영화 좌석 선택 with Vanilla JS"}}},{"node":{"id":"950ab322-20a3-506d-be98-95c57b9d5e7f","fields":{"slug":"/exchange-rate-calculator/"},"frontmatter":{"title":"환전기 with Vanilla JS"}}},{"node":{"id":"bfe47c8d-2f18-5cc3-8501-86e865256557","fields":{"slug":"/custom-video-player/"},"frontmatter":{"title":"비디오 플레이어 with Vanilla JS"}}},{"node":{"id":"4b8a65e9-78c3-54b6-8fce-8e518749024c","fields":{"slug":"/personal-information-list/"},"frontmatter":{"title":"개인자산 체크 with Vanilla JS"}}},{"node":{"id":"364ae05f-101b-5720-9ec6-d692d55e0062","fields":{"slug":"/menu-sidebar-modal/"},"frontmatter":{"title":"사이드바, 모달 with Vanilla JS"}}},{"node":{"id":"5abf51b6-6ecd-5d96-879f-5777a606bf0a","fields":{"slug":"/connecting-server-client/"},"frontmatter":{"title":"React && Node.js 연결하기"}}},{"node":{"id":"ac1bef97-c59e-5beb-955b-d8c6e8e742c8","fields":{"slug":"/import-react/"},"frontmatter":{"title":"importing React 와 JSX 사용의 상관관계"}}},{"node":{"id":"2a9c97e2-a6bc-515d-9f47-b1248cf5f9cf","fields":{"slug":"/vsc-react-autoimport/"},"frontmatter":{"title":"VSC 리액트 auto import"}}},{"node":{"id":"bf55c7ac-a772-56fa-b74d-2a0ae1afd342","fields":{"slug":"/useRef/"},"frontmatter":{"title":"리액트 useRef"}}},{"node":{"id":"376677fe-0b5d-57d7-9b3e-95aeb604a67c","fields":{"slug":"/react-debouncing/"},"frontmatter":{"title":"리액트 디바운싱(debouncing)"}}},{"node":{"id":"de4aef09-b0e7-5a98-99a2-d996af28dbff","fields":{"slug":"/react-debugging/"},"frontmatter":{"title":"리액트 크롬 데브툴 디버깅(debugging)"}}},{"node":{"id":"7ddeab05-2689-5d93-a885-948c97b1db0e","fields":{"slug":"/js-semicolon/"},"frontmatter":{"title":"자바스크립트 내에서의 세미콜론(;) 사용"}}},{"node":{"id":"63903bd1-952c-5d18-a931-a4adf22668c4","fields":{"slug":"/js-short-circuit-evaluation/"},"frontmatter":{"title":"자바스크립트 단축 평가"}}},{"node":{"id":"9ab7110e-3675-5155-a3d2-773f12f2b7fc","fields":{"slug":"/js-const/"},"frontmatter":{"title":"자바스크립트 const(constant) 키워드 에 대한 고찰"}}},{"node":{"id":"ef98c32c-b112-56b5-8750-2a65f29a76f8","fields":{"slug":"/js-single-thread/"},"frontmatter":{"title":"싱글스레드인 자바스크립트는 어떻게 비동기 처리를 하는가"}}},{"node":{"id":"50d11bc0-654a-525a-9cd5-220a2335dfc6","fields":{"slug":"/js-indexOf/"},"frontmatter":{"title":"자바스크립트 indexOf() 와 시간 복잡도의 상관관계에 대한 고찰"}}},{"node":{"id":"e83d28ae-8193-56f4-9504-165a7670ea8c","fields":{"slug":"/2021-retrospect/"},"frontmatter":{"title":"2021년 블로그 운영 회고"}}},{"node":{"id":"2f3f5cd2-f838-50db-9e87-f864a0082032","fields":{"slug":"/react-real-code-splitting/"},"frontmatter":{"title":"리액트 Code-splitting 실적용 사례"}}},{"node":{"id":"3653cebd-84f0-5d9f-b911-7e3380e26d2f","fields":{"slug":"/mac-kernal-task/"},"frontmatter":{"title":"맥북 kernel_task 과점유 현상"}}},{"node":{"id":"ac8423e7-cc42-5cf5-8f71-2d94b816c3cc","fields":{"slug":"/js-async-defer/"},"frontmatter":{"title":"자바스크립트 script 태그 async & defer 속성"}}},{"node":{"id":"7500a096-2419-500f-9c14-f6faa8a8b733","fields":{"slug":"/js-reduce-break/"},"frontmatter":{"title":"자바스크립트 reduce break"}}},{"node":{"id":"862d4423-5868-5d5d-ae40-0996bf878f09","fields":{"slug":"/js-linked-list/"},"frontmatter":{"title":"Linked-list with JS"}}},{"node":{"id":"ce965688-bfc1-5d9e-9fa2-87faec37db48","fields":{"slug":"/js-stack/"},"frontmatter":{"title":"Stack with JS"}}},{"node":{"id":"3fb03326-51d0-5ea4-8f03-157013d29817","fields":{"slug":"/js-queue/"},"frontmatter":{"title":"Queue with JS"}}},{"node":{"id":"2de45d5f-9115-5e85-a7a4-199ed24049b7","fields":{"slug":"/react-4-anti-patterns/"},"frontmatter":{"title":"리액트에서 피해야할 안티패턴"}}},{"node":{"id":"0df70305-6854-532e-b7ed-bf1afa0a0f3b","fields":{"slug":"/js-array-element-swap/"},"frontmatter":{"title":"자바스크립트 배열 원소 swap"}}},{"node":{"id":"7c241801-fc74-5e9f-ad4d-0857819cdd2a","fields":{"slug":"/js-primitive-reference-types/"},"frontmatter":{"title":"자바스크립트 원시(primitive)타입 vs 참조(reference)타입"}}},{"node":{"id":"c02c0083-deea-51d2-b3a9-f8b5dbecba19","fields":{"slug":"/react-automatic-batching/"},"frontmatter":{"title":"React 18 Automatic Batching: 렌더링 성능 향상의 무기"}}},{"node":{"id":"e3b5900a-32b4-5091-8025-7ca64a558e5a","fields":{"slug":"/sellon/"},"frontmatter":{"title":"멋쟁이사자처럼 10기 해커톤 이후 회고"}}},{"node":{"id":"6e309f62-7717-5898-b10d-ed350c7a5e9b","fields":{"slug":"/oohtech-success/"},"frontmatter":{"title":"우아한 테크코스 5기 프론트엔드 최종합격 후기 및 과정"}}},{"node":{"id":"46073002-10b1-599c-8d84-99d4ebb7cb78","fields":{"slug":"/js-global-state-management-vanilla-js/"},"frontmatter":{"title":"Vanilla JS 로 간단한 전역 상태 관리 시스템 만들기"}}},{"node":{"id":"5dae62fe-064f-5acf-8114-7e5f4d22a1e3","fields":{"slug":"/ts-non-null-assertion-operator/"},"frontmatter":{"title":"[Typescript] Non-null assertion operator ! (non-null 단언 연산자)"}}},{"node":{"id":"47305df1-1dc7-5b3c-b334-dcc9922f4cd6","fields":{"slug":"/woowacourse-first-month/"},"frontmatter":{"title":"🦉 부엉이의 함께 자라기 in 우테코"}}},{"node":{"id":"adcfbb9c-c845-5d03-be55-8fddde63ce29","fields":{"slug":"/js-wrapping-object/"},"frontmatter":{"title":"[JavaScript] 자바스크립트의 객체 wrapper에 대해 알아보자"}}},{"node":{"id":"9354e08d-30df-548f-a9df-b62ce6e5616c","fields":{"slug":"/woowacourse-level-one/"},"frontmatter":{"title":"우테코 레벨1 회고"}}},{"node":{"id":"c8c5c807-030d-5002-9827-ae80fe4a4c42","fields":{"slug":"/am-i-doing-good/"},"frontmatter":{"title":"나는 올바르게 성장하고 있는가"}}}]},"previous":{"fields":{"slug":"/js-queue/"},"frontmatter":{"title":"Queue with JS"}},"next":{"fields":{"slug":"/js-array-element-swap/"},"frontmatter":{"title":"자바스크립트 배열 원소 swap"}}},"pageContext":{"id":"2de45d5f-9115-5e85-a7a4-199ed24049b7","series":null,"previousPostId":"3fb03326-51d0-5ea4-8f03-157013d29817","nextPostId":"0df70305-6854-532e-b7ed-bf1afa0a0f3b"}},"staticQueryHashes":[]}