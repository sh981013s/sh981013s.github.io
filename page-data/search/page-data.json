{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"서론 리액트 프로트를 진행하다보면 위와같은 코드를 심심치 않게 쓴다. 나는 보통 url 을 통해 데이터를 fetching\n하였을때 비동기 처리를 위해 데이터가 있을때만 해당 코드가 동작하게 하는  이구나 하고 \n아무생각 없이 사용하곤 하였다. 그러던 중 해당 코드는 자바스크립트의  라는 개념을\n사용한다는 것을 알게되었고 이에대해 정리하려고 한다. 본론 논…","fields":{"slug":"/js-short-circuit-evaluation/"},"frontmatter":{"date":"January 20, 2022","title":"자바스크립트 단축 평가","tags":["Javascript"]},"rawMarkdownBody":"\n## 서론\n\n```javascript\n\n// ... 생략\nreturn (\n  <Root>\n    {data && <p>{data.name}</p>}\n  </Root>\n)\n```\n\n리액트 프로트를 진행하다보면 위와같은 코드를 심심치 않게 쓴다. 나는 보통 url 을 통해 데이터를 fetching\n하였을때 비동기 처리를 위해 데이터가 있을때만 해당 코드가 동작하게 하는 `예외처리` 이구나 하고 \n아무생각 없이 사용하곤 하였다. 그러던 중 해당 코드는 자바스크립트의 `논리연산자를 사용한 단축 평가` 라는 개념을\n사용한다는 것을 알게되었고 이에대해 정리하려고 한다.\n\n---\n\n## 본론\n\n- 논리곱(&&) 연산자는 두개의 피연산자가 모두 true 로 평가될 때 true 를 반환한다. 논리곱 연산자는 좌항에서 우항으로 평가가 진행된다.\n- 논리합(||) 연산자는 두개의 피연산자 중 하나만 true 로 평가되어도 true 를 반환한다. 논리합 연산자 또한 좌항에서 우항으로 평가가 진행된다.\n\n논리곱 연산자와 논리합 연산자는 `논리 연산의 결과를 결정하는 피연산자` 를 타입 변환하지 않고 그대로 반환한다. 이를 단축 평가라 한다.\n단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 뜻한다.\n\n```javascript\n// 논리곱(&&) 연산자\n'a'   && 'b'   // => 'b'\nfalse && 'b'   // => false\n'a'   && false // => false\n\n// 논리합(||) 연산자\n'a'   || 'b'   // => 'a'\nfalse || 'b'   // => 'b'\n'a'   || false // => 'a'\n```\n\n단축 평가를 사용하면 if 문을 대체할 수 있다. 어떤 조건이 true 여야 실행되어야 한다면, 논리곱(&&) 연산자 표현식으로 \n이를 대체하고, 조건이 false 여야 실행되어야 한다면 논리합(||) 연산자 표현식으로 이를 대체할 수 있다.\n\n```javascript\nlet finished = true;\nlet message = '';\n\nmessage = finished && '완료';\nconsole.log(message); // => '완료'\n\nfinished = false;\n\nmessage = finished || '미완료';\nconsole.log(message); // => '미완료'\n```\n\n---\n\n## 결론\n\n단축평가에 대해 처음 알아보기 전에는 그냥 비교연산자와 같이 비교하여 true / false 를 반환하는거 아니였나..? 라고 막연하게\n생각하였는데 그렇지 않고 논리 연산의 결과를 `결정` 하는 피연산자를 그대로 타입 변환 없이 그대로 반환한다는 특징을 가지고 있다.\n이를 잘만 사용한다면 리액트를 사용할때, 논리식을 사용하여 데이터가 없거나 아직 비어있을때 에러를 방지하는 처리를 해줄 수 있겠다는 결론에 다달았다.\n\n\n"},{"excerpt":"서론 자바스크립트 내에서 세미콜론(;) 은 언제 사용해야할까? 왜 사용해야할까?  언제 사용해야할까? 나는 흔히 인터넷에서 돌아다니는 말중에 '자바스크립트를 사용할때 \n세미콜론을 생략해도 되지만, 사용하도록 버릇을 들이는게 좋을것이다.' \n라는 대다수의 조언을 받아드려 마구잡이로 사용하고 있었다. 내가 세운 나만의 기준은 당시 '문장의 끝에 단다.' 정도…","fields":{"slug":"/js-semicolon/"},"frontmatter":{"date":"January 18, 2022","title":"자바스크립트 내에서의 세미콜론(;) 사용","tags":["Javascript"]},"rawMarkdownBody":"\n## 서론\n\n자바스크립트 내에서 세미콜론(;) 은 언제 사용해야할까?\n\n왜 사용해야할까? \n\n언제 사용해야할까?\n\n나는 흔히 인터넷에서 돌아다니는 말중에 '자바스크립트를 사용할때 \n세미콜론을 생략해도 되지만, 사용하도록 버릇을 들이는게 좋을것이다.' \n라는 대다수의 조언을 받아드려 마구잡이로 사용하고 있었다.\n\n내가 세운 나만의 기준은 당시 '문장의 끝에 단다.' 정도였지만 조금더 \n정확한 이유와 개념을 알 필요가 있다고 생각했다.\n\n---\n\n## 본론\n\n세미콜론(;)은 `문` 의 종료를 나타낸다. \n\n`문` 이란 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. \n문의 집합으로 이루어진 것이 `프로그램` 이며, 문을 작성하고 순서에 맞게\n나열하는 행위가 `프로그래밍` 이다.\n\n```javascript\nconst num = 1 + 3;\n```\n\n예시로, 위의 내가 생각하던 '문장'은 키워드를 사용한 `변수의 선언`, `표현식의 평가`,`값을 할당`\n이 이루어진 하나의 `문` 이다. 즉 자바스크립트는 세미콜론을 기준으로 문이 종료한 위치를 파악 후 순차적으로 하나씩 문을 실행한다.\n\n허나 여기에서 내가 생각하던 문제가 있다. 나는 주로 `ESLint` 와 `Prettier` 같은 정적 분석 도구를 사용하였지만,\n보통 문의 종료라고 생각되는 지점에는 자동적으로 세미콜론을 붙여주였지만, `if문`, `for문`, `함수` 뒤에는 세미콜론을 자동으로 붙이지 않아주었다.\n\n나는 여지껏 해당 정적 분석 도구 자체의 하나의 오류이거나 해당 행위는 optional 하지 않을까..? 라고 어림짐작만 하고 있던 상태였다.\n\n하지만, if문, for문, 함수등의 코드 불록 뒤에는 세미콜론을 붙이지 않으며 이유는, 이러한 코드 블록은 언제나 문의 종료를 의미하는\n`자체 종결성 (self closing)` 을 가지고 있기 때문이다.\n\n또한, 자바스크립트 엔진은 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 \n`ASI` 가 자동으로 실행되지만 왜 대다수의 개발자들은 세미콜론을 반드시 붙여야한다는 의견이 대다수일까?\n\n![](.index_images/2c803f76.png)\n\n위의 한 개발자가 말하기를, C# 을 사용할때는 문의 끝에 반드시 세미콜론을 붙여야한다는 문법적 강제성이 따른다.\n하지만 말그대로 자바스크립트에서 런타임 동작시 우리가 붙인 세미콜론은 아무런 의미를 찾을 수 없다는 의견을 내포한다고 나는 이해하였다.\n\n반대로 써야한다는 개발자들의 의견의 대다수는, 보통 다른언어에서도 그래왔기 때문에 `가독성` 면에서 다른이가 나의 코드를 읽었을때,\n세미콜론을 사용한다면 해당 문의 끝이 어디인지 정확히 알 수 있기도 하고, 인터프리터의 ASI 기능에 100프로 의존하며 자발적으로 불안감을 느낄 수 있는 행위를 \n도대체 왜 옹호하냐는 의견이 많았다.\n\n---\n\n## 결론\n\n세미콜론은 문의 종료를 나타낸다. 문이란 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 하지만, 자바스크립트에서는\n개발자가 세미콜론을 붙이지 않더라도 ASI 를 통해 자동적으로 문의 끝의 예측지점에 세미콜론을 부여한다.\n\n세미콜론의 사용 비사용 의견에 나의 의견을 말하자면, 결국 우리의 소스코드를 인터프리터가 해석한다고 하지만, 결국 소스코드란\n개발자가 쓰고, 유지하고 보수하는 하나의 `문서` 라고 생각이 든다. 그 뜻은, 해당 소스코드를 작성한 개발자 및 해당 소스코드를 \n읽고 사용,유지 및 보수해야하는 다른 개발자 또한 지속적으로 해당 소스코드를 보아야 하는데, 인간이 글을 작성할때 가독성을 위해 \n문장의 끝에 마침표를 넣듯이, 결국 안정성 및 가독성을 위해 세미콜론을 사용해야 하지 않을까?  \n\n"},{"excerpt":"서론 외부 api 를 사용하는 상황에서 Docs 를 읽어본다 한들 실제 데이터의 형태가 어떻게 구성되어있는지 정확히 예상하고 코드를 짜는 행위는 불가능에 가깝다고 생각하고 에러를 유발한다. 나는 데이터 구성을 확인하기 위해 데이터 fetching 후 직접 콘솔로 찍어 확인하는 방법을 사용하였는데, 이는 차후에 코드의 에러를 유발할 수 있고, 자칫 까먹고 …","fields":{"slug":"/react-debugging/"},"frontmatter":{"date":"January 09, 2022","title":"리액트 크롬 데브툴 디버깅(debugging)","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n외부 api 를 사용하는 상황에서 Docs 를 읽어본다 한들 실제 데이터의 형태가 어떻게 구성되어있는지 정확히 예상하고 코드를 짜는 행위는 불가능에 가깝다고 생각하고 에러를 유발한다. 나는 데이터 구성을 확인하기 위해 데이터 fetching 후 직접 콘솔로 찍어 확인하는 방법을 사용하였는데, 이는 차후에 코드의 에러를 유발할 수 있고, 자칫 까먹고 체크하는 코드를 없애는 행위를 까먹는 상황을 방지하기 위해 직접 콘솔을 찍기 보다는 `Chrome Dev Tool` 을 사용하여 `디버깅` 하는 방법을 채택하였다.\n\n---\n\n## 본론\n\n`디버깅(debugging)` 은 스크립트 내 에러를 검출해 제거하는 일련의 과정을 의미한다. 모던 브라우저의 환경 대부분은 개발자 도구 내부에 UI 형태로 디버깅 툴을 가지고 있다. 디버깅 툴을 사용하면 실행 단계마다 어떤 일이 일어나는지를 코드 단위로 추적할 수 있다.\n\n![](2022-01-09-16-32-59.png)\n\n구글크롬에서 `F12` 를 누르면 `Chrome Dev Tool` 을 사용할 수 있다. 이후 탭에서 `Sources` 를 누르면 위와같은 화면이 보인다. \n\nSource 패널의 좌측은 `파일 탐색 영역` 으로 페이지에 쓰인 리소스를 트리 형태로 보여준다.\n\n중앙은 `코드 에디터 영역` 으로 파일 탐색 영역에서 선택한 파일의 소스 코드를 보여준다.\n\n우측은 `JS debugging` 영역으로 디버깅에 관련된 기능을 제공한다.\n\n내가 서론에서 서술한 문제를 해결하기 위해 사용한 `breakpoint` 는 매우 중요한 개념이며 말 그대로 JS 의 실행이 중단되는 코드 내 지점을 의미한다. 중단점을 이용하면 실행이 중지된 시점에 변수가 어떤 값을 담고 있는지 알 수 있고, 중지된 시점을 기준으로 명령어를 실행할 수도 있다.\n\n 위의 사진을 자세히 보면 나는 55번줄, 즉 외부 api 로부터 price 를 fetching 한 후 해당 값을 전역 state 에 할당하는 과정 바로 전에 데이터가 어떠한 형태로 들어왔는지 확인하기 위해 breakpoint 를 걸었다.\n\n 우측에 `Scope` 항목에 실제로 prices 애 array 가 들어왔고 해당 데이터를 자세히 확인할 수 있게 되었다. \n\n\n---\n\n## 결론\n\nChrome Dev Tool 에서 breakpoint 를 걸음으로서 스크립트 실행이 중지되면 중단 시점을 기준으로 변수에 어떤 값이 들어가 있는지 확인할 수 있다. 또한 단계별로 코드를 실행해 가며, 어디서 문제가 발생했는지 추적할 수도 있습다. 이런 식으로 디버깅을 진행할 수 있다.\n"},{"excerpt":"서론 가상화폐를 다루는 사이드 프로젝트를 하다가 사용자의  을 받아 검색결과에 맞는 가상화폐들만 보여주어야 하는 Search Input 을 구현하고 있었다.  해당 과정에서 사용자가 input 을 넣은 결과에 따라 output 을 도출해야 하지만, 사용자가 input 을 끝냈는지(마무리했는지) 에 대한 로직을 내가 직접 예측하기에는 무리라 생각이 들었다.…","fields":{"slug":"/react-debouncing/"},"frontmatter":{"date":"January 08, 2022","title":"리액트 디바운싱(debouncing)","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n가상화폐를 다루는 사이드 프로젝트를 하다가 사용자의 `Input` 을 받아 검색결과에 맞는 가상화폐들만 보여주어야 하는 Search Input 을 구현하고 있었다. \n\n해당 과정에서 사용자가 input 을 넣은 결과에 따라 output 을 도출해야 하지만, 사용자가 input 을 끝냈는지(마무리했는지) 에 대한 로직을 내가 직접 예측하기에는 무리라 생각이 들었다. \n\n그리하여 `onKeyUp` 을 활용하여 필터링을 하는 함수를 실행시키려 하였지만, 여기서 문제점은 사용자가 한글자를 타이핑 할때마다 해당 필터링 함수가 실행된다.\n\n여끼까지는 문제점이 크게 없지만 만약 해당 필터링 함수가 `외부 유로 api` 로부터 data 를 fetching 해야하는 동작을 한다면? 각각의 query 는 즉 돈이기 때문에 매우 비효율적인 동작으로 보인다. 물론 위와같은 경우에는 한번만 fetching 한 후 `global state` 로 관리를 하면 된다만 위의 예시 이외에도 다양한 resource 의 낭비를 초래하는 이유들이 많다.\n\n나는 이 문제를 해결하고자 `debounce`를 사용하였다.\n\n![](2022-01-08-20-30-25.png)\n\n\n\n---\n\n## 본론\n\n이벤트 발생과 그에따른 콜백함수를 다루는데 `debounce` 는 중요한 개념중의 하나라고 생각이 든다.\n\n단순 클릭이벤트처럼 단순하지 않고, 검색폼처럼 사용자의 키보드 입력이 지속적으로 발생하면 처리를 하지 않으면 과도한 api 요청을 보낼 수 있고 이는 곧 서버의 과부화까지 이어질 수 있다.\n\n위의 문제를 처리하기 위해 `debounce` 라는 개념을 사용하였다.\n\n> debouncing 은 연속된 이벤트 중 마지막 이벤트의 콜백함수만을 실행한다.\n\n리액트의 내장훅 중 하나인 `useEffect` 를 사용하여 직접 debouncing 을 구현하는 방법이 있지만, `lodash` 는 디바운싱을 사용하기 쉽게 만든 메소드가 존재하기에 이방식을 선택하였다.\n\n```js\nconst filterCoins = (e, setFilteredCoins, coinList) => {\n  let inputValue = e.target.value;\n//   handleFilter(inputValue, coinList, setFilteredCoins);\n    console.log(inputValue)\n};\n\nconst Search = () => {\n  return (\n    <AppContext.Consumer>\n      {({ setFilteredCoins, coinList }) => (\n        <SearchGrid>\n          <h2>Search all coins</h2>\n          <SearchInput\n            onKeyUp={(e) => filterCoins(e, setFilteredCoins, coinList)}\n          />\n        </SearchGrid>\n      )}\n    </AppContext.Consumer>\n  );\n};\n```\n\n위는 예시로 만든 debouncing 을 적용하지 않은 상태이며 만일 내가 'abc' 를 input 에 넣으면 콘솔에 'a', 'ab', 'abc' 즉 3번이 찍힌다.\n\n```js\nconst handleFilter = _.debounce((inputValue, coinList, setFilterCoins) => {\n  console.log(inputValue);\n}, 500);\n\nconst filterCoins = (e, setFilteredCoins, coinList) => {\n  let inputValue = e.target.value;\n  handleFilter(inputValue, coinList, setFilteredCoins);\n};\n```\n\n이를위해 debouncing 을 사요하는 `handleFilter` 함수를 추가로 만들어주었다. 결과적으로는 abc 를 타이핑하였을때 콘솔에 'abc' 한번만 찍히게 되었다.\n \n---\n\n## 결론\n\n사용자의 input 에 따른 함수를 실행할 때, 특히 해당 함수가 유료 API를 사용한다면 쿼리를 무분별하게 날리기 때문에, 비용적인 문제를 초래할 수 있기에 이를 방지하기 위해 debouncing 을 사용할 수 있다. debouncing 은 연이은 이벤트의 마지막에만 실행할 수 있는 환경을 만들어 준다. \n"},{"excerpt":"서론 Javascript 를 사용할때, 특정 DOM 을 선택하여 정보를 얻거나 임의로 조작해야 할때,  혹은  과 같은 DOM Selector 함수를 사용하여 DOM 을 선택하였다. 하지만, React 는 이 기능을 대체할 수 있는  훅을 제공한다. 본론 useRef는 .current 프로퍼티로 전달된 인자(initialValue)로 초기화된 변경 가능한…","fields":{"slug":"/useRef/"},"frontmatter":{"date":"January 04, 2022","title":"리액트 useRef","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\nJavascript 를 사용할때, 특정 DOM 을 선택하여 정보를 얻거나 임의로 조작해야 할때, `getElementById` 혹은 `querySelector` 과 같은 DOM Selector 함수를 사용하여 DOM 을 선택하였다. 하지만, React 는 이 기능을 대체할 수 있는 `useRef` 훅을 제공한다.\n\n---\n\n## 본론\n\n> useRef는 .current 프로퍼티로 전달된 인자(initialValue)로 초기화된 변경 가능한 ref 객체를 반환합니다. 반환된 객체는 컴포넌트의 전 생애주기를 통해 유지될 것입니다. 본질적으로 useRef는 .current 프로퍼티에 변경 가능한 값을 담고 있는 상자와 같습니다.\n\n리액트 공식문서에는 위와 같이 나와있고, 결국 나는 useRef 는 특정 DOM node 와 변수 자체를 담을 수 있는 상자라고 해석했다.\n\n그렇다면 왜 기존에 vanilla JS 에서 사용하던 친숙한 `querySelector` 를 지양하고 이를 대체하는 `useRef` 를 사용할까? 에 대해 검색을 해보았다.\n\n내가 해석한 결론은 React에서 `querySelector` 를 사용하게되면, 실제 DOM의 요소를 가져오게 된다. 하지만 React는 Virtual DOM을 통해 Real DOM을 그리기 때문에, React가 제어하고있는 Virtual DOM 안에 있는 요소가 더 신뢰할만하다. DOM API로 Real DOM에 있는 node 를 담았지만, 이게 현재 Virtual DOM을 통해 Real DOM에 존재하는 node 인지 아닌지 확신할 수 없다는 점이 크리티컬 하다고 생각한다.\n\n또한, React를 사용하게되면, 가장 중요한 개념 중 하나가 `State` 이다. React 내부에서 데이터는 컴포넌트 내의 State으로 조작된다. 즉, React가 State를 컨트롤(제어)하고 있다. 만약 이러한 React 시스템을 벗어나 DOM을 직접적으로 건드리게되면 이 내용들은 React가 제어하는 영역에서 벗어나게 되고, 이렇게 React의 제어를 벗어나게 되면, React에서 제공하는 이점들을 사용할 수 없게 된다.\n\n위에서 `useRef` 를 사용 이유에 대해 알아보았다면, 내가 생각하기에 `useRef` 의 이점은 `무분별한 react component 의 re-rendering 을 방지한다` 이다.\n\nReact 내에서 `re-rendering` 은 컴포넌트가 자신의 `state` 가 변경되거나, 부모에게서 받는 `props` 가 변경될 때마다\n컴포넌트를 다시 호출하여 실행하는 현상을 말한다. re-rendering 시에 컴포넌트 내부의 state 과 function 또한 `재선언` 이\n이루어지기에, 무분별한 re-rendering은 결국 resource 낭비라고 생각이 든다.\n\n결국 `useRef` 가 어떻게 `무분별한 re-rendering` 을 방지하는가에 대해서는 useRef 가 담을 수 있는 변수에 답이 있다.\n이는 독단적인 `변수` 그 자체이기에, 값이 바뀐다고 해도 컴포넌트가 re-rendering 되는 트리거로 작동하지 않는다.\n\n```js\nimport \"./App.css\"\nimport { useState } from \"react\"\n\nfunction App() {\n  const [username, setUsername] = useState(\"\")\n  const handleChange = e => {\n    setUsername(e.target.value)\n    console.log(username)\n  }\n\n  console.log(\"rendered\")\n\n  return (\n    <div className=\"box\">\n      <input type=\"text\" onChange={handleChange} />\n      {username}\n    </div>\n  )\n}\n\nexport default App\n```\n\n위의 예시는 컴포넌트의 re-rendering 을 감지하기 위해 예시로 짠 코드이다. `console.log('rendered')` 로 인하여\n컴포넌트가 초기에 렌더링될때 한번 콘솔에 찍히고, re-rendering 될때마다 매번 rendered 가 찍히게 된다.\n또한, input 에 넣는 값에따라 handleChange 함수로 인하여 username 의 state 를 변경하게 된다. 즉, 값이 변경될 때마다\nstate 가 변하게 되고 이는 즉, re-rendering 을 일으킨다는 것이다.\n\n![](2022-01-04-18-34-15.png)\n\n위와같이 테스트 결과 state 이 변할때마다 re-rendering 이 일어났다.\n\n```js\nimport \"./App.css\"\nimport { useRef, useState } from \"react\"\nimport React from \"react\"\n\nfunction App() {\n  const inputRef = useRef(0)\n  const [user, setUser] = useState([])\n\n  const addUser = () => {\n    setUser([...user, { name: inputRef.current.value }])\n  }\n\n  console.log(\"rendered\")\n\n  return (\n    <div className=\"box\">\n      <input type=\"text\" ref={inputRef} />\n      <button onClick={addUser}>add user</button>\n      <div>\n        {user.map((user, idx) => {\n          return <h4 key={idx}>{user.name}</h4>\n        })}\n      </div>\n    </div>\n  )\n}\n\nexport default App\n```\n\n이를 위해 위와 같이 `useRef` 를 사용하는 방식으로 리팩토링 해보았고, 직접 값을 추출하여 유저를 추가 및, `map()` 을\n사용하여 화면에 유저들을 띄우는 코드로 바꾸었다.\n\n![](2022-01-04-19-04-04.png)\n\n테스트 결과, 처음 렌더링 될때 한번, 3명의 유저를 추가하였을때 각각 한번씩, 총합 4번의 'rendered' 콘솔이 찍혔다.\n\n---\n\n## 결론\n\n리액트는 `virtual DOM` 을 사용하기 때문에 특정 DOM 을 선택할때 Vanilla JS 에서 사용하던 방식인 `querySelector`\n를 사용하는 방식을 지양해야 한다. 이를 대체하기 위해 `useRef` 를 사용하게 되는데, 개념은 비슷하지만 내부에 따로 변수또한\n담을 수 있고, 이를 유용하게 사용할 수 있다.\n"},{"excerpt":"서론 나는  을 사용하다가 유료이기도 하고, 나름 에 비교하면 무겁다고 체감이 되어 다시  로 돌아왔는데, \nwebstorm 에서는 훅을 사용할때 따로 import 를 해주지 않더라도 자동적으로 import 를 해주어 이 기능이 대단하단것을 몰랐다.\n따라서, VSC 에서도  기능을 사용 할 수 없는지에 대해 구글링을 해보았다. 본론 결론적으로는 쉽게 가능…","fields":{"slug":"/vsc-react-autoimport/"},"frontmatter":{"date":"January 03, 2022","title":"VSC 리액트 auto import","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n나는 `webstorm` 을 사용하다가 유료이기도 하고, 나름 `VSC`에 비교하면 무겁다고 체감이 되어 다시 `VSC` 로 돌아왔는데, \nwebstorm 에서는 훅을 사용할때 따로 import 를 해주지 않더라도 자동적으로 import 를 해주어 이 기능이 대단하단것을 몰랐다.\n따라서, VSC 에서도 `auto import` 기능을 사용 할 수 없는지에 대해 구글링을 해보았다.\n\n---\n\n## 본론\n\n결론적으로는 쉽게 가능하다. 루트 디렉토리에 `jsconfig.json` 파일을 생성한 후 아래의 내용을 넣어주면 된다.\n\n```json\n{\n\t\"compilerOptions\": {\n\t\t\"module\": \"commonjs\",\n\t\t\"target\": \"es6\",\n\t\t\"checkJs\": true,\n\t\t\"jsx\": \"react\"\n\t},\n\t\"exclude\": [\"node_modules\"]\n}\n\n```\n\n\n"},{"excerpt":"서론 종종 리액트 공부를 하다보면  문법을 사용할 것이기 때문에  와 같이 리액트를\nimport 해주어야 한다는 말들을 들었다. 하지만 생각해보면 나는 딱히 리액트로 프로젝트를 진행할때, JSX 문법을 사용해야 한다 하더라도 컴포넌트마다 리액트를 import 하는\n행위는 따르지 않고도 문제가 발견되지 않았었다. 본론 이에따라  와  을 통하여 찾아보니, …","fields":{"slug":"/import-react/"},"frontmatter":{"date":"January 02, 2022","title":"importing React 와 JSX 사용의 상관관계","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n종종 리액트 공부를 하다보면 `JSX` 문법을 사용할 것이기 때문에 `import React from 'react'` 와 같이 리액트를\nimport 해주어야 한다는 말들을 들었다.\n\n하지만 생각해보면 나는 딱히 리액트로 프로젝트를 진행할때, JSX 문법을 사용해야 한다 하더라도 컴포넌트마다 리액트를 import 하는\n행위는 따르지 않고도 문제가 발견되지 않았었다.\n\n---\n\n## 본론\n\n이에따라 `stack overflow` 와 `구글링` 을 통하여 찾아보니, 결국 이는 과거에 행해졌던 일종의 `관습` 이라고 나는 판단하였다.\n\n리액트 공식문서에 따르면, JSX 를 사용할때 더는 import react 를 하지 않아도 된 이유는 결국 새로운 `JSX Transform` 때문이라고 한다.\n\n리액트 17버전 부터 새로운 `JSX Transform` 을 사용할 수 있는데,\n\n이는 React 를 import 하지 않고도 JSX 문법을 사용 가능하게 해주며,\n\n세팅에 따라서, bundle size 자체를 미세하게 나마 줄여줄 수 있다.\n\n### 이전 방식과의 차이\n\n```javascript\nimport React from \"react\"\n\nfunction App() {\n  return <h1>Hello World</h1>\n}\n```\n\n이전의 방식으로는 위와같은 JSX 코드를 컴파일러가 브라우저가 이해할 수 있게 컴파일을 해주었다.\n\n```js\nimport React from \"react\"\n\nfunction App() {\n  return React.createElement(\"h1\", null, \"Hello world\")\n}\n```\n\n이를 (Old JSX Transform), 자바스크립트 방식으로 바꾼다면 위와 같은 모양을 띄울 것이다.\n\n```js\nfunction App() {\n  return <h1>Hello World</h1>\n}\n```\n\n```js\nimport { jsx as _jsx } from \"react/jsx-runtime\"\n\nfunction App() {\n  return _jsx(\"h1\", { children: \"Hello world\" })\n}\n```\n\n하지만 `React 17`에 포함되어있는 `New JSX Transform` 으로 인하여, 더는 리액트는 JSX 를 `React.createElement` 로 변환하지 않고, 리액트 패키지 자체의 함수를 불러와 위와같이 작동하게된다.\n\n---\n\n## 결론\n\n리액트 17버전 이전에는, JSX 문법을 사용하기 위하여 React 를 import 했던것은 사실이다.\n\n하지만, 리액트 17버전에 출시된 NEW JSX Transform 으로 인하여, 기존에 JSX 코드를 React.createElement 로 변환하여 사용하는 방식이 아닌, 자체적으로 리액트 패키지의 엔드포인트로부터 변환하는 함수를 호출하여 변환하기에 리액트 17 버전 이상을 사용한다면, JSX 문법을 사용하기위해 더이상은 React 를 굳이 import 해줄 필요는 없다.\n"},{"excerpt":"서론 평소 프로젝트를 진행할때, 리액트를 사용한 Client 단만을 만들었는데, 나는 Express.js 에 대한 이해가 어느정도 있긴 하였다. 하지만 항상 느꼈던 점은 어떻게 Server(Node.js) 단과, Client(React ) 단을 동시에 연결할지를 몰랐었고, 알게된 과정을 기록하려 한다. 본론 내가 사용한 모듈 : Express nodemo…","fields":{"slug":"/connecting-server-client/"},"frontmatter":{"date":"December 27, 2021","title":"React && Node.js 연결하기","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n평소 프로젝트를 진행할때,\n\n리액트를 사용한 Client 단만을 만들었는데, 나는 Express.js 에 대한 이해가 어느정도 있긴 하였다.\n\n하지만 항상 느꼈던 점은 어떻게 Server(Node.js) 단과, Client(React ) 단을 동시에 연결할지를 몰랐었고, 알게된 과정을 기록하려 한다.\n\n---\n\n## 본론\n\n###내가 사용한 모듈 : \n - Express\n - nodemon\n - cocurrently\n - react\n - http-proxy-middleware\n \n##### Express :\n\n`Express`란 Node.js를 사용하여 쉽게 서버를 구성할 수 있게\n만든 클래스와 라이브러리의 집합체 이다.\n\n##### nodemon:\n\n`nodemon`이란 Node.js에 기반한 웹 어플리케이션을 개발할 때, 파일에 변경사항이 발생했을 때마다, 저절로 어플리케이션이 재실행되도록\n도와주는 패키지이다. \n\n##### cocurrently:\n\n`cocurrenly`란 명령어를 동시에 실행시켜주는 모듈이다.\n\n##### http-proxy-middleware:\n\n`http-proxy-middleware`란 여러 개의 프록시를 등록하고 옵션을 줄 때 편리하게 도와주는 모듈이다.\n\n![](.index_images/71c59333.png)\n\n---\n\n### 디렉토리 생성 및 필요 모듈 설치\n\n```\n$ mkdir my-app\n$ cd my-app\n$ echo node_modules > .gitignore\n$ npm init -y\n$ npm install express nodemon concurrently\n```\n\n서버로 사용할 `index.js` 파일을 생성 후 아래 내용을 입력해준다.\n\n```javascript\n// express 모듈 불러오기\nconst express = require(\"express\");\n\n// express 객체 생성\nconst app = express();\n\n// 기본 포트를 app 객체에 설정\nconst port = process.env.PORT || 5000;\napp.listen(port);\n\n// 미들웨어 함수를 특정 경로에 등록\napp.use(\"/api/data\", function (req, res) {\n  res.json({ greeting: \"Hello World\" });\n});\n\nconsole.log(`server running at http ${port}`);\n```\n\n루트 디렉토리의 `package.json` 파일에 아래의 script 를 추가해준다.\n\n```javascript\n\"scripts\": {\n  \"start\": \"nodemon index.js\"\n}\n```\n\n### CRA 를 사용한 Client단 생성 및 초기화\n\n```\n$ create-react-app client --use-npm --template typescript\n```\n\n### 프록시 설정\n\n`client` 디렉토리로 이동하여 `http-proxy-middleware` 를 설치한다.\n\n```\n$ cd client\n$ npm install http-proxy-middleware\n```\n\n설치 후 `/client/src` 디렉토리에 `setupProxy.js` 파일을 생성 후 아래의 내용을 작성한다.\n\n```javascript\nconst { createProxyMiddleware } = require(\"http-proxy-middleware\");\n\nmodule.exports = function (app) {\n  app.use(\n    createProxyMiddleware(\"/api/data\", {\n      target: \"http://localhost:5000\",\n      changeOrigin: true,\n    })\n  );\n};\n```\n\n### 서버(Express), 클라이언트(React) 동시 시작 설정\n\n루트 디렉토리의 `package.json` 의 스크립트를 다음과 같이 수정한다.(cocurrently 사용)\n\n```\n\"scripts\": {\n  \"start\": \"nodemon index.js\",\n  \"dev\": \"concurrently \\\"npm run dev:server\\\" \\\"npm run dev:client\\\"\",\n  \"dev:server\": \"npm start\",\n  \"dev:client\": \"cd client && npm start\"\n}\n```\n\n### 검색 폼 및 리스트 추가(임시 컴포넌트)\n\n`/client/src/` 디렉토리에 components 폴더를 생성하고 SearchForm.tsx, SearchList.tsx 파일을 생성하고 각각 아래처럼 입력해 준다.\n\n#### SearchForm.tsx\n\n```javascript\nconst fetchApi = () => {\n  fetch('api/data')\n    .then((res) => {\n      return res.json();\n    })\n    .then((data) => {\n      console.log(data);\n    });\n};\n\nconst SearchForm = () => {\n  return (\n    <div className=\"form\">\n      <input type=\"text\" className=\"form-text\" />\n      <button type=\"button\" className=\"form-btn\" onClick={fetchApi}>\n        search\n      </button>\n    </div>\n  );\n};\n\nexport default SearchForm;\n```\n\n#### SearchList.tsx\n\n```javascript\nimport React from \"react\";\n\nconst SearchList = () => {\n  return (\n    <div className=\"card-list\"></div>\n  );\n};\n\nexport default SearchList;\n```\n\nApp.tsx 변경\n\n```javascript\nimport React from \"react\";\nimport SearchForm from \"./components/SearchForm\";\nimport SearchList from \"./components/SearchList\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SearchForm />\n      <SearchList />\n    </div>\n  );\n}\n\nexport default App;\n```\n`search` 버튼을 클릭하면 `fetch` 함수로 `서버(http://localhost:5000/api/data)`에 요청을 하게 되고 응답값으로 콘솔창에 `{ greeting: \"Hello World\" }`가 출력되는 것을 확인할 수 있다.\n\n\n\n\n\n\n---\n\n\n\n\n\n\n\n"},{"excerpt":"서론 대부분 React 앱들은 ,  또는  같은 Bundling Tool 을 사용하여 여러 파일을 하나로 병합한  을 웹 패이지에 포함하여 \n한번에 전체 앱을 로드 할 수 있다. 예시) App Bundle 위의 예시는 어떠한 방식으로 Bundling 을 하는지에 대한 예시일 뿐이다. (실제와는 많이 다르다)\n 나  와 같은 툴을 사용한다면 이미 App 자…","fields":{"slug":"/react-code-splitting/"},"frontmatter":{"date":"December 18, 2021","title":"React - 코드 분할","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n대부분 React 앱들은 `Webpack`, `Rollup` 또는 `Browserify` 같은 Bundling Tool 을 사용하여 여러 파일을 하나로 병합한 `Bundled file` 을 웹 패이지에 포함하여 \n한번에 전체 앱을 로드 할 수 있다.\n\n#### 예시)\n\n##### App\n\n```javascript\n// app.js\nimport { add } from './math.js';\n\nconsole.log(add(16, 26)); // 42\n```\n\n```javascript\n// math.js\nexport function add(a, b) {\n  return a + b;\n}\n```\n\n##### Bundle\n\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n\nconsole.log(add(16, 26)); // 42\n```\n\n위의 예시는 어떠한 방식으로 Bundling 을 하는지에 대한 예시일 뿐이다. (실제와는 많이 다르다)\n`CRA` 나 `Next.js` 와 같은 툴을 사용한다면 이미 App 자체에 `Webpack` 이 설치되어 있을것이다.\n\n'흩어져 있는 파일들을 압축하여 bundling size 를 줄인다.' 라는 명목 자체는 매우 훌륭하지만, 앱이 커질수록 \n해당 번들도 커질 가능성이 농후하다. 특히 큰 사이즈의 3rd party library 를 사용하였을떄는 번들 사이즈 또한 커지기 때문에\n로드 시간이 길어지고 이는 곧 웹서비스의 성능에 악영향을 끼친다.\n\n번들이 거대해지는 것을 방지하기 위해서 `code splitting` 을 고민해보아야 한다. 코드분할은 앱을 `지연로딩` 하게 도와주고, 이는 \n앱의 코드 양을 줄이지 않고도 사용자가 필요하지 않은 코드를 불러오지 않게 하며 앱의 initializing 에 필요한 loading resource 자체를 줄여준다.\n\n---\n\n## 본론\n\n### import()\n\nApp 에 code splitting 을 도입하는 방식중 하나는 `동적 import()` 를 사용하는 것이다.\n\n#### Before\n\n```javascript\nimport { add } from './math';\n\nconsole.log(add(16, 26));\n```\n\n#### After \n\n```javascript\nimport(\"./math\").then(math => {\n  console.log(math.add(16, 26));\n});\n```\n\n`Webpack` 이 해당 구문을 만나게 되면 자체적으로 앱의 Code 를 Splitting 한다.\n\n하지만, `Babel` 을 사용한다면 Babel 은 위와같은 동적 import 를 `인식` 할수는 있지만, 자체적으로 `분할` 하지는 않는다.\n그에따라, `babel-plugin-synyax-dynamic-import` 를 사용해야만 한다.\n\n\n### React.lazy\n\n`React.lazy` 함수를 사용하 동적 import 를 사용하여 컴포넌트를 렌더링 할 수 있다.\n\n#### Before\n\n```javascript\nimport ExpampleConponent from './ExpampleConponent';\n```\n\n#### After\n\n```javascript\nconst Main = lazy(() => import(\"./components/Main\"));\nconst AboutPage = lazy(() => import(\"./components/AboutPage\"));\nconst MySkillsPage = lazy(() => import(\"./components/MySkillsPage\"));\n```\n\n### Entire Code\n\n```javascript\nconst Main = lazy(() => import(\"./components/Main\"));\nconst AboutPage = lazy(() => import(\"./components/AboutPage\"));\nconst MySkillsPage = lazy(() => import(\"./components/MySkillsPage\"));\nconst BlogPage = lazy(() => import(\"./components/BlogPage\"));\nconst WorkPage = lazy(() => import(\"./components/WorkPage\"));\nconst SoundBar = lazy(() => import(\"./subComponents/SoundBar\"));\n\nfunction App() {\n  const location = useLocation();\n\n  return (\n    <>\n      <GlobalStyle />\n\n      <ThemeProvider theme={lightTheme}>\n        <Suspense fallback={<Loading />}>\n          <SoundBar />\n\n          <AnimatePresence exitBeforeEnter>\n            <Switch location={location} key={location.pathname}>\n              <Route exact path=\"/\" component={Main} />\n\n              <Route exact path=\"/about\" component={AboutPage} />\n\n              <Route exact path=\"/blog\" component={BlogPage} />\n\n              <Route exact path=\"/work\" component={WorkPage} />\n\n              <Route exact path=\"/skills\" component={MySkillsPage} />\n            </Switch>\n          </AnimatePresence>\n        </Suspense>\n      </ThemeProvider>\n    </>\n  );\n}\n```\n\n`App` Component 가 처음 rendering 될때, 내부에 속한 번들을 자동으로 불러온다.\n\n`React.lazy` 는 동적 import() 를 호출하는 함수를 인자로 가진다. 이 함수는 React 컴포넌트를 포함하여 `default export ` 를 \n가진 모둘로 결정되는 `Promise` 를 반환해야 한다.\n\n또한, `lazy component` 는 `Suspense component` 하위에서 rendering 되어야하며, `Suspense` 는 `lazy component`  \n가 로드되길 기다리는 동안 로딩 화면과 같은 예비 컨텐츠를 보여줄 수 있게 해준다.\n\n마지막의 Entire Code 에서 주목해야 할 점은, 그래서 Code Splitting 을 도대체 어느 곳에 도입하여야 한다는 점이다.\n나는 이를 시작하는 좋은 장소는  `Route` 라고 생각하여 해당 코드를 작성하였다. 아무리 `SPA` 라고 할지라도,  page transition 이 발생하는 부분에서\nloading 시간은 필연적으로 발생하며 대부분의 페이지를 한번에 렌더링하기에 사용자가 페이지를 렌더링 하는 동안 다른 요소와 상호작용 또한 하지 않기 때문이다.\n\n---\n\n## 결론\n\nBundling 툴은 보통 코드를 압축하기에 이에따른 import 하는 과정에서 너무 많은 리소스를 낭비 할 수 있기에,\n이부분에 대해서는 code splitting 이 유용하게 쓰인다. \n\n이 과정에서 동적으로 import() 함수를 쓰는 방법이 존재하지만, page transition 시간에 다른 예비 요소를 사용할 수 있기에\n나는 주로 Route 에 Suspense 와 lazy 를 사용하는 방법을 좋아한다.\n\n\n\n\n"},{"excerpt":"서론 이전의 포스트에서 타입검사를 왜 조심해야 하는지에 대해 말해보았다. 가장 주요한 이유로는 자바스크립트가 부족한 언어이다. 자바스크립트가 너무 느슨하다. 자바스크립트가 너무 유연하다. 자바스크립트가 동적이다. 라고 생각을 할 수 있을지도 모른다. 본론  하지만 javascript equality table 이라고 검색해보면, 이러한 테이블인 나온다. …","fields":{"slug":"/careful-typecast/"},"frontmatter":{"date":"December 02, 2021","title":"JS - 형변환 주의하기","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 서론\n\n이전의 포스트에서 타입검사를 왜 조심해야 하는지에 대해 말해보았다.\n\n\n\n가장 주요한 이유로는\n- 자바스크립트가 부족한 언어이다.\n- 자바스크립트가 너무 느슨하다.\n- 자바스크립트가 너무 유연하다.\n- 자바스크립트가 동적이다.\n\n라고 생각을 할 수 있을지도 모른다.\n\n---\n\n## 본론\n![](.index_images/f4615b5d.png)\n\n하지만 javascript equality table 이라고 검색해보면, 이러한 테이블인 나온다. 이처럼 기본적인 == equality operator 를 사용하면 많은 모순점이 생기기 마련이지만,\n\n![](.index_images/b13259cc.png)\n\n위처럼 === strict equality operator 를 사용한다면 벌써 많은 오류를 피할 수 있다.\n\n하지만, 여기에서 끝나지 않고 `JS의 형변환` 그 자체에 주목할 필요는 있다.\n\n```javascript\n'1' == 1 // true\n1 == true // true\n0 == false // ture\n```\n\n위의 코드는 사람이 보면 '느슨한 검사를 하고 있구나.'\n\n라고 생각을 할 수 있지만, 결국에는 `형번환` 이 일어난 케이스이다. 이는 JS 의 `암묵적인 형변환` 이라고도 부른다.\n\n```javascript\n11 + '문자와 결합' // '11 문자와 결합`\n\n!!'일반 문자열' // true\n!!'' // false (빈 문자열)\n\nparseInt('9.999', 10);\n```\n\n위는 일전에 언급한 JS 의 암묵적인 형번환의 예시들이다.\n\n잠시 다른 얘기를 하자면 마지막줄의 `parseInt` 에서 두번째 인자로 몇진수로 변환할 것인지에 따른 값을 정할 수 있지만, 많은분들이 default 값으로 10진수가 들어가겠지.. 하고 생략을 하는 경우를 종종 보았다.\n\n하지만 내장된 `parseInt` 메서드의 기본 진수값은 꼭 10진수가 아니기 때문에 오류를 피하기위해서는 꼭 두번째 인자를 넣는것을 추천한다.\n\n굳이 따지자면, 위의 세줄은 압묵적인 형변환이 일어나지만, 마지막 `parseInt`는 누가봐도 형변환을 명시적으로 표현하였기 때문에 압묵적이지만은 않다고 말할수 있다.\n\n결론은 압묵적인 형변환은 본인도 헷갈릴 수 있고, 팀원들에게도 혼란을 초래할 수 있기 때문에, 명시적인 형변환을 지향해야 한단는 점이다.\n\n```javascript\nString(11 + '문자와 결합') // '11 문자와 결합`\n\nBoolean('일반 문자열') // true\nBoolean('') // false (빈  문자열)\n\nparseInt('9.999', 10);\n```\n\n\n이런식으로 명시적인 형변환을 사용 할 수 있다.\n\n---\n\n## 결론\n\n자바스크립트에서 사용자가 형변환을 하였을때는 `명시적인 형변환` 이라고 할 수 있다.\n\n하지만 사용자가 아닌, JS 엔진이 형변환을 자동적으로 하였을때는 `암시적인 형변환` 이라고 할 수 있다.\n\n우리는 사람이 코드를 작성하는 것이기 때문에, 예측가능한 `명시적인 형변환` 을 지향해야한다.\n\n\n\n\n"},{"excerpt":"서론  란 JS의 를 뜻한다. mdn 문서에 따르면  두개의 equal signs 은 그냥  라고 부르고,  , 즉 세개의 equal sign 은  라고 부른다.  이 둘은 무시 할 수 없는 크나큰 차이를 불러 일으킨다. 본론 자바스크립트를 보통 '미개한 언어이다.' 혹은 '헷갈리는 언어이다' 라고 생각하시는 분들은 아마 이러한 상황을 겪어본 분들일지도 …","fields":{"slug":"/no-eqeq/"},"frontmatter":{"date":"December 01, 2021","title":"JS - eqeq 줄이기","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 서론\n\n`eqeq` 란 JS의 `동등 연산자`를 뜻한다.\n\nmdn 문서에 따르면 `==` 두개의 equal signs 은 그냥 `equality operator` 라고 부르고, \n\n`===`, 즉 세개의 equal sign 은 `strict equality opeartor` 라고 부른다. \n\n이 둘은 무시 할 수 없는 크나큰 차이를 불러 일으킨다.\n\n\n\n\n\n---\n\n## 본론\n\n```javascript\n'1' == 1 // true\n1 == true // true\n```\n\n자바스크립트를 보통 '미개한 언어이다.' 혹은 '헷갈리는 언어이다' 라고 생각하시는 분들은 아마 이러한 상황을 겪어본 분들일지도 모른다.\n\n동등 연산자는 형변환, 즉 `type casting`을 불러 일으킨다.\n\n위의 예시처럼 동등연산자를 `strict equlaity operator` 가 아닌, 일반 `equality operator` 를 사용한다면, 이렇게 위험한 type casting 이 발생 할 수 있다.\n\n어떻게 string 과 number 를 비교하는데 true 가 나오고 \nnumber 와 boolean 을 비교하는데 true 가 나올 수 있단말인가!\n\n```javascript\n'1' === 1 // false\n1 === true // false\n```\n\n그러므로 위처럼 두개의 항을 비교할 때에는 `strict equality operator` 를 사용하는것을 추천한다.\n\n```javascript\nconst inputNum = $('#inputNum');\n\nconsole.log(inputNum.value) // '0' (string)\nif (inputNum.value === 0) {\n  console.log('the Number is Zero') \n  // passed\n}\n```\n위처 input 값 자체가 string format 을 뱉어내기 때문에\nstrict equality operator 로 if 연산을 하면 무시해버리게 된다.\n\n```javascript\nconst inputNum = $('#inputNum');\n\nconsole.log(inputNum.value) // '0' (string)\nif (inputNum.value == 0) {\n  console.log('the Number is Zero') \n  // the Number is Zero\n}\n```\n\n하지만, 이미 JS의 이런 특성을 파악한 개발자들은 이를 역이용 하여 일반 equality opearator 로 비교하는 방법 또한 생각해낼 수 있지만, 이는 팀원들의 입장에서는 오류를 초래할 수 있기때문에 좋은 방법이라고만은 생각이 들지 않는다.\n\n```javascript\nconst inputNum = $('#inputNum');\n\nconsole.log(inputNum.value) // '0' (string)\nif (Number(inputNum.value) === 0) {\n  console.log('the Number is Zero') \n  // the Number is Zero\n}\n```\n\n그러므로 어떻게든 수동으로라도 형변환을 해서 위와같이 안전하게 strict equality operator 를 사용하는것을 추천한다.\n\n\n\n---\n\n## 결론\n\n다른언어에서 동등연산자로 쓰이는 `==` (equality operator)  는 \n\nJS 에서는 일반, 혹은 느슨한 동등연산자로 불리우며, 이는 강제로 typecasting 을 불러 일으키기 때문에,\n\n가능하면 이를 지양하는 방식을 택하고, 수동으로 자신이 형변환을 해야하는 상황에 처하더라도 `===` (strict equality operator) 를 지향해야한다.\n\n\n\n\n\n"},{"excerpt":"서론  와 , 결국 값으로 쓰기에는 둘다 무언가 없다 라는 것을 의미한다. 인터넷만 봐도 이 둘의 차이때문에 혼란을 겪는 사람이 많고, 이에따라 이를 풍자하는 밈들 또한 많다. 언어적으로 더 엄격하다면 이러한 일도 없겠지만 JS 에서는 헷갈릴 가능성이 높다고 생각한다. 본론 을 뒤집어보면은 true 라고 표현하지만, 을 으로 바꾸면 false 라고 표현한…","fields":{"slug":"/undefined-null/"},"frontmatter":{"date":"November 30, 2021","title":"JS - undefined & null","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 서론\n\n`undefined` 와 `null`, 결국 값으로 쓰기에는 둘다 무언가 없다 라는 것을 의미한다.\n\n인터넷만 봐도 이 둘의 차이때문에 혼란을 겪는 사람이 많고, 이에따라 이를 풍자하는 밈들 또한 많다.\n\n언어적으로 더 엄격하다면 이러한 일도 없겠지만 JS 에서는 헷갈릴 가능성이 높다고 생각한다.\n\n\n---\n\n## 본론\n\n```javascript\n!null // true\n!!null // false\n\nnull === false // false\n!null === true // true\n\nnull + 123 // 123\n\n```\n\n`null`을 뒤집어보면은 true 라고 표현하지만,\n\n`null`을 `boolean`으로 바꾸면 false 라고 표현한다.\n\n그렇다면 null 은 false 인가? 그것도 아니라고 한다.\n\n그렇다면 !null 은 true 인가? 맞다고 한다.\n\n머리가 지끈지끈하다.\n\n또한, null 은 수학적으로는 `비어있다` 라는 state 를 표현하기에 0으로 간주한다.\n\n때문에 null 은 비어있다 를 명시적으로 표현한다.\n\n```javascript\nlet variable;\n\ntypeof variable // undefined\n\nundefined + 10 // NaN\n\n!undefined // true\n```\n\n그렇다면 undefined 는? \n\n`아무것도 지정하지 않았을 때에 기본값` 이라고 생각이 든다.\n\n변수를 선언하였지만 이에 값을 할당하지 않았다 이다.\n\n하지만 연산을 시도해 보았을 때 null 은 0 으로 간주되었지만, undefined 는 NaN 즉 not a number 라고 하기에 더더욱 헷갈릴 수 있다.\n\n또한 !undefined 는 또 true 라고 값이 찍힌다.\n\n```javascript\nundefined == null // true\nundefined === null // false\n!undefined === !null // true\n``` \n\n위의 예시를 보면 정말 머리가 아플정도로 헷갈리고 모순점들또한 머리에 생기기 마련이다.\n\n그러므로, undefined 와 null 을 많이 활용하는 코드를 작성하기 보다는, 하나의 팀에서 둘중에 하나만 선택하여 컨벤션 자체를 만드는 것이 좋다고 생각한다.\n\n\n\n\n---\n\n## 결론\n\nundefined 와 null 의 차이점이 많지만,\n\nundefined 와 null 은 결국 값이 없거나 정의되지 않다는 차이점이 있고,\n\nundefined 는 NaN 이지만 null 은 숫자적으로 표현하였을때 0에 가깝다.\n\nundefined 의 type 은 undefined 이지만 null 의 type 은 object 이다.\n\n그래서, 결국 이 둘의 쓰임을 조심해야만 한다.\n\n\n"},{"excerpt":"서론 간단한 앱을 개발할때도 타입검사를 흔하게 사용한다. JS 에서 타입을 검사할때 제일먼저 떠오르는 것은  연산자 이다. typeof 는 우항에 있는 피연산자를 평가한 후, 문자열로 반환해준다.\n하지만, typeof 는 치명적인 단점이 있는데, 모든것을 커버해주지 못한다는 것이다. 이뜻은, Primitive 원시값, Reference 자료형에 해당하는 …","fields":{"slug":"/types-of-javascript/"},"frontmatter":{"date":"November 29, 2021","title":"JS - 타입 검사","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 서론\n\n간단한 앱을 개발할때도 타입검사를 흔하게 사용한다. JS 에서 타입을 검사할때 제일먼저 떠오르는 것은 `typeof` 연산자 이다.\n\ntypeof 는 우항에 있는 피연산자를 평가한 후, 문자열로 반환해준다.\n하지만, typeof 는 치명적인 단점이 있는데, 모든것을 커버해주지 못한다는 것이다.\n\n이뜻은, Primitive 원시값, Reference 자료형에 해당하는 객체들이 존재하는데, 원시값은 불변하기에 타입검사를 할때, 괜찮을 수 있지만, `array`, `function`, `date` 등이 Reference type 에 해당하는 object 로 치부되기에, `typeof` 연산자로 타입검사를 할 때 모순점이 생긴다.\n\n---\n\n## 본론\n\n```javascript\nfunction myFunc() {}\nclass myClass {}\nconst str = new String('문자열')\n\ntypeof myFunc // 'function'\ntypeof myClass // 'function'\ntypeof str // 'object'\ntypeof '문자열' // 'string'\ntypeof 123 // 'number'\n```\n\n위와같이 primitive type 은 typeof 연산자로 검사가 가능하지만, typeof 연산자로 reference type 을 검사 할 때는 굉장히 많은 위험을 동반한다.\n\n```javascript\ntypeof null // 'object'\n```\n\n가장 문제가 되는 녀석은 `null` 이다. null 의 type 을 object 로 찍어내는 것은 이해가 안가는 부분이 존재하고, 사실 이는 javascript 가 공식적으로 인정한 `오류` 이다. js 가 발전을 하면서 언어적으로 이는 수정을 할 수 없다고 판단을 하였다고 한다.\n\nJavascript 는 `동적` 으로 변하는 언어이지만, 위험성은 `type` 까지 동적이 된다는 점이다.\n\n`typeof` 의 단점을 커버하기위해 `instanceof` 라는 일종의 연산자의 한 종류를 사용 할 수 있는데, 이 연산자는 객체의 prototype chain 을 검사 할 수 있게 해준다.\n\n```javascript\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nconst Hwani = new Person('hwani', 24);\n\nconst Lee = {\n  name: 'hwani',\n  age: 24\n}\n\nHwani instanceof Person // true\nLee instanceof Person // false\n```\n\n여기에서 감을 잡을 수 있다. typeof 는 불변한 primitive value 들을 검사 할 수 있는데, instanceof 는 객체에 대해 확인하기에 요긴하다.\n\n하지만 여기서도 함정이 존재한다.\n\n```javascript\nconst arr = [];\nconst func = function() {};\nconst date = new Date();\n\narr instanceof Array // true\nfunc instanceof Function // true\ndate instanceof Date // true\n```\n이렇게만 보면 instaceof 라는 연산자를 사용하여 좌항과 우항을 잘 비교하고 있는것처럼 보이지만\n\n```javascript\nconst arr = [];\nconst func = function() {};\nconst date = new Date();\n\narr instanceof Object // true\nfunc instanceof Object // true\ndate instanceof Object // true\n```\n\n결국 reference type 이기 때문에 `prototype chain` 을 타보면 최상위는 `object` 라는 결론에 도달하게 된다.\n\n때문에, 더더욱 타입 검사를 하기에 어려움이 생긴다.\n\n위의 `typeof` 연산자와 `instanceof` 연산자의 단점 때문에 다른 하나의 방법이 더 존재한다.\n`object 의 prototype chain` 자체를 역이용하는 방법이다.\n\n```javascript\nconst arr = [];\nconst func = function() {};\nconst date = new Date();\n\nObject\n  .prototype\n  .toString\n  .call(new String('string')) \n// '[object String]'\n\nObject\n  .prototype\n  .toString\n  .call(arr)\n// '[object Array]'\n\nObject\n  .prototype\n  .toString\n  .call(func)\n// '[object Function]'\n\nObject\n  .prototype\n  .toString\n  .call(date)\n// '[object Date]'\n```\n\n이런식으로 reference type 까지 검사 할 수 있다.\n\n하지만 이 방식또한 무적이라고 말 할 수 없기 때문에 타입을 검사할 때 하나하나 노하우를 쌓아가는 것이 중요하다.\n\n주로 나는 `stack overflow` 를 이용하는데 이때, 검색 키워드는 \n\n- javascript is array\n- javascript is function\n- javascript is date\n\n와 같이 검색하면 주로 많은 답변이 나온다.\n\n---\n\n## 결론\n\n자바스크립트는 동적을 타입을 가진 언어이다.\n\n그렇기 때문에 타입 검사가 어렵다. \n\n많은 타입 검사가 존재하기 때문에 다 외우기 보다는 검색을 통하여 타입 검사를 체크하는 방법을 추천한다.\n\n타입 검사를 할 때에는 항상 `primitive type` 과 `reference type` 을 잘 생각하며 유의해야하며 \n\n`typeof` 연산자는 무적이 아니다. \n\n"},{"excerpt":"Intro 5번째 Mini Vanilla Js Project 이다. 이번에는  라는  를 사용하여 개인자산 체크 기능을 만들어보았다! Main 소스코드 liveDemo  Conclusion JS 에서 가장 흔하게 사용되는? 메서드인 , , , 를 주축으로 구현을 해보았다. 간편화를 위해, input 으로 user 정보를 받는것이 아닌, 외부 api 를 사…","fields":{"slug":"/personal-information-list/"},"frontmatter":{"date":"November 28, 2021","title":"개인자산 체크 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n5번째 Mini Vanilla Js Project 이다.\n\n이번에는 `Random User Generator-API` 라는 `Third-party api` 를 사용하여 개인자산 체크 기능을 만들어보았다!\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Personal-Information-List)\n- [liveDemo](https://hwani-vanillajs.netlify.app/personal-information-list/)\n\n\n![](personal.gif)\n\n---\n\n## Conclusion\n\nJS 에서 가장 흔하게 사용되는? 메서드인 `sort`, `filter`, `reduce`, 를 주축으로 구현을 해보았다.\n\n간편화를 위해, input 으로 user 정보를 받는것이 아닌, 외부 api 를 사용하여 쉽게 예시 user 를 추가 할 수 있게 했고,\n\n이를 좌축의 aside button 들에 event mapping 해놓았다.\n\n가장 고민했던 부분은, event 가 실행되어 유저가 추가되었을때, 유저의 데이터가 변할때 어떤 방식으로 DOM 자체를 refresh 없이 re-rendering 시킬것인가 였다.\n\nReact 는 Virtual DOM 을 사용하여 Diff 를 파악한 후, 변경점이 필요한 부분만 바꾸어주는 방식을 사용하지만, Vanilla JS 로 이를 직접 구현하기에는 나중에 내 기준에서는 (대형..?) 프로젝트 및 과제로 미루어두고,\n\n우선은 state 를 가지고 있는 화면단을 하나의 배열로 관리하며, 해당 state 가 변경될 때, 통째로 re-rendering 하는 방식으로 구현하였다. \n\n이번에도 느낀것이지만, vanillaJS 프로젝트를 진행할때마다, framework 이 자체적으로 가지고 있는 기능 혹은 library 가 대신 해주었던 기능들을 직접 사소하나마 찾아가며 구현하며 내 프로젝트와의 차이점을 찾고, 해당 framework 이나 library 의 기능들의 작동 방식을 차차 알아갈 수 있다는 점이 아직은 재밌게 느껴졌다!"},{"excerpt":"Intro 6번째 Mini Vanilla Js Project 이다. 이번에는 순수  와  를 사용하여 Sidebar 와 Modal 을 직접 구현해보았다. Main 소스코드 liveDemo  Conclusion 사실 내가 프로젝트를 진행할때  를 사용했던 이유는 style 적인 이유보다는 JS? 적인 이유가 더 컸다.\n이 뜻은, UI Library 를 사용…","fields":{"slug":"/menu-sidebar-modal/"},"frontmatter":{"date":"November 28, 2021","title":"사이드바, 모달 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n6번째 Mini Vanilla Js Project 이다.\n\n이번에는 순수 `css` 와 `vanilla JS` 를 사용하여 Sidebar 와 Modal 을 직접 구현해보았다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Menu-Sidebar-Modal)\n- [liveDemo](https://hwani-vanillajs.netlify.app/menu-sidebar-modal/)\n\n\n![](modal.gif)\n\n---\n\n## Conclusion\n\n사실 내가 프로젝트를 진행할때 `UI Library` 를 사용했던 이유는 style 적인 이유보다는 JS? 적인 이유가 더 컸다.\n이 뜻은, UI Library 를 사용할때도 보통 style 적인 부분은 모두 갈아엎으며 나의 입맛대로 꾸몄지만, 예를 들어,\n\n- 'x' 표시를 누르면 모달이 닫힌다.\n- 모달 바깥의 영역을 누르면 부드럽게 animation 과 함께 자연스럽게 닫힌다.\n- 사이드바 햄버거 아이콘을 누르면 자연스럽게 화면이 이동하며 sidebar 가 펼쳐진다\n\n와 같은 기능적인 부분에 대해 무지했기때문에 이런부분은 주로 library 에 의존하곤 했다.\n\n하지만, 지속적인 구글링과 공부 끝에, 이번 기회에 노력하면 해볼 수 있지 않을까? 라는 결론에 도달했고, \n나의 기대치에 맞는 화면을 직접 구성 할 수 있게 되었다. \n\n결론적으로는, 사실 JS 부분은 복잡하지 않고 간단하지만, 주로 CSS 적인 변화와 움직임을 toggle 로 컨트롤하면서 여러가지 상황에 대처할 수 있게 구현하는 방식을 택하였다."},{"excerpt":"Intro 4번째 Mini Vanilla Js Project 이다. 이번에는  라는  를 사용하여 환전 기능을 만들어보았다! Main 소스코드 liveDemo  Conclusion 처음으로 vanillaJS 를 사용하며, third-party api 를 사용해보았다. 기존에 리액트를 배우고 사용했을때는 데이터를 요청하는 방식 자체에 대해서 당연하게 고민도…","fields":{"slug":"/exchange-rate-calculator/"},"frontmatter":{"date":"November 27, 2021","title":"환전기 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n4번째 Mini Vanilla Js Project 이다.\n\n이번에는 `ExchangeRate-API` 라는 `Third-party api` 를 사용하여 환전 기능을 만들어보았다!\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Exchange-Rate-Calculator)\n- [liveDemo](https://hwani-vanillajs.netlify.app/exchange-rate-calculator/)\n\n\n![](exchange-cal.gif)\n\n---\n\n## Conclusion\n\n처음으로 vanillaJS 를 사용하며, third-party api 를 사용해보았다.\n\n기존에 리액트를 배우고 사용했을때는 데이터를 요청하는 방식 자체에 대해서 당연하게 고민도 하지 않은채 마구잡이로 남들이 사용하는 방식대로 `request` 나 `axios` 를 썼었는데,\n\n이번 프로젝트를 진행하며, 브라우저가 자체적으로 `fetch()` 함수를 지원한다는 것을 배웠고, 이를 사용해보았다. 결과는 내 기준에서는 성공적이였고, 고민을 해보았던 점은, 결국 `request`, `axios` 도 같은 `Http 비동기 통신 library` 일텐데\n\n이들을 대체할 수 있는 내장 함수인 `fetch()` 를 main 으로 사용한다면 `js bundling size` 면에서 유리하지 않을까 였다.\n\n이 문제에 대해 찾아본 결과, 내 생각대로라면 `fetch()` 를 main 으로 쓰는것이 바람직 할 수 있겠지만, \n\n- 지원하지 않는 브라우저가 있다  (...IE11)\n- 네트워크 에러 발생 시 response timeout 없이 기다려야한다.\n- JSON 으로 변환해주는 과정이 필요하다.\n\n위 세가지의 단점때문에 아직 외부 라이브러리들을 사용을 한다는 의견이 많고,  나의 실력으로써는 더 많이 경험하고 써보면서 각자의 장단점을 몸소 직접 체험하는 수밖에 없을 것 같다."},{"excerpt":"Intro 새번째 Mini Vanilla Js Project 이다. video api 를 사용하여 비디오 플레이어를 만들어 보았다. Main 소스코드 liveDemo  Conclusion 각 버튼들과 상황에 따른 전반적인 동작 원리와 기능들을 직접 공부하고 구현하려다 보니, 간단할지라도 배우는점이 많았다.  이제 앞으로 프로젝트를 진행하며  태그를 사용해…","fields":{"slug":"/custom-video-player/"},"frontmatter":{"date":"November 27, 2021","title":"비디오 플레이어 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n새번째 Mini Vanilla Js Project 이다.\n\nvideo api 를 사용하여 비디오 플레이어를 만들어 보았다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Custom-Video-Player)\n- [liveDemo](https://hwani-vanillajs.netlify.app/custom-video-player/)\n\n\n![](vid-player.gif)\n\n---\n\n## Conclusion\n\n각 버튼들과 상황에 따른 전반적인 동작 원리와 기능들을 직접 공부하고 구현하려다 보니, 간단할지라도 배우는점이 많았다. \n\n이제 앞으로 프로젝트를 진행하며 `video` 태그를 사용해야 할때 겁먹지 않기를 바라며 ㅎㅎ"},{"excerpt":"Intro 두번째 Mini Vanilla Js Project 이다. 이번에는 간단하게 영화 좌석 선택을 만들어보았고, 전과 다른점이 있다면, 이번에는  를 사용하여,  된 후에도 데이터가 남아있게 하였다. Main 소스코드 liveDemo  Conclusion Vanilla JS 프로젝트를 진행하면서,  를 사용할때도,  속성을 사용할 수 있다는 것을 배…","fields":{"slug":"/movie-seat-booking/"},"frontmatter":{"date":"November 26, 2021","title":"영화 좌석 선택 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n두번째 Mini Vanilla Js Project 이다.\n\n이번에는 간단하게 영화 좌석 선택을 만들어보았고, 전과 다른점이 있다면,\n\n이번에는 `localStorage` 를 사용하여, `refresh` 된 후에도 데이터가 남아있게 하였다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Movie-Seat-Booking)\n- [liveDemo](https://hwani-vanillajs.netlify.app/form-validator/)\n\n\n![](movie-seat.gif)\n\n---\n\n## Conclusion\n\nVanilla JS 프로젝트를 진행하면서, `document.querySelector` 를 사용할때도, `not()` 속성을 사용할 수 있다는 것을 배웠고, \n\nlocalStorage 에서 데이터가 어떤식으로 들어가고 나오는지에 대해 깨달은 점도 존재하다. 더불어 CSS 공부도 나름 열심히 하게 되는 것 같다!\n\nUI Library 가 필요없을 경지에 도달하는 그날을 기다리며.. ㅎㅎ"},{"excerpt":"Intro 리액트를 공부하거나, 프로젝트를 했으로때 주로 간단한 ui 적인 부분은 라이브러리를 사용하여 해결 했었지만, vanilla JS 를 사용하여 내가 직접 가능한 부분은 공부하여 만들어 보려고 하였다. Main 소스코드 liveDemo  HTML JS","fields":{"slug":"/vainllajs-registration-form/"},"frontmatter":{"date":"November 24, 2021","title":"회원가입 폼 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n리액트를 공부하거나, 프로젝트를 했으로때 주로 간단한 ui 적인 부분은 라이브러리를 사용하여 해결 했었지만, vanilla JS 를 사용하여 내가 직접 가능한 부분은 공부하여 만들어 보려고 하였다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Form-Validator)\n- [liveDemo](https://hwani-vanillajs.netlify.app/form-validator/)\n\n\n![](form_val.gif)\n\n---\n\n## HTML\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\"\n        content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <link rel=\"stylesheet\" href=\"./styles.css\">\n  <title>Form Validator</title>\n</head>\n<body>\n<div class=\"container\">\n  <form action=\"\" id=\"form\" class=\"form\">\n    <h2>Register With Us</h2>\n    <div class=\"form-control\">\n      <label for=\"username\">Username</label>\n      <input type=\"text\" id=\"username\" placeholder=\"Enter username\">\n      <small>Error message</small>\n    </div>\n    <div class=\"form-control\">\n      <label for=\"email\">Email</label>\n      <input type=\"text\" id=\"email\" placeholder=\"Enter email\">\n      <small>Error message</small>\n    </div>\n    <div class=\"form-control\">\n      <label for=\"password\">Password</label>\n      <input type=\"password\" id=\"password\" placeholder=\"Enter password\">\n      <small>Error message</small>\n    </div>\n    <div class=\"form-control\">\n      <label for=\"password\">Confirm Password</label>\n      <input type=\"password\" id=\"password2\" placeholder=\"Enter password again\">\n      <small>Error message</small>\n    </div>\n    <button>Submit</button>\n  </form>\n</div>\n<script src=\"script.js\"></script>\n</body>\n</html>\n```\n\n## JS\n\n```javascript\nconst form = document.getElementById('form');\nconst username = document.getElementById('username');\nconst email = document.getElementById('email');\nconst password = document.getElementById('password');\nconst password2 = document.getElementById('password2');\n\n// Show input error message\nconst showError = (input, message) => {\n  const formControl = input.parentElement;\n  formControl.className = 'form-control error';\n  const small = formControl.querySelector('small');\n  small.innerText = message;\n}\n\n// Show success outline\nconst showSuccess = (input) => {\n  const formControl = input.parentElement;\n  formControl.className = 'form-control success';\n}\n\n// Check email is valid\nconst isValidEmail = (email) => {\n  const re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  if (re.test(email.value)) {\n    showSuccess(email)\n  } else {\n    showError(email, 'Email is not valid');\n  }\n}\n\n// Get field name\nconst getFieldName = (input) => {\n  return input.id.charAt(0).toUpperCase() + input.id.slice(1);\n}\n\n// Check required fields\nconst checkRequired = (inputArr) => {\n  inputArr.forEach(input => {\n    if (input.value.trim() === '') {\n      showError(input, `${getFieldName(input)} is required`);\n    } else {\n      showSuccess(input);\n    }\n  })\n}\n\n// Check input length\nconst checkLength = (input, min, max) => {\n  if (input.value.length < min) {\n    showError(input, `${getFieldName(input)} must be at least ${min} characters`)\n  } else if (input.value.length > max) {\n    showError(input, `${getFieldName(input)} must be at less than ${max} characters`)\n  }\n}\n\n// Check passwords match\nconst checkPasswordsMatch = (input1, input2) => {\n  if(input1.value !== input2.value) {\n    showError(input2, 'Password do not match');\n  }\n}\n\n// Event listeners\nform.addEventListener('submit', e => {\n  e.preventDefault();\n\n  checkRequired([username, email, password, password2]);\n  checkLength(username, 8, 15);\n  checkLength(password, 6, 25);\n  isValidEmail(email);\n  checkPasswordsMatch(password, password2);\n});\n```"},{"excerpt":"호이스팅이란? 호이스팅을 간단하게 말하자면 런타임시에 과 이 분리된 것을 뜻한다. 런타임시기는 프로그램이 동작 할 때를 의미한다. 코드를 잘성할 때는 이 스코프는 이렇게 동작할 것이다. 라고 예상을 하는데,\n실상 런타임시에는 그렇게 동작하지 않을 때가 있다. 해당 현상중의 하나가  인데, 호이스팅은 로 선언한 변수 초기화가 제대로 되어있지 않았을때,  상…","fields":{"slug":"/no-hoisting/"},"frontmatter":{"date":"November 23, 2021","title":"JS - 호이스팅 주의하기","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 호이스팅이란?\n\n호이스팅을 간단하게 말하자면 런타임시에 `선언`과 `할당`이 분리된 것을 뜻한다.\n\n런타임시기는 프로그램이 동작 할 때를 의미한다.\n\n코드를 잘성할 때는 이 스코프는 이렇게 동작할 것이다. 라고 예상을 하는데,\n실상 런타임시에는 그렇게 동작하지 않을 때가 있다.\n\n해당 현상중의 하나가 `호이스팅` 인데, 호이스팅은 `var`로 선언한 변수 초기화가 제대로 되어있지 않았을때, `undefined` 상태로 코드의 상단으로 끌어올려지는 것을 뜻한다.\n\n물론 `let & const` 를 사용한다면 이러한 현상을 잘 겪지 않겠지만 (TDZ)\n`var`에서는 종종 일어난다.\n\n--- \n\n## 예시\n\n```javascript\nvar global = 0;\n\nfunction outer () {\n  console.log(global); // undefined\n  var global = 5;\n  \n  function inner () {\n    var global = 10;\n    console.log(global); // 10\n  }\n  \n  inner();\n  \n  global = 1;\n  console.log(global) // 1\n}\n\nouter();\n```\n\n위의 코드가 호이스팅이 동작한 사례라고 생각한다.\n\n선언과 할당 부분이 메모리 공간을 선언하기전에, 미리 할당을 하기때문에 이러한 일이 발생한다.\n\n## 쉬운예시\n\n```javascript\nfunction duplicatedVar() {\n  var a;\n  \n  console.log(a); // undefined\n  \n  var a = 100;\n  \n  console.log(a); // 100\n}\n\nconsole.log(duplicatedVar());\n```\n\nvar 는 중복 선언이 가능하고, 중복 선언해도 오류 없이 undefined 를 반환한다.\n원래 다른 언어였다면, 이 코드는 에러를 반환한다는 예측을 할텐데, 예측과 다르게 런타임 시에 undefined 를 리턴하기에\n위험할 수 있다.\n\n## 골때리는 예시\n\n```javascript\nvar sum;\n\nconsole.log(typeof sum); // function\n\nfunction sum() {\n  return 1 + 2;\n};\n```\n\n콘솔로 찍어보니, 변수가 아닌 함수라고 말한다. 결국 아래에 위치한 함수조차도 hoisting 이 되었다는 뜻이다.\n함수 선언문이 변수를 뒤집어 엎어버린다.\n\n---\n\n## 결론 \n\n호이스팅은 런타임시에 바로 선언을 최상단으로 끌어올려 줌으로써, 문제는 코드를 작성할 때 예측하지 못한 실행결과를 노출하게 된다. 이러한 예측하지 못하는 상황들을 탈피하기 위해 var 를 지양한다.\n\n또한 함수또한 호이스팅이 되고, 이를 탈피하기 위해서는 함수 표현식을 사용하는 방법이 있다.\n\nlet 과 const 를 지향하자!\n\n"},{"excerpt":"임시변수란? 자바스크립트를 다룰때, 기존의 Scope 를 다룰때,   을 사용하지 말고,   또한 피해야 한다고 들었다. 임시변수란, Scope 안에서 전역변수처럼 활용되는 친구를 생각한다. 위의 코드의  도 마찬가지이다.\n어떻게 보면 이것도 const 니까 문제 없을까? 라고 생각 할 수 있지만, 이 임시 객체도 함수가 커지  이나 다름없는 상황이 발생…","fields":{"slug":"/no-temporary-variable/"},"frontmatter":{"date":"November 22, 2021","title":"JS - 임시변수 제거하기","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 임시변수란?\n\n자바스크립트를 다룰때, 기존의 Scope 를 다룰때, \n\n`전역공간` 을 사용하지 말고,  `var` 또한 피해야 한다고 들었다.\n\n#### 임시변수란, Scope 안에서 전역변수처럼 활용되는 친구를 생각한다.\n\n```javascript\nconst getObj = () => {\n    const result = {};\n    \n    result.title = 'tmp_variable'\n    result.text = 'wow'\n    \n    return result;\n}\n```\n\n위의 코드의 `const result = {}` 도 마찬가지이다.\n어떻게 보면 이것도 const 니까 문제 없을까? 라고 생각 할 수 있지만, 이 임시 객체도 함수가 커지 `전역공간` 이나 다름없는 상황이 발생할 수 있다.\n\n그렇게 되면 위험한 상황이 나올 수 있다. 임시변수를 만들었을때, 누군가가 같이 일하는 팀원이 미래의 내가 유혹을 받을 수 있다는 말이다.\n\n그러면 이 임시 변수를 어떻게 접근 할까에 대해서는, 함수를 작게 쪼개는 방법도 있지만, \n\n```javascript\nconst getObj = () => {\n    const result = {\n      title: 'tmp_variable',\n      text: 'wow',\n    };\n    return result;\n}\n```\n\n이런식으로 간소화 할 수도 있다. 일단은 코드가 명확해지고,\n아까는 굳이 선언 후 접근하는 과정으로 나뉘어있었기 때문에,\n누구나 고칠 수 있는 느낌이 들었다.\n\n하지만, 더 명확하게 바꿀 수 있는 방법이 뭐가 있을까?\n\n```javascript\nconst getObj = () => {\n    return {\n      title: 'tmp_variable',\n      text: 'wow',\n    };\n}\n```\n\n이런식으로 바로 반환하는는 방법또한 존재한다.\n\n그러면, 이 함수는 누가봐도 `side-effect` 가 많지않은, 함수로 볼 수 있다.\n\n---\n\n## 결론\n\n#### 임시변수는 좋지 않다.\n\n임시변수를 제거해야 하는 이유는\n\n명령형으로 가득한 조직이기 때문에, 어디서 어떻게 잘못되었는지 디버깅이 어려워진다.\n\n또한, 타인이 추가적인 코드를 덧붙이고 싶은 유혹에 빠지기 쉽다. 결국 코드의 유지보수가 어려워진다는 것이다.\n\n이에따라 해결책은, 함수를 나누거나, 바로 반환하거나, `map` `filter` `reduce` 와 같은 고차 함수를 사용하는 것이다.\n\n또한, 선언형 코드로 바꾸는 방식을 사용해보든 것이다. \n\n\n\n"},{"excerpt":"백준 1653번 링크 풀이 처음에는 해멧지만, 이후에 \n전형적인 이분탐색 문제라고 판단이 들었다. 이분탐색이란, 탐색 범위를 두 부분으로 분할해서 찾는 방식으로,    값을 잡아서 탐색한다.","fields":{"slug":"/baekjoon-1654/"},"frontmatter":{"date":"November 22, 2021","title":"[BOJ] 1654 랜선 자르기 (Node.js)","tags":["BOJ"]},"rawMarkdownBody":"\n<a href=\"https://www.acmicpc.net/problem/1654\" target=\"_blank\">백준 1653번 링크</a>\n\n## 풀이\n\n처음에는 해멧지만, 이후에 \n전형적인 이분탐색 문제라고 판단이 들었다.\n\n이분탐색이란, 탐색 범위를 두 부분으로 분할해서 찾는 방식으로, `max` `min` `mid` 값을 잡아서 탐색한다.\n\n```javascript\n'use strict';\n\n(() => {\n\tconst fs = require('fs');\n\tconst input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');\n\n\tconst [n, k] = input\n\t\t.shift()\n\t\t.split(' ')\n\t\t.map((a) => +a);\n\tconst lines = input.map((a) => +a).sort();\n\n\tlet max = Math.max(...lines);\n\tlet min = 1;\n\n\twhile (min <= max) {\n\t\tlet mid = parseInt((max + min) / 2);\n\t\tlet howManyPieces = lines\n\t\t\t.map((line) => parseInt(line / mid))\n\t\t\t.reduce((a, b) => a + b, 0);\n\t\tif (howManyPieces >= k) {\n\t\t\tmin = mid + 1;\n\t\t} else {\n\t\t\tmax = mid - 1;\n\t\t}\n\t}\n\n\tconsole.log(max);\n})();\n\n```"},{"excerpt":"결과물 미리보기  CheckLists 메뉴에 새로운 메뉴를 확인 버튼 또는 엔터키 입력으로 추가한다. 메뉴가 추가되고 나면, input은 빈 값으로 초기화한다. 사용자 입력값이 빈 값이라면 추가되지 않는다. 메뉴의 수정 버튼을 눌러 메뉴 이름 수정할 수 있다. 메뉴 수정시 브라우저에서 제공하는  인터페이스를 활용한다. 메뉴 삭제 버튼을 이용하여 메뉴 삭제…","fields":{"slug":"/starbucks-menu-1/"},"frontmatter":{"date":"November 21, 2021","title":"스타벅스 메뉴관리 with vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## 결과물 미리보기\n\n![](123.gif)\n\n## CheckLists\n\n- [x] 메뉴에 새로운 메뉴를 확인 버튼 또는 엔터키 입력으로 추가한다.\n    - [x] 메뉴가 추가되고 나면, input은 빈 값으로 초기화한다.\n    - [x] 사용자 입력값이 빈 값이라면 추가되지 않는다.\n- [x] 메뉴의 수정 버튼을 눌러 메뉴 이름 수정할 수 있다.\n    - [x] 메뉴 수정시 브라우저에서 제공하는 `prompt` 인터페이스를 활용한다.\n- [x] 메뉴 삭제 버튼을 이용하여 메뉴 삭제할 수 있다.\n    - [x] 메뉴 삭제시 브라우저에서 제공하는 `confirm` 인터페이스를 활용한다.\n- [x] 총 메뉴 갯수를 count하여 상단에 보여준다.\n- [x] [localStorage](https://developer.mozilla.org/ko/docs/Web/API/Window/localStorage)에 데이터를 저장하여 새로고침해도 데이터가 남아있게 한다.\n- [x] 지점별로 메뉴판을 관리할 수 있게 만든다.\n- [x] 페이지에 최초로 접근할 때는 국민대 지점 메뉴가 먼저 보이게 한다.\n\n---\n\n## 왜 했는가?\n\n리액트를 공부하며 상태관리에 대해 생각하던 중, 문득 궁금함이 생겼다.\n\n동적인 `web application` 을 만들기 위해 리액트를 공부중 이지만,\n\n결국 리액트도 `javascript library` 일뿐일텐데,\n\n이를 vanilla JS 로 내가 비슷하게라도 흉내내어 리액트 없이 `동적으로 state 관리`란 불가능한것일까..?\n\n찾아보니, `localStorage` 라는 개념이 존재했고, 이를 사용하여 state 관리를 해보았다.\n\n--- \n\n## 후기\n\n결국 구현한건 기본적인 CRUD 일뿐이지만, vanillaJS 를 통해서도 최대한 리액트에서 활용하고 작동하는 방식과\n\n유사하게 만들어 보려고 노력했었다. 🔥\n\n--- \n\n## 데모링크\n\n<p align=\"middle\">\n  <a href=\"https://optimistic-blackwell-8e5882.netlify.app\" target=\"_blank\">🖥️ 데모 링크</a>\n</p>\n\n\n\n\n"},{"excerpt":"SEO 란? SEO 는  의 약자로써, 구글 등 여러 Search Engine 의 상위 노출을 위한  검색엔진 최적화이다. 과정 SEO 를 위해 위와 같이 필요한 정보들을 입력해주었고,  에서 데이터 분석 및, 동작이 제대로 되는지에 대한   정보를 위해,  또한 추가해주었다.  또한,  을 작성하고 제출하여, 정상적으로 search engine 이 나의…","fields":{"slug":"/blog-SEO/"},"frontmatter":{"date":"November 21, 2021","title":"블로그 SEO","tags":["Blog"]},"rawMarkdownBody":"\n## SEO 란? \n\nSEO 는 `Search Engine Optimization` 의 약자로써, 구글 등 여러 Search Engine 의 상위 노출을 위한 \n\n검색엔진 최적화이다.\n\n---\n## 과정\n\nSEO 를 위해\n\n```javascript\nconst SEO = ({ title, description, url }) => {\n  return (\n    <Helmet>\n      <title>{title}</title>\n      <meta property=\"og:url\" content={url} />\n      <meta property=\"og:title\" content={title} />\n      <meta property=\"og:image\" content={`${siteUrl}/og-image.png`} />\n      <meta name=\"google-site-verification\" content=\"hidden\" />\n      {description && <meta name=\"description\" content={description} />}\n      {description && <meta property=\"og:description\" content={description} />}\n    </Helmet>\n  )\n}\n```\n\n위와 같이 필요한 정보들을 입력해주었고, `Google Search Console` 에서 데이터 분석 및, 동작이 제대로 되는지에 대한 \n\n`tracking` 정보를 위해, `google-site-verification` 또한 추가해주었다.\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\" xmlns:mobile=\"http://www.google.com/schemas/sitemap-mobile/1.0\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\n<url> <loc>https://hwani.dev/about-hoodie-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/quick-start-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/writing-guide-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/other-tips-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/no-var/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/no-global/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/starbucks-menu-1/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/series/gatsby-starter-hoodie-로-블로그-시작하기</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/series/JS_CleanCode</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/search/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/series/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/tags/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n</urlset>\n```\n\n![](b478fca6.png)\n\n또한, `sitemap` 을 작성하고 제출하여, 정상적으로 search engine 이 나의 `sitemap` 을 참고하도록 설정해주었다.\n\n```txt\nUser-agent: *\nAllow: /\nSitemap: https://hwani.dev/sitemap/sitemap-index.xml\nHost: https://hwani.dev\n\n```\n\n마지막으로는 Robot.txt 파일 또한 수정하고, `Root` 디렉토리에 위치하게 하였다.\n\n---\n\n## 결과\n\n![](ef3b1b5e.png)\n\n네이버를 통한 SEO 간단 체크 결과 모든 항목이 정상적으로 체크되어있었다.\n\n하지만 SEO 부분에서는 아직 모르는 것 투성이고 아직 improved 시킬 수 있다는 판단이 섰다.\n\n추가 사항이 있다면, 추가적으로 연재할 계획이다! \n\n---\n\n## Reference\n\n<a href=\"https://neilpatel.com/what-is-seo/\" target=\"_blank\">What Is SEO? (Learn How to Do It in 5 Minutes)</a>\n\n"},{"excerpt":"전역공간을 왜 사용하면 안되는지, 혹은 왜 사용을 최소화 해야하는지 알아보자. 전역공간 사용을 최소화해라 라는 말 또한 JS 공부를 하며 많이 들었던 내용이고,\n해당 이유에 대해서는 주로 경험에 의하여 누군가 또는 자바스크립트 생태계때문에 강의 혹은 책 에 의하여 회사 또는 멘토에 의하여 Lint 때문에 알 수도 있지만, 경험과 누군가, 책, Lint 때…","fields":{"slug":"/no-global/"},"frontmatter":{"date":"November 20, 2021","title":"JS - 전역 공간 사용 최소화","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n### 전역공간을 왜 사용하면 안되는지, 혹은 왜 사용을 최소화 해야하는지 알아보자.\n\n> 전역공간 사용을 최소화해라\n\n라는 말 또한 JS 공부를 하며 많이 들었던 내용이고,\n해당 이유에 대해서는 주로\n\n- 경험에 의하여\n- 누군가 또는 자바스크립트 생태계때문에\n- 강의 혹은 책 에 의하여\n- 회사 또는 멘토에 의하여\n- Lint 때문에\n\n알 수도 있지만, 경험과 누군가, 책, Lint 때문에 최소화했지만, 해당 이유에 대하여 정확히는 생각해보지 않았었다.\n\n---\n\n### 전역공간이란?\n\n전역공간은 말그대로 전역, 최상위 이고,\n대체로 `window` 와 `global`로 나뉜다.\n이유는, 브라우저 환경에서는 window 가 최상위이고,\nnode 환경에서는 global 이 최상위이다.\n\n### 이유에 대한 코드예시\n\n![](https://images.velog.io/images/sh981013s/post/da7e0621-40b3-4303-883d-32b1e17a1b67/image.png)\n\n우선 하나의 html 파일에서는 less_global1.js 와 less_global2.js 를 가져오고 있다.\n\n![](https://images.velog.io/images/sh981013s/post/8652c1a9-3a85-496b-9f64-3eb35039dc29/image.png)\n\nglobal 변수를 선언 및 할당하여 콘솔을 찍어보니 출력이 된다.\n\n![](https://images.velog.io/images/sh981013s/post/f02ed25c-8b9d-4343-9acb-ca7eebf5e71c/image.png)\n\n여기서 문제가 첫번째 js file 에서 선언한 변수가 다른 file 에서도 접근이 가능하고, 또한 몽키패치로 인하여 window.~ 로도 접근이 가능해진다는 것이다. 핵심은 파일을 나눈다고 해도, scope 자체가 나누어지지 않는다는것이다.\n\n---\n\n### 결론\n\n전역공간 사용을 최소화하여 전역공간을 더럽히지 않아야한다.\n이유는, 어디서나 접근이 가능하고 스코프 분리시에 위험이 따른다.\n\n이를 방지하기 위해,\n전역변수를 사용하지 않고 지역변수를 사용하거나,\nwindow.global 을 조작하지 않을 수 있고.\nconst/let 을 사용하는 것만으로도 많은 문제가 해결된다.\n\n"},{"excerpt":"자바스크립트를 공부하면서 var 을 지양하고 const/let 을 지향하세요. 라는 말을 수도없이 들었다. 하지만 왜...? const/let 은 ES2015 에 나왔고, 이전에는 어쩔 수 없이 var를 사용해야만 했다. 그렇다면 현시점에서 왜  을 사용해야하나의 핵심은 var 는 함수 스코프, const/let 은 블록 단위 스코프를 가지기 때문. 이라…","fields":{"slug":"/no-var/"},"frontmatter":{"date":"November 19, 2021","title":"JS - var 를 지양하자","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n\n\n자바스크립트를 공부하면서\n> var 을 지양하고 const/let 을 지향하세요.\n\n라는 말을 수도없이 들었다. 하지만 왜...?\n\n<br/>\n\nconst/let 은 ES2015 에 나왔고, 이전에는 어쩔 수 없이 var를 사용해야만 했다.\n\n그렇다면 현시점에서 왜 ```const/let``` 을 사용해야하나의 핵심은\n\n#### var 는 함수 스코프,<br/> const/let 은 블록 단위 스코프를 가지기 때문.\n\n이라고 생각한다.\n\n---\n\n- ### var 사용 테스트\n\n![](https://images.velog.io/images/sh981013s/post/f55540d2-8b6a-41ba-9ada-e42231a12716/image.png)\n\n같은 이름으로 선언 및 재할당까지 하고있음에도 에러가 나지 않고 가장 마지막에 할당한 value 가 나왔다.\n\n![](https://images.velog.io/images/sh981013s/post/e86ea9ea-41a2-4cb5-b1d6-16d27c31215f/image.png)\n\n이런식으로 순서를 바꾼다면? <br/> null 이 아닌 undefined 가 나오며 편하게 재할당까지 할 수 있고, 재할당을 넘어서 재선언(중복선언) 까지 계속할 수 있다.\n<br/> 이는 매우 편하다고 생각할 수 있는데, 지금의 코드는 겨우 9줄이지만, 코드가 많아진다면? 에 대해 고민해봐야 한다.\n\n![](https://images.velog.io/images/sh981013s/post/77693bf7-86d2-4c47-90b9-7bd66711a480/image.png)\n\n위와 같은 코드를 let 으로 바꾼다면 바로 에러가 난다.\n에러 내용을 해석해보면 '이미 선언(Declared)이 되었다고 나온다.'\n\n- ### 스코프 차이에 따른 예시\n\n![](https://images.velog.io/images/sh981013s/post/2f13d7a1-5e75-4375-a272-0a34f869ef08/image.png)\n\n위 코드에서 기대효과는 지역만 바뀌기를 바랬는데,\n전역 공간까지 영향을 주었다. 이는 var 는 함수 단위 스코프인데 이건 함수가 아니기 때문이다. 그러므로, 이를 블럭 단위 스코프로 바꾸지 않는 이상 이러한 위험요소를 항상 가지고 있다는 뜻이다.\n\n![](https://images.velog.io/images/sh981013s/post/9458cfb4-ccba-4bb4-acb6-4823d5afe82c/image.png)\n\n이를 let 으로 바꾸어보았는데, 굉장히 안전하다.\n블럭 안에서 지역변수의 역활을 굉장히 잘 수행하였다. 그리고 전역공간에서는 합당한 값을 보여주었다.\n위처럼 사람이 생각할 만한 결과를 안전하게 생각하기위해 const/let 을 사용한다.\n\n\n\n\n"}]}},"pageContext":{}},"staticQueryHashes":[]}