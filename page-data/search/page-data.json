{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"서론 이전의 포스트에서 타입검사를 왜 조심해야 하는지에 대해 말해보았다. 가장 주요한 이유로는 자바스크립트가 부족한 언어이다. 자바스크립트가 너무 느슨하다. 자바스크립트가 너무 유연하다. 자바스크립트가 동적이다. 라고 생각을 할 수 있을지도 모른다. 본론  하지만 javascript equality table 이라고 검색해보면, 이러한 테이블인 나온다. …","fields":{"slug":"/careful-typecast/"},"frontmatter":{"date":"December 02, 2021","title":"JS - 형변환 주의하기","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 서론\n\n이전의 포스트에서 타입검사를 왜 조심해야 하는지에 대해 말해보았다.\n\n\n가장 주요한 이유로는\n- 자바스크립트가 부족한 언어이다.\n- 자바스크립트가 너무 느슨하다.\n- 자바스크립트가 너무 유연하다.\n- 자바스크립트가 동적이다.\n\n라고 생각을 할 수 있을지도 모른다.\n\n---\n\n## 본론\n![](.index_images/f4615b5d.png)\n\n하지만 javascript equality table 이라고 검색해보면, 이러한 테이블인 나온다. 이처럼 기본적인 == equality operator 를 사용하면 많은 모순점이 생기기 마련이지만,\n\n![](.index_images/b13259cc.png)\n\n위처럼 === strict equality operator 를 사용한다면 벌써 많은 오류를 피할 수 있다.\n\n하지만, 여기에서 끝나지 않고 `JS의 형변환` 그 자체에 주목할 필요는 있다.\n\n```javascript\n'1' == 1 // true\n1 == true // true\n0 == false // ture\n```\n\n위의 코드는 사람이 보면 '느슨한 검사를 하고 있구나.'\n\n라고 생각을 할 수 있지만, 결국에는 `형번환` 이 일어난 케이스이다. 이는 JS 의 `암묵적인 형변환` 이라고도 부른다.\n\n```javascript\n11 + '문자와 결합' // '11 문자와 결합`\n\n!!'일반 문자열' // true\n!!'' // false (빈 문자열)\n\nparseInt('9.999', 10);\n```\n\n위는 일전에 언급한 JS 의 암묵적인 형번환의 예시들이다.\n\n잠시 다른 얘기를 하자면 마지막줄의 `parseInt` 에서 두번째 인자로 몇진수로 변환할 것인지에 따른 값을 정할 수 있지만, 많은분들이 default 값으로 10진수가 들어가겠지.. 하고 생략을 하는 경우를 종종 보았다.\n\n하지만 내장된 `parseInt` 메서드의 기본 진수값은 꼭 10진수가 아니기 때문에 오류를 피하기위해서는 꼭 두번째 인자를 넣는것을 추천한다.\n\n굳이 따지자면, 위의 세줄은 압묵적인 형변환이 일어나지만, 마지막 `parseInt`는 누가봐도 형변환을 명시적으로 표현하였기 때문에 압묵적이지만은 않다고 말할수 있다.\n\n결론은 압묵적인 형변환은 본인도 헷갈릴 수 있고, 팀원들에게도 혼란을 초래할 수 있기 때문에, 명시적인 형변환을 지향해야 한단는 점이다.\n\n```javascript\nString(11 + '문자와 결합') // '11 문자와 결합`\n\nBoolean('일반 문자열') // true\nBoolean('') // false (빈  문자열)\n\nparseInt('9.999', 10);\n```\n\n\n이런식으로 명시적인 형변환을 사용 할 수 있다.\n\n---\n\n## 결론\n\n자바스크립트에서 사용자가 형변환을 하였을때는 `명시적인 형변환` 이라고 할 수 있다.\n\n하지만 사용자가 아닌, JS 엔진이 형변환을 자동적으로 하였을때는 `암시적인 형변환` 이라고 할 수 있다.\n\n우리는 사람이 코드를 작성하는 것이기 때문에, 예측가능한 `명시적인 형변환` 을 지향해야한다.\n\n\n\n\n"},{"excerpt":"서론  란 JS의 를 뜻한다. mdn 문서에 따르면  두개의 equal signs 은 그냥  라고 부르고,  , 즉 세개의 equal sign 은  라고 부른다.  이 둘은 무시 할 수 없는 크나큰 차이를 불러 일으킨다. 본론 자바스크립트를 보통 '미개한 언어이다.' 혹은 '헷갈리는 언어이다' 라고 생각하시는 분들은 아마 이러한 상황을 겪어본 분들일지도 …","fields":{"slug":"/no-eqeq/"},"frontmatter":{"date":"December 01, 2021","title":"JS - eqeq 줄이기","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 서론\n\n`eqeq` 란 JS의 `동등 연산자`를 뜻한다.\n\nmdn 문서에 따르면 `==` 두개의 equal signs 은 그냥 `equality operator` 라고 부르고, \n\n`===`, 즉 세개의 equal sign 은 `strict equality opeartor` 라고 부른다. \n\n이 둘은 무시 할 수 없는 크나큰 차이를 불러 일으킨다.\n\n\n\n\n\n---\n\n## 본론\n\n```javascript\n'1' == 1 // true\n1 == true // true\n```\n\n자바스크립트를 보통 '미개한 언어이다.' 혹은 '헷갈리는 언어이다' 라고 생각하시는 분들은 아마 이러한 상황을 겪어본 분들일지도 모른다.\n\n동등 연산자는 형변환, 즉 `type casting`을 불러 일으킨다.\n\n위의 예시처럼 동등연산자를 `strict equlaity operator` 가 아닌, 일반 `equality operator` 를 사용한다면, 이렇게 위험한 type casting 이 발생 할 수 있다.\n\n어떻게 string 과 number 를 비교하는데 true 가 나오고 \nnumber 와 boolean 을 비교하는데 true 가 나올 수 있단말인가!\n\n```javascript\n'1' === 1 // false\n1 === true // false\n```\n\n그러므로 위처럼 두개의 항을 비교할 때에는 `strict equality operator` 를 사용하는것을 추천한다.\n\n```javascript\nconst inputNum = $('#inputNum');\n\nconsole.log(inputNum.value) // '0' (string)\nif (inputNum.value === 0) {\n  console.log('the Number is Zero') \n  // passed\n}\n```\n위처 input 값 자체가 string format 을 뱉어내기 때문에\nstrict equality operator 로 if 연산을 하면 무시해버리게 된다.\n\n```javascript\nconst inputNum = $('#inputNum');\n\nconsole.log(inputNum.value) // '0' (string)\nif (inputNum.value == 0) {\n  console.log('the Number is Zero') \n  // the Number is Zero\n}\n```\n\n하지만, 이미 JS의 이런 특성을 파악한 개발자들은 이를 역이용 하여 일반 equality opearator 로 비교하는 방법 또한 생각해낼 수 있지만, 이는 팀원들의 입장에서는 오류를 초래할 수 있기때문에 좋은 방법이라고만은 생각이 들지 않는다.\n\n```javascript\nconst inputNum = $('#inputNum');\n\nconsole.log(inputNum.value) // '0' (string)\nif (Number(inputNum.value) === 0) {\n  console.log('the Number is Zero') \n  // the Number is Zero\n}\n```\n\n그러므로 어떻게든 수동으로라도 형변환을 해서 위와같이 안전하게 strict equality operator 를 사용하는것을 추천한다.\n\n\n\n---\n\n## 결론\n\n다른언어에서 동등연산자로 쓰이는 `==` (equality operator)  는 \n\nJS 에서는 일반, 혹은 느슨한 동등연산자로 불리우며, 이는 강제로 typecasting 을 불러 일으키기 때문에,\n\n가능하면 이를 지양하는 방식을 택하고, 수동으로 자신이 형변환을 해야하는 상황에 처하더라도 `===` (strict equality operator) 를 지향해야한다.\n\n\n\n\n\n"},{"excerpt":"서론  와 , 결국 값으로 쓰기에는 둘다 무언가 없다 라는 것을 의미한다. 인터넷만 봐도 이 둘의 차이때문에 혼란을 겪는 사람이 많고, 이에따라 이를 풍자하는 밈들 또한 많다. 언어적으로 더 엄격하다면 이러한 일도 없겠지만 JS 에서는 헷갈릴 가능성이 높다고 생각한다. 본론 을 뒤집어보면은 true 라고 표현하지만, 을 으로 바꾸면 false 라고 표현한…","fields":{"slug":"/undefined-null/"},"frontmatter":{"date":"November 30, 2021","title":"JS - undefined & null","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 서론\n\n`undefined` 와 `null`, 결국 값으로 쓰기에는 둘다 무언가 없다 라는 것을 의미한다.\n\n인터넷만 봐도 이 둘의 차이때문에 혼란을 겪는 사람이 많고, 이에따라 이를 풍자하는 밈들 또한 많다.\n\n언어적으로 더 엄격하다면 이러한 일도 없겠지만 JS 에서는 헷갈릴 가능성이 높다고 생각한다.\n\n\n---\n\n## 본론\n\n```javascript\n!null // true\n!!null // false\n\nnull === false // false\n!null === true // true\n\nnull + 123 // 123\n\n```\n\n`null`을 뒤집어보면은 true 라고 표현하지만,\n\n`null`을 `boolean`으로 바꾸면 false 라고 표현한다.\n\n그렇다면 null 은 false 인가? 그것도 아니라고 한다.\n\n그렇다면 !null 은 true 인가? 맞다고 한다.\n\n머리가 지끈지끈하다.\n\n또한, null 은 수학적으로는 `비어있다` 라는 state 를 표현하기에 0으로 간주한다.\n\n때문에 null 은 비어있다 를 명시적으로 표현한다.\n\n```javascript\nlet variable;\n\ntypeof variable // undefined\n\nundefined + 10 // NaN\n\n!undefined // true\n```\n\n그렇다면 undefined 는? \n\n`아무것도 지정하지 않았을 때에 기본값` 이라고 생각이 든다.\n\n변수를 선언하였지만 이에 값을 할당하지 않았다 이다.\n\n하지만 연산을 시도해 보았을 때 null 은 0 으로 간주되었지만, undefined 는 NaN 즉 not a number 라고 하기에 더더욱 헷갈릴 수 있다.\n\n또한 !undefined 는 또 true 라고 값이 찍힌다.\n\n```javascript\nundefined == null // true\nundefined === null // false\n!undefined === !null // true\n``` \n\n위의 예시를 보면 정말 머리가 아플정도로 헷갈리고 모순점들또한 머리에 생기기 마련이다.\n\n그러므로, undefined 와 null 을 많이 활용하는 코드를 작성하기 보다는, 하나의 팀에서 둘중에 하나만 선택하여 컨벤션 자체를 만드는 것이 좋다고 생각한다.\n\n\n\n\n---\n\n## 결론\n\nundefined 와 null 의 차이점이 많지만,\n\nundefined 와 null 은 결국 값이 없거나 정의되지 않다는 차이점이 있고,\n\nundefined 는 NaN 이지만 null 은 숫자적으로 표현하였을때 0에 가깝다.\n\nundefined 의 type 은 undefined 이지만 null 의 type 은 object 이다.\n\n그래서, 결국 이 둘의 쓰임을 조심해야만 한다.\n\n\n"},{"excerpt":"서론 간단한 앱을 개발할때도 타입검사를 흔하게 사용한다. JS 에서 타입을 검사할때 제일먼저 떠오르는 것은  연산자 이다. typeof 는 우항에 있는 피연산자를 평가한 후, 문자열로 반환해준다.\n하지만, typeof 는 치명적인 단점이 있는데, 모든것을 커버해주지 못한다는 것이다. 이뜻은, Primitive 원시값, Reference 자료형에 해당하는 …","fields":{"slug":"/types-of-javascript/"},"frontmatter":{"date":"November 29, 2021","title":"JS - 타입 검사","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 서론\n\n간단한 앱을 개발할때도 타입검사를 흔하게 사용한다. JS 에서 타입을 검사할때 제일먼저 떠오르는 것은 `typeof` 연산자 이다.\n\ntypeof 는 우항에 있는 피연산자를 평가한 후, 문자열로 반환해준다.\n하지만, typeof 는 치명적인 단점이 있는데, 모든것을 커버해주지 못한다는 것이다.\n\n이뜻은, Primitive 원시값, Reference 자료형에 해당하는 객체들이 존재하는데, 원시값은 불변하기에 타입검사를 할때, 괜찮을 수 있지만, `array`, `function`, `date` 등이 Reference type 에 해당하는 object 로 치부되기에, `typeof` 연산자로 타입검사를 할 때 모순점이 생긴다.\n\n---\n\n## 본론\n\n```javascript\nfunction myFunc() {}\nclass myClass {}\nconst str = new String('문자열')\n\ntypeof myFunc // 'function'\ntypeof myClass // 'function'\ntypeof str // 'object'\ntypeof '문자열' // 'string'\ntypeof 123 // 'number'\n```\n\n위와같이 primitive type 은 typeof 연산자로 검사가 가능하지만, typeof 연산자로 reference type 을 검사 할 때는 굉장히 많은 위험을 동반한다.\n\n```javascript\ntypeof null // 'object'\n```\n\n가장 문제가 되는 녀석은 `null` 이다. null 의 type 을 object 로 찍어내는 것은 이해가 안가는 부분이 존재하고, 사실 이는 javascript 가 공식적으로 인정한 `오류` 이다. js 가 발전을 하면서 언어적으로 이는 수정을 할 수 없다고 판단을 하였다고 한다.\n\nJavascript 는 `동적` 으로 변하는 언어이지만, 위험성은 `type` 까지 동적이 된다는 점이다.\n\n`typeof` 의 단점을 커버하기위해 `instanceof` 라는 일종의 연산자의 한 종류를 사용 할 수 있는데, 이 연산자는 객체의 prototype chain 을 검사 할 수 있게 해준다.\n\n```javascript\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nconst Hwani = new Person('hwani', 24);\n\nconst Lee = {\n  name: 'hwani',\n  age: 24\n}\n\nHwani instanceof Person // true\nLee instanceof Person // false\n```\n\n여기에서 감을 잡을 수 있다. typeof 는 불변한 primitive value 들을 검사 할 수 있는데, instanceof 는 객체에 대해 확인하기에 요긴하다.\n\n하지만 여기서도 함정이 존재한다.\n\n```javascript\nconst arr = [];\nconst func = function() {};\nconst date = new Date();\n\narr instanceof Array // true\nfunc instanceof Function // true\ndate instanceof Date // true\n```\n이렇게만 보면 instaceof 라는 연산자를 사용하여 좌항과 우항을 잘 비교하고 있는것처럼 보이지만\n\n```javascript\nconst arr = [];\nconst func = function() {};\nconst date = new Date();\n\narr instanceof Object // true\nfunc instanceof Object // true\ndate instanceof Object // true\n```\n\n결국 reference type 이기 때문에 `prototype chain` 을 타보면 최상위는 `object` 라는 결론에 도달하게 된다.\n\n때문에, 더더욱 타입 검사를 하기에 어려움이 생긴다.\n\n위의 `typeof` 연산자와 `instanceof` 연산자의 단점 때문에 다른 하나의 방법이 더 존재한다.\n`object 의 prototype chain` 자체를 역이용하는 방법이다.\n\n```javascript\nconst arr = [];\nconst func = function() {};\nconst date = new Date();\n\nObject\n  .prototype\n  .toString\n  .call(new String('string')) \n// '[object String]'\n\nObject\n  .prototype\n  .toString\n  .call(arr)\n// '[object Array]'\n\nObject\n  .prototype\n  .toString\n  .call(func)\n// '[object Function]'\n\nObject\n  .prototype\n  .toString\n  .call(date)\n// '[object Date]'\n```\n\n이런식으로 reference type 까지 검사 할 수 있다.\n\n하지만 이 방식또한 무적이라고 말 할 수 없기 때문에 타입을 검사할 때 하나하나 노하우를 쌓아가는 것이 중요하다.\n\n주로 나는 `stack overflow` 를 이용하는데 이때, 검색 키워드는 \n\n- javascript is array\n- javascript is function\n- javascript is date\n\n와 같이 검색하면 주로 많은 답변이 나온다.\n\n---\n\n## 결론\n\n자바스크립트는 동적을 타입을 가진 언어이다.\n\n그렇기 때문에 타입 검사가 어렵다. \n\n많은 타입 검사가 존재하기 때문에 다 외우기 보다는 검색을 통하여 타입 검사를 체크하는 방법을 추천한다.\n\n타입 검사를 할 때에는 항상 `primitive type` 과 `reference type` 을 잘 생각하며 유의해야하며 \n\n`typeof` 연산자는 무적이 아니다. \n\n"},{"excerpt":"Intro 5번째 Mini Vanilla Js Project 이다. 이번에는  라는  를 사용하여 개인자산 체크 기능을 만들어보았다! Main 소스코드 liveDemo  Conclusion JS 에서 가장 흔하게 사용되는? 메서드인 , , , 를 주축으로 구현을 해보았다. 간편화를 위해, input 으로 user 정보를 받는것이 아닌, 외부 api 를 사…","fields":{"slug":"/personal-information-list/"},"frontmatter":{"date":"November 28, 2021","title":"개인자산 체크 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n5번째 Mini Vanilla Js Project 이다.\n\n이번에는 `Random User Generator-API` 라는 `Third-party api` 를 사용하여 개인자산 체크 기능을 만들어보았다!\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Personal-Information-List)\n- [liveDemo](https://hwani-vanillajs.netlify.app/personal-information-list/)\n\n\n![](personal.gif)\n\n---\n\n## Conclusion\n\nJS 에서 가장 흔하게 사용되는? 메서드인 `sort`, `filter`, `reduce`, 를 주축으로 구현을 해보았다.\n\n간편화를 위해, input 으로 user 정보를 받는것이 아닌, 외부 api 를 사용하여 쉽게 예시 user 를 추가 할 수 있게 했고,\n\n이를 좌축의 aside button 들에 event mapping 해놓았다.\n\n가장 고민했던 부분은, event 가 실행되어 유저가 추가되었을때, 유저의 데이터가 변할때 어떤 방식으로 DOM 자체를 refresh 없이 re-rendering 시킬것인가 였다.\n\nReact 는 Virtual DOM 을 사용하여 Diff 를 파악한 후, 변경점이 필요한 부분만 바꾸어주는 방식을 사용하지만, Vanilla JS 로 이를 직접 구현하기에는 나중에 내 기준에서는 (대형..?) 프로젝트 및 과제로 미루어두고,\n\n우선은 state 를 가지고 있는 화면단을 하나의 배열로 관리하며, 해당 state 가 변경될 때, 통째로 re-rendering 하는 방식으로 구현하였다. \n\n이번에도 느낀것이지만, vanillaJS 프로젝트를 진행할때마다, framework 이 자체적으로 가지고 있는 기능 혹은 library 가 대신 해주었던 기능들을 직접 사소하나마 찾아가며 구현하며 내 프로젝트와의 차이점을 찾고, 해당 framework 이나 library 의 기능들의 작동 방식을 차차 알아갈 수 있다는 점이 아직은 재밌게 느껴졌다!"},{"excerpt":"Intro 6번째 Mini Vanilla Js Project 이다. 이번에는 순수  와  를 사용하여 Sidebar 와 Modal 을 직접 구현해보았다. Main 소스코드 liveDemo  Conclusion 사실 내가 프로젝트를 진행할때  를 사용했던 이유는 style 적인 이유보다는 JS? 적인 이유가 더 컸다.\n이 뜻은, UI Library 를 사용…","fields":{"slug":"/menu-sidebar-modal/"},"frontmatter":{"date":"November 28, 2021","title":"사이드바, 모달 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n6번째 Mini Vanilla Js Project 이다.\n\n이번에는 순수 `css` 와 `vanilla JS` 를 사용하여 Sidebar 와 Modal 을 직접 구현해보았다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Menu-Sidebar-Modal)\n- [liveDemo](https://hwani-vanillajs.netlify.app/menu-sidebar-modal/)\n\n\n![](modal.gif)\n\n---\n\n## Conclusion\n\n사실 내가 프로젝트를 진행할때 `UI Library` 를 사용했던 이유는 style 적인 이유보다는 JS? 적인 이유가 더 컸다.\n이 뜻은, UI Library 를 사용할때도 보통 style 적인 부분은 모두 갈아엎으며 나의 입맛대로 꾸몄지만, 예를 들어,\n\n- 'x' 표시를 누르면 모달이 닫힌다.\n- 모달 바깥의 영역을 누르면 부드럽게 animation 과 함께 자연스럽게 닫힌다.\n- 사이드바 햄버거 아이콘을 누르면 자연스럽게 화면이 이동하며 sidebar 가 펼쳐진다\n\n와 같은 기능적인 부분에 대해 무지했기때문에 이런부분은 주로 library 에 의존하곤 했다.\n\n하지만, 지속적인 구글링과 공부 끝에, 이번 기회에 노력하면 해볼 수 있지 않을까? 라는 결론에 도달했고, \n나의 기대치에 맞는 화면을 직접 구성 할 수 있게 되었다. \n\n결론적으로는, 사실 JS 부분은 복잡하지 않고 간단하지만, 주로 CSS 적인 변화와 움직임을 toggle 로 컨트롤하면서 여러가지 상황에 대처할 수 있게 구현하는 방식을 택하였다."},{"excerpt":"Intro 4번째 Mini Vanilla Js Project 이다. 이번에는  라는  를 사용하여 환전 기능을 만들어보았다! Main 소스코드 liveDemo  Conclusion 처음으로 vanillaJS 를 사용하며, third-party api 를 사용해보았다. 기존에 리액트를 배우고 사용했을때는 데이터를 요청하는 방식 자체에 대해서 당연하게 고민도…","fields":{"slug":"/exchange-rate-calculator/"},"frontmatter":{"date":"November 27, 2021","title":"환전기 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n4번째 Mini Vanilla Js Project 이다.\n\n이번에는 `ExchangeRate-API` 라는 `Third-party api` 를 사용하여 환전 기능을 만들어보았다!\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Exchange-Rate-Calculator)\n- [liveDemo](https://hwani-vanillajs.netlify.app/exchange-rate-calculator/)\n\n\n![](exchange-cal.gif)\n\n---\n\n## Conclusion\n\n처음으로 vanillaJS 를 사용하며, third-party api 를 사용해보았다.\n\n기존에 리액트를 배우고 사용했을때는 데이터를 요청하는 방식 자체에 대해서 당연하게 고민도 하지 않은채 마구잡이로 남들이 사용하는 방식대로 `request` 나 `axios` 를 썼었는데,\n\n이번 프로젝트를 진행하며, 브라우저가 자체적으로 `fetch()` 함수를 지원한다는 것을 배웠고, 이를 사용해보았다. 결과는 내 기준에서는 성공적이였고, 고민을 해보았던 점은, 결국 `request`, `axios` 도 같은 `Http 비동기 통신 library` 일텐데\n\n이들을 대체할 수 있는 내장 함수인 `fetch()` 를 main 으로 사용한다면 `js bundling size` 면에서 유리하지 않을까 였다.\n\n이 문제에 대해 찾아본 결과, 내 생각대로라면 `fetch()` 를 main 으로 쓰는것이 바람직 할 수 있겠지만, \n\n- 지원하지 않는 브라우저가 있다  (...IE11)\n- 네트워크 에러 발생 시 response timeout 없이 기다려야한다.\n- JSON 으로 변환해주는 과정이 필요하다.\n\n위 세가지의 단점때문에 아직 외부 라이브러리들을 사용을 한다는 의견이 많고,  나의 실력으로써는 더 많이 경험하고 써보면서 각자의 장단점을 몸소 직접 체험하는 수밖에 없을 것 같다."},{"excerpt":"Intro 새번째 Mini Vanilla Js Project 이다. video api 를 사용하여 비디오 플레이어를 만들어 보았다. Main 소스코드 liveDemo  Conclusion 각 버튼들과 상황에 따른 전반적인 동작 원리와 기능들을 직접 공부하고 구현하려다 보니, 간단할지라도 배우는점이 많았다.  이제 앞으로 프로젝트를 진행하며  태그를 사용해…","fields":{"slug":"/custom-video-player/"},"frontmatter":{"date":"November 27, 2021","title":"비디오 플레이어 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n새번째 Mini Vanilla Js Project 이다.\n\nvideo api 를 사용하여 비디오 플레이어를 만들어 보았다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Custom-Video-Player)\n- [liveDemo](https://hwani-vanillajs.netlify.app/custom-video-player/)\n\n\n![](vid-player.gif)\n\n---\n\n## Conclusion\n\n각 버튼들과 상황에 따른 전반적인 동작 원리와 기능들을 직접 공부하고 구현하려다 보니, 간단할지라도 배우는점이 많았다. \n\n이제 앞으로 프로젝트를 진행하며 `video` 태그를 사용해야 할때 겁먹지 않기를 바라며 ㅎㅎ"},{"excerpt":"Intro 두번째 Mini Vanilla Js Project 이다. 이번에는 간단하게 영화 좌석 선택을 만들어보았고, 전과 다른점이 있다면, 이번에는  를 사용하여,  된 후에도 데이터가 남아있게 하였다. Main 소스코드 liveDemo  Conclusion Vanilla JS 프로젝트를 진행하면서,  를 사용할때도,  속성을 사용할 수 있다는 것을 배…","fields":{"slug":"/movie-seat-booking/"},"frontmatter":{"date":"November 26, 2021","title":"영화 좌석 선택 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n두번째 Mini Vanilla Js Project 이다.\n\n이번에는 간단하게 영화 좌석 선택을 만들어보았고, 전과 다른점이 있다면,\n\n이번에는 `localStorage` 를 사용하여, `refresh` 된 후에도 데이터가 남아있게 하였다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Movie-Seat-Booking)\n- [liveDemo](https://hwani-vanillajs.netlify.app/form-validator/)\n\n\n![](movie-seat.gif)\n\n---\n\n## Conclusion\n\nVanilla JS 프로젝트를 진행하면서, `document.querySelector` 를 사용할때도, `not()` 속성을 사용할 수 있다는 것을 배웠고, \n\nlocalStorage 에서 데이터가 어떤식으로 들어가고 나오는지에 대해 깨달은 점도 존재하다. 더불어 CSS 공부도 나름 열심히 하게 되는 것 같다!\n\nUI Library 가 필요없을 경지에 도달하는 그날을 기다리며.. ㅎㅎ"},{"excerpt":"Intro 리액트를 공부하거나, 프로젝트를 했으로때 주로 간단한 ui 적인 부분은 라이브러리를 사용하여 해결 했었지만, vanilla JS 를 사용하여 내가 직접 가능한 부분은 공부하여 만들어 보려고 하였다. Main 소스코드 liveDemo  HTML JS","fields":{"slug":"/vainllajs-registration-form/"},"frontmatter":{"date":"November 24, 2021","title":"회원가입 폼 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n리액트를 공부하거나, 프로젝트를 했으로때 주로 간단한 ui 적인 부분은 라이브러리를 사용하여 해결 했었지만, vanilla JS 를 사용하여 내가 직접 가능한 부분은 공부하여 만들어 보려고 하였다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Form-Validator)\n- [liveDemo](https://hwani-vanillajs.netlify.app/form-validator/)\n\n\n![](form_val.gif)\n\n---\n\n## HTML\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\"\n        content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <link rel=\"stylesheet\" href=\"./styles.css\">\n  <title>Form Validator</title>\n</head>\n<body>\n<div class=\"container\">\n  <form action=\"\" id=\"form\" class=\"form\">\n    <h2>Register With Us</h2>\n    <div class=\"form-control\">\n      <label for=\"username\">Username</label>\n      <input type=\"text\" id=\"username\" placeholder=\"Enter username\">\n      <small>Error message</small>\n    </div>\n    <div class=\"form-control\">\n      <label for=\"email\">Email</label>\n      <input type=\"text\" id=\"email\" placeholder=\"Enter email\">\n      <small>Error message</small>\n    </div>\n    <div class=\"form-control\">\n      <label for=\"password\">Password</label>\n      <input type=\"password\" id=\"password\" placeholder=\"Enter password\">\n      <small>Error message</small>\n    </div>\n    <div class=\"form-control\">\n      <label for=\"password\">Confirm Password</label>\n      <input type=\"password\" id=\"password2\" placeholder=\"Enter password again\">\n      <small>Error message</small>\n    </div>\n    <button>Submit</button>\n  </form>\n</div>\n<script src=\"script.js\"></script>\n</body>\n</html>\n```\n\n## JS\n\n```javascript\nconst form = document.getElementById('form');\nconst username = document.getElementById('username');\nconst email = document.getElementById('email');\nconst password = document.getElementById('password');\nconst password2 = document.getElementById('password2');\n\n// Show input error message\nconst showError = (input, message) => {\n  const formControl = input.parentElement;\n  formControl.className = 'form-control error';\n  const small = formControl.querySelector('small');\n  small.innerText = message;\n}\n\n// Show success outline\nconst showSuccess = (input) => {\n  const formControl = input.parentElement;\n  formControl.className = 'form-control success';\n}\n\n// Check email is valid\nconst isValidEmail = (email) => {\n  const re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  if (re.test(email.value)) {\n    showSuccess(email)\n  } else {\n    showError(email, 'Email is not valid');\n  }\n}\n\n// Get field name\nconst getFieldName = (input) => {\n  return input.id.charAt(0).toUpperCase() + input.id.slice(1);\n}\n\n// Check required fields\nconst checkRequired = (inputArr) => {\n  inputArr.forEach(input => {\n    if (input.value.trim() === '') {\n      showError(input, `${getFieldName(input)} is required`);\n    } else {\n      showSuccess(input);\n    }\n  })\n}\n\n// Check input length\nconst checkLength = (input, min, max) => {\n  if (input.value.length < min) {\n    showError(input, `${getFieldName(input)} must be at least ${min} characters`)\n  } else if (input.value.length > max) {\n    showError(input, `${getFieldName(input)} must be at less than ${max} characters`)\n  }\n}\n\n// Check passwords match\nconst checkPasswordsMatch = (input1, input2) => {\n  if(input1.value !== input2.value) {\n    showError(input2, 'Password do not match');\n  }\n}\n\n// Event listeners\nform.addEventListener('submit', e => {\n  e.preventDefault();\n\n  checkRequired([username, email, password, password2]);\n  checkLength(username, 8, 15);\n  checkLength(password, 6, 25);\n  isValidEmail(email);\n  checkPasswordsMatch(password, password2);\n});\n```"},{"excerpt":"호이스팅이란? 호이스팅을 간단하게 말하자면 런타임시에 과 이 분리된 것을 뜻한다. 런타임시기는 프로그램이 동작 할 때를 의미한다. 코드를 잘성할 때는 이 스코프는 이렇게 동작할 것이다. 라고 예상을 하는데,\n실상 런타임시에는 그렇게 동작하지 않을 때가 있다. 해당 현상중의 하나가  인데, 호이스팅은 로 선언한 변수 초기화가 제대로 되어있지 않았을때,  상…","fields":{"slug":"/no-hoisting/"},"frontmatter":{"date":"November 23, 2021","title":"JS - 호이스팅 주의하기","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 호이스팅이란?\n\n호이스팅을 간단하게 말하자면 런타임시에 `선언`과 `할당`이 분리된 것을 뜻한다.\n\n런타임시기는 프로그램이 동작 할 때를 의미한다.\n\n코드를 잘성할 때는 이 스코프는 이렇게 동작할 것이다. 라고 예상을 하는데,\n실상 런타임시에는 그렇게 동작하지 않을 때가 있다.\n\n해당 현상중의 하나가 `호이스팅` 인데, 호이스팅은 `var`로 선언한 변수 초기화가 제대로 되어있지 않았을때, `undefined` 상태로 코드의 상단으로 끌어올려지는 것을 뜻한다.\n\n물론 `let & const` 를 사용한다면 이러한 현상을 잘 겪지 않겠지만 (TDZ)\n`var`에서는 종종 일어난다.\n\n--- \n\n## 예시\n\n```javascript\nvar global = 0;\n\nfunction outer () {\n  console.log(global); // undefined\n  var global = 5;\n  \n  function inner () {\n    var global = 10;\n    console.log(global); // 10\n  }\n  \n  inner();\n  \n  global = 1;\n  console.log(global) // 1\n}\n\nouter();\n```\n\n위의 코드가 호이스팅이 동작한 사례라고 생각한다.\n\n선언과 할당 부분이 메모리 공간을 선언하기전에, 미리 할당을 하기때문에 이러한 일이 발생한다.\n\n## 쉬운예시\n\n```javascript\nfunction duplicatedVar() {\n  var a;\n  \n  console.log(a); // undefined\n  \n  var a = 100;\n  \n  console.log(a); // 100\n}\n\nconsole.log(duplicatedVar());\n```\n\nvar 는 중복 선언이 가능하고, 중복 선언해도 오류 없이 undefined 를 반환한다.\n원래 다른 언어였다면, 이 코드는 에러를 반환한다는 예측을 할텐데, 예측과 다르게 런타임 시에 undefined 를 리턴하기에\n위험할 수 있다.\n\n## 골때리는 예시\n\n```javascript\nvar sum;\n\nconsole.log(typeof sum); // function\n\nfunction sum() {\n  return 1 + 2;\n};\n```\n\n콘솔로 찍어보니, 변수가 아닌 함수라고 말한다. 결국 아래에 위치한 함수조차도 hoisting 이 되었다는 뜻이다.\n함수 선언문이 변수를 뒤집어 엎어버린다.\n\n---\n\n## 결론 \n\n호이스팅은 런타임시에 바로 선언을 최상단으로 끌어올려 줌으로써, 문제는 코드를 작성할 때 예측하지 못한 실행결과를 노출하게 된다. 이러한 예측하지 못하는 상황들을 탈피하기 위해 var 를 지양한다.\n\n또한 함수또한 호이스팅이 되고, 이를 탈피하기 위해서는 함수 표현식을 사용하는 방법이 있다.\n\nlet 과 const 를 지향하자!\n\n"},{"excerpt":"임시변수란? 자바스크립트를 다룰때, 기존의 Scope 를 다룰때,   을 사용하지 말고,   또한 피해야 한다고 들었다. 임시변수란, Scope 안에서 전역변수처럼 활용되는 친구를 생각한다. 위의 코드의  도 마찬가지이다.\n어떻게 보면 이것도 const 니까 문제 없을까? 라고 생각 할 수 있지만, 이 임시 객체도 함수가 커지  이나 다름없는 상황이 발생…","fields":{"slug":"/no-temporary-variable/"},"frontmatter":{"date":"November 22, 2021","title":"JS - 임시변수 제거하기","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n## 임시변수란?\n\n자바스크립트를 다룰때, 기존의 Scope 를 다룰때, \n\n`전역공간` 을 사용하지 말고,  `var` 또한 피해야 한다고 들었다.\n\n#### 임시변수란, Scope 안에서 전역변수처럼 활용되는 친구를 생각한다.\n\n```javascript\nconst getObj = () => {\n    const result = {};\n    \n    result.title = 'tmp_variable'\n    result.text = 'wow'\n    \n    return result;\n}\n```\n\n위의 코드의 `const result = {}` 도 마찬가지이다.\n어떻게 보면 이것도 const 니까 문제 없을까? 라고 생각 할 수 있지만, 이 임시 객체도 함수가 커지 `전역공간` 이나 다름없는 상황이 발생할 수 있다.\n\n그렇게 되면 위험한 상황이 나올 수 있다. 임시변수를 만들었을때, 누군가가 같이 일하는 팀원이 미래의 내가 유혹을 받을 수 있다는 말이다.\n\n그러면 이 임시 변수를 어떻게 접근 할까에 대해서는, 함수를 작게 쪼개는 방법도 있지만, \n\n```javascript\nconst getObj = () => {\n    const result = {\n      title: 'tmp_variable',\n      text: 'wow',\n    };\n    return result;\n}\n```\n\n이런식으로 간소화 할 수도 있다. 일단은 코드가 명확해지고,\n아까는 굳이 선언 후 접근하는 과정으로 나뉘어있었기 때문에,\n누구나 고칠 수 있는 느낌이 들었다.\n\n하지만, 더 명확하게 바꿀 수 있는 방법이 뭐가 있을까?\n\n```javascript\nconst getObj = () => {\n    return {\n      title: 'tmp_variable',\n      text: 'wow',\n    };\n}\n```\n\n이런식으로 바로 반환하는는 방법또한 존재한다.\n\n그러면, 이 함수는 누가봐도 `side-effect` 가 많지않은, 함수로 볼 수 있다.\n\n---\n\n## 결론\n\n#### 임시변수는 좋지 않다.\n\n임시변수를 제거해야 하는 이유는\n\n명령형으로 가득한 조직이기 때문에, 어디서 어떻게 잘못되었는지 디버깅이 어려워진다.\n\n또한, 타인이 추가적인 코드를 덧붙이고 싶은 유혹에 빠지기 쉽다. 결국 코드의 유지보수가 어려워진다는 것이다.\n\n이에따라 해결책은, 함수를 나누거나, 바로 반환하거나, `map` `filter` `reduce` 와 같은 고차 함수를 사용하는 것이다.\n\n또한, 선언형 코드로 바꾸는 방식을 사용해보든 것이다. \n\n\n\n"},{"excerpt":"백준 1653번 링크 풀이 처음에는 해멧지만, 이후에 \n전형적인 이분탐색 문제라고 판단이 들었다. 이분탐색이란, 탐색 범위를 두 부분으로 분할해서 찾는 방식으로,    값을 잡아서 탐색한다.","fields":{"slug":"/baekjoon-1654/"},"frontmatter":{"date":"November 22, 2021","title":"[BOJ] 1654 랜선 자르기 (Node.js)","tags":["BOJ"]},"rawMarkdownBody":"\n<a href=\"https://www.acmicpc.net/problem/1654\" target=\"_blank\">백준 1653번 링크</a>\n\n## 풀이\n\n처음에는 해멧지만, 이후에 \n전형적인 이분탐색 문제라고 판단이 들었다.\n\n이분탐색이란, 탐색 범위를 두 부분으로 분할해서 찾는 방식으로, `max` `min` `mid` 값을 잡아서 탐색한다.\n\n```javascript\n'use strict';\n\n(() => {\n\tconst fs = require('fs');\n\tconst input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');\n\n\tconst [n, k] = input\n\t\t.shift()\n\t\t.split(' ')\n\t\t.map((a) => +a);\n\tconst lines = input.map((a) => +a).sort();\n\n\tlet max = Math.max(...lines);\n\tlet min = 1;\n\n\twhile (min <= max) {\n\t\tlet mid = parseInt((max + min) / 2);\n\t\tlet howManyPieces = lines\n\t\t\t.map((line) => parseInt(line / mid))\n\t\t\t.reduce((a, b) => a + b, 0);\n\t\tif (howManyPieces >= k) {\n\t\t\tmin = mid + 1;\n\t\t} else {\n\t\t\tmax = mid - 1;\n\t\t}\n\t}\n\n\tconsole.log(max);\n})();\n\n```"},{"excerpt":"결과물 미리보기  CheckLists 메뉴에 새로운 메뉴를 확인 버튼 또는 엔터키 입력으로 추가한다. 메뉴가 추가되고 나면, input은 빈 값으로 초기화한다. 사용자 입력값이 빈 값이라면 추가되지 않는다. 메뉴의 수정 버튼을 눌러 메뉴 이름 수정할 수 있다. 메뉴 수정시 브라우저에서 제공하는  인터페이스를 활용한다. 메뉴 삭제 버튼을 이용하여 메뉴 삭제…","fields":{"slug":"/starbucks-menu-1/"},"frontmatter":{"date":"November 21, 2021","title":"스타벅스 메뉴관리 with vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## 결과물 미리보기\n\n![](123.gif)\n\n## CheckLists\n\n- [x] 메뉴에 새로운 메뉴를 확인 버튼 또는 엔터키 입력으로 추가한다.\n    - [x] 메뉴가 추가되고 나면, input은 빈 값으로 초기화한다.\n    - [x] 사용자 입력값이 빈 값이라면 추가되지 않는다.\n- [x] 메뉴의 수정 버튼을 눌러 메뉴 이름 수정할 수 있다.\n    - [x] 메뉴 수정시 브라우저에서 제공하는 `prompt` 인터페이스를 활용한다.\n- [x] 메뉴 삭제 버튼을 이용하여 메뉴 삭제할 수 있다.\n    - [x] 메뉴 삭제시 브라우저에서 제공하는 `confirm` 인터페이스를 활용한다.\n- [x] 총 메뉴 갯수를 count하여 상단에 보여준다.\n- [x] [localStorage](https://developer.mozilla.org/ko/docs/Web/API/Window/localStorage)에 데이터를 저장하여 새로고침해도 데이터가 남아있게 한다.\n- [x] 지점별로 메뉴판을 관리할 수 있게 만든다.\n- [x] 페이지에 최초로 접근할 때는 국민대 지점 메뉴가 먼저 보이게 한다.\n\n---\n\n## 왜 했는가?\n\n리액트를 공부하며 상태관리에 대해 생각하던 중, 문득 궁금함이 생겼다.\n\n동적인 `web application` 을 만들기 위해 리액트를 공부중 이지만,\n\n결국 리액트도 `javascript library` 일뿐일텐데,\n\n이를 vanilla JS 로 내가 비슷하게라도 흉내내어 리액트 없이 `동적으로 state 관리`란 불가능한것일까..?\n\n찾아보니, `localStorage` 라는 개념이 존재했고, 이를 사용하여 state 관리를 해보았다.\n\n--- \n\n## 후기\n\n결국 구현한건 기본적인 CRUD 일뿐이지만, vanillaJS 를 통해서도 최대한 리액트에서 활용하고 작동하는 방식과\n\n유사하게 만들어 보려고 노력했었다. 🔥\n\n--- \n\n## 데모링크\n\n<p align=\"middle\">\n  <a href=\"https://optimistic-blackwell-8e5882.netlify.app\" target=\"_blank\">🖥️ 데모 링크</a>\n</p>\n\n\n\n\n"},{"excerpt":"SEO 란? SEO 는  의 약자로써, 구글 등 여러 Search Engine 의 상위 노출을 위한  검색엔진 최적화이다. 과정 SEO 를 위해 위와 같이 필요한 정보들을 입력해주었고,  에서 데이터 분석 및, 동작이 제대로 되는지에 대한   정보를 위해,  또한 추가해주었다.  또한,  을 작성하고 제출하여, 정상적으로 search engine 이 나의…","fields":{"slug":"/blog-SEO/"},"frontmatter":{"date":"November 21, 2021","title":"블로그 SEO","tags":["Blog"]},"rawMarkdownBody":"\n## SEO 란? \n\nSEO 는 `Search Engine Optimization` 의 약자로써, 구글 등 여러 Search Engine 의 상위 노출을 위한 \n\n검색엔진 최적화이다.\n\n---\n## 과정\n\nSEO 를 위해\n\n```javascript\nconst SEO = ({ title, description, url }) => {\n  return (\n    <Helmet>\n      <title>{title}</title>\n      <meta property=\"og:url\" content={url} />\n      <meta property=\"og:title\" content={title} />\n      <meta property=\"og:image\" content={`${siteUrl}/og-image.png`} />\n      <meta name=\"google-site-verification\" content=\"hidden\" />\n      {description && <meta name=\"description\" content={description} />}\n      {description && <meta property=\"og:description\" content={description} />}\n    </Helmet>\n  )\n}\n```\n\n위와 같이 필요한 정보들을 입력해주었고, `Google Search Console` 에서 데이터 분석 및, 동작이 제대로 되는지에 대한 \n\n`tracking` 정보를 위해, `google-site-verification` 또한 추가해주었다.\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\" xmlns:mobile=\"http://www.google.com/schemas/sitemap-mobile/1.0\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\n<url> <loc>https://hwani.dev/about-hoodie-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/quick-start-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/writing-guide-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/other-tips-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/no-var/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/no-global/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/starbucks-menu-1/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/series/gatsby-starter-hoodie-로-블로그-시작하기</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/series/JS_CleanCode</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/search/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/series/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/tags/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n</urlset>\n```\n\n![](b478fca6.png)\n\n또한, `sitemap` 을 작성하고 제출하여, 정상적으로 search engine 이 나의 `sitemap` 을 참고하도록 설정해주었다.\n\n```txt\nUser-agent: *\nAllow: /\nSitemap: https://hwani.dev/sitemap/sitemap-index.xml\nHost: https://hwani.dev\n\n```\n\n마지막으로는 Robot.txt 파일 또한 수정하고, `Root` 디렉토리에 위치하게 하였다.\n\n---\n\n## 결과\n\n![](ef3b1b5e.png)\n\n네이버를 통한 SEO 간단 체크 결과 모든 항목이 정상적으로 체크되어있었다.\n\n하지만 SEO 부분에서는 아직 모르는 것 투성이고 아직 improved 시킬 수 있다는 판단이 섰다.\n\n추가 사항이 있다면, 추가적으로 연재할 계획이다! \n\n---\n\n## Reference\n\n<a href=\"https://neilpatel.com/what-is-seo/\" target=\"_blank\">What Is SEO? (Learn How to Do It in 5 Minutes)</a>\n\n"},{"excerpt":"전역공간을 왜 사용하면 안되는지, 혹은 왜 사용을 최소화 해야하는지 알아보자. 전역공간 사용을 최소화해라 라는 말 또한 JS 공부를 하며 많이 들었던 내용이고,\n해당 이유에 대해서는 주로 경험에 의하여 누군가 또는 자바스크립트 생태계때문에 강의 혹은 책 에 의하여 회사 또는 멘토에 의하여 Lint 때문에 알 수도 있지만, 경험과 누군가, 책, Lint 때…","fields":{"slug":"/no-global/"},"frontmatter":{"date":"November 20, 2021","title":"JS - 전역 공간 사용 최소화","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n### 전역공간을 왜 사용하면 안되는지, 혹은 왜 사용을 최소화 해야하는지 알아보자.\n\n> 전역공간 사용을 최소화해라\n\n라는 말 또한 JS 공부를 하며 많이 들었던 내용이고,\n해당 이유에 대해서는 주로\n\n- 경험에 의하여\n- 누군가 또는 자바스크립트 생태계때문에\n- 강의 혹은 책 에 의하여\n- 회사 또는 멘토에 의하여\n- Lint 때문에\n\n알 수도 있지만, 경험과 누군가, 책, Lint 때문에 최소화했지만, 해당 이유에 대하여 정확히는 생각해보지 않았었다.\n\n---\n\n### 전역공간이란?\n\n전역공간은 말그대로 전역, 최상위 이고,\n대체로 `window` 와 `global`로 나뉜다.\n이유는, 브라우저 환경에서는 window 가 최상위이고,\nnode 환경에서는 global 이 최상위이다.\n\n### 이유에 대한 코드예시\n\n![](https://images.velog.io/images/sh981013s/post/da7e0621-40b3-4303-883d-32b1e17a1b67/image.png)\n\n우선 하나의 html 파일에서는 less_global1.js 와 less_global2.js 를 가져오고 있다.\n\n![](https://images.velog.io/images/sh981013s/post/8652c1a9-3a85-496b-9f64-3eb35039dc29/image.png)\n\nglobal 변수를 선언 및 할당하여 콘솔을 찍어보니 출력이 된다.\n\n![](https://images.velog.io/images/sh981013s/post/f02ed25c-8b9d-4343-9acb-ca7eebf5e71c/image.png)\n\n여기서 문제가 첫번째 js file 에서 선언한 변수가 다른 file 에서도 접근이 가능하고, 또한 몽키패치로 인하여 window.~ 로도 접근이 가능해진다는 것이다. 핵심은 파일을 나눈다고 해도, scope 자체가 나누어지지 않는다는것이다.\n\n---\n\n### 결론\n\n전역공간 사용을 최소화하여 전역공간을 더럽히지 않아야한다.\n이유는, 어디서나 접근이 가능하고 스코프 분리시에 위험이 따른다.\n\n이를 방지하기 위해,\n전역변수를 사용하지 않고 지역변수를 사용하거나,\nwindow.global 을 조작하지 않을 수 있고.\nconst/let 을 사용하는 것만으로도 많은 문제가 해결된다.\n\n"},{"excerpt":"자바스크립트를 공부하면서 var 을 지양하고 const/let 을 지향하세요. 라는 말을 수도없이 들었다. 하지만 왜...? const/let 은 ES2015 에 나왔고, 이전에는 어쩔 수 없이 var를 사용해야만 했다. 그렇다면 현시점에서 왜  을 사용해야하나의 핵심은 var 는 함수 스코프, const/let 은 블록 단위 스코프를 가지기 때문. 이라…","fields":{"slug":"/no-var/"},"frontmatter":{"date":"November 19, 2021","title":"JS - var 를 지양하자","tags":["JS_CleanCode"]},"rawMarkdownBody":"\n\n\n자바스크립트를 공부하면서\n> var 을 지양하고 const/let 을 지향하세요.\n\n라는 말을 수도없이 들었다. 하지만 왜...?\n\n<br/>\n\nconst/let 은 ES2015 에 나왔고, 이전에는 어쩔 수 없이 var를 사용해야만 했다.\n\n그렇다면 현시점에서 왜 ```const/let``` 을 사용해야하나의 핵심은\n\n#### var 는 함수 스코프,<br/> const/let 은 블록 단위 스코프를 가지기 때문.\n\n이라고 생각한다.\n\n---\n\n- ### var 사용 테스트\n\n![](https://images.velog.io/images/sh981013s/post/f55540d2-8b6a-41ba-9ada-e42231a12716/image.png)\n\n같은 이름으로 선언 및 재할당까지 하고있음에도 에러가 나지 않고 가장 마지막에 할당한 value 가 나왔다.\n\n![](https://images.velog.io/images/sh981013s/post/e86ea9ea-41a2-4cb5-b1d6-16d27c31215f/image.png)\n\n이런식으로 순서를 바꾼다면? <br/> null 이 아닌 undefined 가 나오며 편하게 재할당까지 할 수 있고, 재할당을 넘어서 재선언(중복선언) 까지 계속할 수 있다.\n<br/> 이는 매우 편하다고 생각할 수 있는데, 지금의 코드는 겨우 9줄이지만, 코드가 많아진다면? 에 대해 고민해봐야 한다.\n\n![](https://images.velog.io/images/sh981013s/post/77693bf7-86d2-4c47-90b9-7bd66711a480/image.png)\n\n위와 같은 코드를 let 으로 바꾼다면 바로 에러가 난다.\n에러 내용을 해석해보면 '이미 선언(Declared)이 되었다고 나온다.'\n\n- ### 스코프 차이에 따른 예시\n\n![](https://images.velog.io/images/sh981013s/post/2f13d7a1-5e75-4375-a272-0a34f869ef08/image.png)\n\n위 코드에서 기대효과는 지역만 바뀌기를 바랬는데,\n전역 공간까지 영향을 주었다. 이는 var 는 함수 단위 스코프인데 이건 함수가 아니기 때문이다. 그러므로, 이를 블럭 단위 스코프로 바꾸지 않는 이상 이러한 위험요소를 항상 가지고 있다는 뜻이다.\n\n![](https://images.velog.io/images/sh981013s/post/9458cfb4-ccba-4bb4-acb6-4823d5afe82c/image.png)\n\n이를 let 으로 바꾸어보았는데, 굉장히 안전하다.\n블럭 안에서 지역변수의 역활을 굉장히 잘 수행하였다. 그리고 전역공간에서는 합당한 값을 보여주었다.\n위처럼 사람이 생각할 만한 결과를 안전하게 생각하기위해 const/let 을 사용한다.\n\n\n\n\n"}]}},"pageContext":{}},"staticQueryHashes":[]}