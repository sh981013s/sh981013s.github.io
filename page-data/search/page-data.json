{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"비전공자로서 혼자 개발자가 되고자 학습을 하던 당시, 나를 가장 괴롭히는 의문은 내가 올바른 방향과 속도로 성장하고 있는가였다. 이 의문은 우테코에 와서도 변함없이 나를 괴롭히는 의문이었다. 나는 학습을 할수록 내가 무엇을 배웠는지, 얼마나 성장했는지를 확인할 수 있는 방법이 필요했다. 그래서 나는 나 자신에게 매일 밤 질문을 던졌다. \"오늘, 내가 정말…","fields":{"slug":"/am-i-doing-good/"},"frontmatter":{"date":"May 10, 2023","title":"나는 올바르게 성장하고 있는가","tags":["회고"]},"rawMarkdownBody":"\n\n비전공자로서 혼자 개발자가 되고자 학습을 하던 당시, 나를 가장 괴롭히는 의문은 내가 올바른 방향과 속도로 성장하고 있는가였다. 이 의문은 우테코에 와서도 변함없이 나를 괴롭히는 의문이었다. 나는 학습을 할수록 내가 무엇을 배웠는지, 얼마나 성장했는지를 확인할 수 있는 방법이 필요했다. 그래서 나는 나 자신에게 매일 밤 질문을 던졌다. \"오늘, 내가 정말로 잘했는가?\" 이 질문은 나에게 매일 밤 자기 성찰의 시간을 주었고, 나의 성장을 돕는 중요한 순간이 되었다.\n\n## 자기성찰 체크리스트\n\n나는 밤이 되면 항상 나 자신에게 묻는다. \"오늘, 내가 정말로 잘했는가?\" 이런 자기 성찰의 시간이 바로 나의 하루를 정리하고, 내일을 위한 계획을 세우는 중요한 순간이다. 아래는 내가 매일 밤 자기 전에 체크하는 목록과 그 과정이다.\n\n첫 번째로, 정말로 나는 최선을 다했는지 나에게 묻는다. 세계적인 축구 스타인 웨인 루니는 경기가 끝난 후 조금이라도 뛸 체력이 남아있는 자신을 보면 정말 한심하기 짝이 없었다고 말했다. 나는 항상 내가 최선을 다했는지를 확인한다. 이를 통해 나는 내가 더 노력해야 할 부분을 찾고, 내일을 위한 계획을 세울 수 있다.\n\n두 번째로, 오늘 깨닫거나 학습한 개념을 복습하는 시간이다. 이 과정에서는 단순히 오늘 배운 내용을 되새김질하는 것뿐만 아니라, 그것을 어떻게 내 것으로 만들 것인지에 대한 계획을 세운다. 이를 통해 나는 배운 내용을 보다 깊이 이해하고, 실제로 사용할 수 있도록 한다.\n\n세 번째로, 나는 내가 작성한 코드에 대한 리뷰를 한다. 이 과정에서는 코드의 효율성, 가독성, 그리고 구조 등을 고려하며, 문제가 있다면 어떻게 개선할 수 있을지를 생각한다. 이를 통해 나는 내 코드에 대한 이해도를 높이고, 다음날 어떤 부분에 집중하여 코드를 짤 수 있을지 청사진을 그릴 수 있다.\n\n마지막으로, 나는 내일의 계획을 세운다. 나는 남들과의 비교는 관심이 없는 편이다. 늘 내일의 나 자신이 오늘보다 더 나아질 수 있도록 계획하고 그것을 실행에 옮기기 위해 노력한다. 내일의 학습 목표를 설정하고, 어떤 주제를 학습할 것인지, 어떤 코드에 집중할 것인지 등을 결정한다.\n\n이런 식으로, 나는 매일 밤 내 자신에게 질문하며, 내가 정말로 잘 하고 있는지를 점검한다. 이는 나에게 자기 성찰의 시간을 주며, 나의 성장을 돕는다. 그래서 나는 매일 밤 이 시간을 정성껏 준비하고 통과한다. 이를 통해 나는 내가 정말로 잘하고 있는지를 체크하고, 내일을 위한 계획을 세울 수 있다.\n"},{"excerpt":"Intro 우아한테크코스 5기 FE 부엉이. 내 새로운 이름이자 현재의 나를 소개하는 말이 되었다. 하루하루가 꿈만 같았고 매 순간이 새로웠다. 본고에서는 우테코에서의 첫 두달간 레벨1 과정을 모두 마친 후에 \n다시 그 기간을 돌아보며 회고를 진행하려 한다. Main 인간관계의 중요성 우테코에 처음 들어가서 놀란 점은 우테코는 소위 말하는 들에게 맞춰진 …","fields":{"slug":"/woowacourse-level-one/"},"frontmatter":{"date":"April 04, 2023","title":"우테코 레벨1 회고","tags":["회고"]},"rawMarkdownBody":"\n## Intro\n\n우아한테크코스 5기 FE 부엉이. 내 새로운 이름이자 현재의 나를 소개하는 말이 되었다. 하루하루가 꿈만 같았고 매 순간이 새로웠다. 본고에서는 우테코에서의 첫 두달간 레벨1 과정을 모두 마친 후에 \n다시 그 기간을 돌아보며 회고를 진행하려 한다.\n\n## Main\n\n### 인간관계의 중요성\n\n우테코에 처음 들어가서 놀란 점은 우테코는 소위 말하는 `인싸`들에게 맞춰진 시스템이라고 생각했다. 들어가기 전에는 대다수의 우테코 합격생들은 개발에 온 시간을 갈아넣은 극 내향형 사람들이지 않을까 하고 생각했다.\n하지만, 매일 아침 팀단위로 `데일리 미팅` 을 진행하고, 자체적인 `연극`을 하는가 하며, 심지어는 컴퓨터 한대를 놓고 두명이서 끝이 없는 의사소통을 하며 개발을 하는 `페어 프로그래밍` 을 시킨다. 즉, 내향형이 살아남기 힘든 시스템이다.\n처음보는 사람에게 이름조차 물어보기 힘들어하는 극 내향형인 나로써는 초반에 적응하기 힘들었고 심지어는 어느정도 시스템에 대한 원망도 했던 것 같다. \n\n시간이 지날수록 생각이 바뀌었다. 현재는 개발자에게 얼마나 사회성과 커뮤니케이션 스킬이 요구되고 이가 득이되는지 깨닫고 있다. 물론 아직 우테코에서 정식적인 협업을 해보진 않았지만, 페어 프로그래밍을 통해 대화하고 사람과 소통하는 스킬이 많이 \n좋아졌다고 생각한다. 상대방의 의견이 아니라고 생각하면 맹목적으로 반대하기 보다는 나의 의견을 제시하며 대화 및 토론을 유도하는 방식을 배웠다. 또한 개발 방식에는 정답이 없다. 이에따라 개인마다 다른 방식으로 구현할 수 있는 케이스를 많이 보곤 하는데, 이 때, \n나는 이미 나의 스타일이 고착 및 학습되어있음을 인정하고, 오히려 다른 이의 스타일을 배우기 위해 우선 경청하고 받아드리는 방식을 배웠다. 이러한 소프트 스킬에서의 깨달음을 적용하자, 실제 개발 실력적으로도 서로의 상호관계를 통해 성장이 같이 이루어짐을 체감하였다. \n\n두서없이 말한 부분이 많지만, 함축적으로는 개발자에 소프트 스킬적인 역량은 필수적일수도 있다 생각이 바뀌게 되었고, 실제 우테코에서 두달동안 다른 이들과 소통을 통해 얻은 부분이 굉장히 많다고 생각했다. \n\n### 유연한 사고\n\n나 자시의 성향인지, 독학으로 개발을 시작해서 그런지 몰라도, 블로그 글이나 시\n\n## Wrapping up\n\n"},{"excerpt":"Intro 오늘 진행한  에서 나눈 대화다. 🙋🏻 아래 코드는 생성자 함수로 생성한  이다. 🙋🏻  변수의 타입은  일테고. 🙋🏻  가 어떻게 이 나오는걸까? 🙋🏻‍♂️ 이 그렇게 변환하는거 아니야? 🙋🏻 그래서 어떻게 변환하길래  와  의 덧셈이 가능한거지? Main 이는  에서 찾을 수 있었다. AdditiveExpression 규칙은 덧셈 연산자(+)가 사용된 경…","fields":{"slug":"/js-wrapping-object/"},"frontmatter":{"date":"March 27, 2023","title":"[JavaScript] 자바스크립트의 객체 wrapper에 대해 알아보자","tags":["JavaScript"]},"rawMarkdownBody":"  \n\n## Intro\n\n오늘 진행한 `자바스크립트 스터디` 에서 나눈 대화다.\n\n🙋🏻 아래 코드는 생성자 함수로 생성한 `String Object` 이다.\n\n```js  \nconst a = new Number(1);  \n```   \n🙋🏻 `a` 변수의 타입은 `object` 일테고.\n\n```js  \nconst a = new Number(1);  \ntypeof a // object  \n```  \n\n🙋🏻 `a + 2` 가 어떻게 `3`이 나오는걸까?\n\n```js  \nconst a = new Number(1);  \ntypeof a cosnsole.log(a + 2) // 3  \n```  \n\n🙋🏻‍♂️ `JavaScript 엔진`이 그렇게 변환하는거 아니야?\n\n🙋🏻 그래서 어떻게 변환하길래 `object` 와 `number` 의 덧셈이 가능한거지?\n\n\n<br/>  \n본고에서는 어떻게 위처럼 결과가 나올 수 있었는지에 대해 다룰 예정이다. 단순 \"`JavaScript 엔진`이 형변환을 한다.\" 라는 개념을 넘어보고 싶었다.   \n  \n---  \n\n## Main\n\n이는 `ECMAScript 11.6.1 The Addition operator ( + )` 에서 찾을 수 있었다.\n\n\n> AdditiveExpression 규칙은 덧셈 연산자(+)가 사용된 경우를 나타냅니다. 이 규칙은 다음과 같이 평가됩니다:\n\n> 1. AdditiveExpression을 평가한 결과를 lref에 할당합니다.\n> 2. lref에서 값(value)을 가져와 lval에 할당합니다. 이때, lval은 앞서 평가된 결과의 원시 값(primitive value)입니다.\n> 3. MultiplicativeExpression을 평가한 결과를 rref에 할당합니다.\n> 4. rref에서 값(value)을 가져와 rval에 할당합니다. 이때, rval은 앞서 평가된 결과의 원시 값(primitive value)입니다.\n> 5. lval과 rval의 원시 값을 구합니다. 이때, ToPrimitive() 메소드를 사용하여 객체 래퍼 타입을 원시 값으로 변환합니다.\n> 6. lprim과 rprim의 타입을 비교하여 둘 중 하나라도 문자열(string) 타입이라면, lprim과 rprim을 문자열로 변환하여 이어 붙인 결과를 반환합니다.\n> 7. 그렇지 않다면, lprim과 rprim을 숫자(number) 타입으로 변환하여 덧셈 연산을 수행합니다.\n\n언뜻 보면 이해가 가지 않을 수 있다. 우선 아래의 과정에서 `값을 가져온다` 는 말은 일반적인 원시 타입이면 간단할 수 있으나, `객체 wrapper` 타입인 경우 말이 달라진다.  \nJavaScript 엔진은 연산자나 피연산자가 참조 타입일 때, 해당 값을 가져오기 위해 `GetValue()` 메서드를 사용한다. 이때, `GetValue()` 메서드 내부에서는 해당 값이 객체 `wrapper 타입`인 경우 `ToPrimitive()` 메소드를 사용하여 객체 래퍼를 원시 값으로 변환한 후 반환한다.\n\n따라서, 참조 타입 값에 대한 연산이 수행될 때, 자바스크립트 엔진은 내부적으로 `GetValue()` 함수와 `ToPrimitive()` 메소드를 사용하여 값을 처리하게 된다.\n\n> 2. lref에서 값(value)을 가져와 lval에 할당합니다. 이때, lval은 앞서 평가된 결과의 원시 값(primitive value)입니다.\n\n다시한번 처음에 나왔던 예시를 살펴보자.\n\n`new Number(1)`은 내부적으로 자동으로 `객체 wrapper`를 생성한다.\n\n`new` 키워드를 사용하여 `Number 생성자 함수`를 호출할 때, 반환되는 값은 `Number 객체 wrapper`이다. 따라서, `new Number(1)`은 1이라는 원시 값에 대해 `Number 객체 wrapper`를 생성하는 것이다.\n\n이렇게 생성된 Number 객체 wrapper는, `Number.prototype` 객체에 정의된 메소드를 포함하여 객체처럼 다양한 기능을 제공한다. 예를 들어, `toFixed()` 메소드를 호출하여 소수점 이하 자리수를 조절할 수 있다.\n\n```js  \nconst a = new Number(1);  \ncosnsole.log(a + 2) // 3  \n```  \n\n`new Number(1)` 은 내부적으로 자동 객체 wrapper 를 생성하고, 평가시에 `GetValueOf()` 메서드를 사용하여 값을 추출해낸다. 이후 `ToPrimitive()` 메서드를 사용하여 이를 `원시 타입` 으로 형변환 한다.\n\n`a + 2`와 같은 덧셈 연산은 위와 같은 규칙을 따라 `1 + 2` 로 평가되어 연산된다.\n\n\n\n  \n---  \n\n## Wrapping Up\n\n위의 과정에서 나왔듯이 객체 래퍼를 사용하는 것이 일반적인 원시 값 처리보다 더 많은 자원을 사용하므로 성능상의 문제가 있을 수 있다.\n\n또한, 객체 래퍼는 원시 값과는 다르게 불변하지 않다. 따라서, 객체 래퍼를 사용하여 값에 대한 연산을 수행할 경우, 예상치 못한 결과가 발생할 수 있다.\n\n예를 들어, 다음과 같이 `== 연산자`를 사용하여 객체 래퍼와 원시 값의 비교를 수행하면, 예상치 못한 결과가 발생할 수 있다.\n\n```js  \nconst num = 10;  \nconst numObj = new Number(10);  \n  \nconsole.log(num == numObj); // true  \nconsole.log(num === numObj); // false  \n```  \n\n이처럼, 객체 래퍼를 사용하여 값을 처리할 때는 위와 같은 예기치 않은 결과가 발생할 가능성이 있으므로 주의해야 한다. 따라서, 가능하다면 원시 값 처리를 우선적으로 고려하는 것이 좋다.\n  \n---\n"},{"excerpt":"Intro 개발자가 되기로 결심한 뒤, 항상 꿈에 그리던 우아한테크코스에 합격하고 벌써 한 달이라는 시간이 흘렀다. 매 순간 간절했고, 진심이었다. 한 달 동안 제일 크게 우테코의 장점이라고\n생각한 에 대해 다루며 글을 이어가려 한다. Main 혼자가 편했다. 외로울 때도 있고, 타인과 함께라면 웃을 일도 많겠지만 이상할 정도로 1년 전부터 혼자가 편했다…","fields":{"slug":"/woowacourse-first-month/"},"frontmatter":{"date":"March 20, 2023","title":"🦉 부엉이의 함께 자라기 in 우테코","tags":["회고"]},"rawMarkdownBody":"\n## Intro\n\n개발자가 되기로 결심한 뒤, 항상 꿈에 그리던 우아한테크코스에 합격하고 벌써 한 달이라는 시간이 흘렀다. 매 순간 간절했고, 진심이었다. 한 달 동안 제일 크게 우테코의 장점이라고\n생각한 `크루원 간의 상호관계`에 대해 다루며 글을 이어가려 한다.\n\n## Main\n\n혼자가 편했다. 외로울 때도 있고, 타인과 함께라면 웃을 일도 많겠지만 이상할 정도로 1년 전부터 혼자가 편했다. 개발을 시작한 이후 내 목표는  `훌륭한 개발자`였다. 되고싶은 개발자는 연봉이 높거나 미디어에 노출되어 인기가 있는 개발자가 아니었다.\n순수하게 개발을 잘하는, 팀원에게 항상 도움이 되는, 동료들이 기댈 수 있는 개발자가 되고 싶다 이를 위해 나는 개발적 체급을 키워야 한다는 강박증이 있었다. 보통 이틀에 4시간 정도 잘 정도로 간절했고, 두려웠다.\n\n개발적 체급을 키우기 위해 나를 방안에 가두었다. 매 순간 채찍질했다. 그리고 너무 힘들었지만, 필요 없다고 생각했던 요소들을 제거했다. 운동을 아예 하지 않았다. 친구들의 연락을 피했다. 연인과의 이별을 결심했다. 공통점을 생각해보면\n인간관계를 끊으며, 나만의 시간을 최대한으로 확보했다. 개발을 누구보다 확실히 배울 수 있는 주체인 `인터넷`을 맹신했으며, 주변인들에게 소홀했다. 그리고 그게 항상 정답이라고 믿었으며, 지금의 나를 만들었다고 생각했다. 또한 해커톤을 참여하며 비전공자라 무시당한 경험도 있었다.\n더욱 마음을 독하게 먹고 `혼자`만의 힘으로 훌륭한 개발자가 되고자 발버둥 쳤다.\n\n그렇게 우테코에 합격했다. 사실 처음에는 변하지 않은 생각을 하고 있었다. 우테코를 통해 나에게 주어진 기회는\n현업자분들에게 리뷰를 받을 수 있는 `환경`과 탄탄한 `커리큘럼`뿐이라 생각하며 나 스스로를 또다시 혼자 가두었다.\n\n하지만 시간이 지날수록 생각이 변하기 시작했다. 첫 시작은 흡연으로부터 시작됐다. 크루원들과 흡연하며 종종 미션 관련 이야기기를 했다. 비교적 가벼운 고민과 주제였을지라도, 영감을 받으며 모르는 부분을 자각할 수 있었다. 혼자 생각하고, 구글링하며 학습하는 프로세스와는 분명히 다른 부분이\n존재했고 성장과 관련하여 높은 효율성이 존재한다는 생각이 들었다. 다른 크루원들에게도 다가가 보았다. 코드를 치고 있는 크루원에게 이유 없이 옆에 구경하며 나와는 다른 방식으로 미션에 접근하는 모습을 보며, 괜히 말을 걸었다.\n깨달은 점과, 배울 수 있는 부분이 무궁무진했고, 설령 정확하지 않은 견해를 서로 말할지라도 같이 생각하고, 고민하며 매초가 나한테 매우 뜻깊은 시간이었다.\n\n`함께 자라기`라는 책에서 구글이 밝힌 탁월한 팀의 특징은 팀 토론 등 특별히 생긴 활동을 통해 심리적 안전감을 개선하는 패턴을 반복한다고 한다. 여기서 `심리적 안전감`이란 내 생각이나 의견, 질문, 걱정, 실수가 드러났을 때 처벌받거나 놀림당하지 않을 거라는 믿음이다.\n우테코의 크루원들도 동일하다. 비전공자라 깎아내리지 않는다. 터무니없는 개발 관련 주제를 꺼낸다고 무시하지 않는다. 질문한다고 귀찮아하기는커녕 오히려 초롱초롱한 눈으로 대화에 진지하게 참여한다. 그 결과, 나는 크루원들과의 `상호작용`이 너무 좋고 소중하게 여겨지는 지점에 도달할 수 있었다.\n이제는 크루원들과의 대화를 즐기고 먼저 하고 싶어 한다.\n\n## Wrapping up\n\n한 달간 이상할 정도로 생각이 바뀌었다. 더 이상 `혼자`에 가중치를 두지 않고 `타인`도 전적으로 믿고 `동료`라 생각한다. 6시 이후 11시까지 남아있더라도 몰두하고 있는 주변 분들에게 존경심이 들고 나 또한 매 순간 자극을 받는다.\n사실 우테코에 들어오기 전 `함께 자라기(애자일로 가는 길)`라는 책을 읽었을 때 나의 가치관과 다른 부분이 여럿 존재해 공감하기 어려웠다. 하지만 최근에는 책 내용을 맹신하기에 이르렀다. `타인`과 함께 성장하는\n내일을 기대하며 이만 이 글을 마친다.\n"},{"excerpt":"Intro 타입스크립트에서 접미에 붙는  는 non-null 단언 연산자라 불리웁니다. 만일 타입스크립트 컴파일러가 값이   혹은  일수도 있다하며 불평한다면 단순히 뒤에   를 붙이며, 이 값은 \n 혹은  가 될수없다 말하시면 깔끔하게 해결 가능합니다. (라고 말하면 이 글을 당장 끄시는 분들이 많겠죠? 장난입니다. 🫠)   Main 1️⃣ non-null…","fields":{"slug":"/ts-non-null-assertion-operator/"},"frontmatter":{"date":"March 13, 2023","title":"[Typescript] Non-null assertion operator ! (non-null 단언 연산자)","tags":["Typescript"]},"rawMarkdownBody":"\n## Intro\n\n타입스크립트에서 접미에 붙는 `느낌표 (!)` 는 non-null 단언 연산자라 불리웁니다. 만일 타입스크립트 컴파일러가 값이 `null`  혹은 `undefined` 일수도 있다하며 불평한다면 단순히 뒤에  `!` 를 붙이며, 이 값은 \n`null` 혹은 `undefined` 가 될수없다 말하시면 깔끔하게 해결 가능합니다.\n\n(라고 말하면 이 글을 당장 끄시는 분들이 많겠죠? 장난입니다. 🫠) \n\n![img.png](img.png)\n\n---\n\n## Main\n\n### 1️⃣ non-null assertion operator (!) 란?\n\nnon-null 단언 연산자란 `typescript type checker` 에게 적용된 피연산자가 `null` 이나 `undefined` 가 아니다! 라고 단언하게 해주는 연산자입니다.\n\n예시를 보며 살펴봅시다. \n`문자열` 을 인자로 받아 대문자로 변환하여 반환하는 함수를 만든다 가정하면 아래 결과와 같이 typescript type checker 는\n\n> 'givenStr' is possibly 'null'.\n\n라며 빨간줄과 함께 불평을 하기 시작합니다.\n\n```ts\nconst toUpperCase = (givenStr: string | null) => {\n    return givenStr.toUpperCase()\n}\n```\n\n![img_1.png](img_1.png)\n\n이는 `toUpperCase()` 메서드가 자바스크립트의 `String` 객체의 내장 메서드이기에 `null || undefined` 값에는 사용할 수 없기 때문입니다.\n\n그렇다면 `non-null assertion operator` 를 사용하여 `givenStr` 은 `null` 이나 `undefined` 가 아닙니다! 라고 단언한다면 어떻게 될까요?\n\n\n```ts\nconst toUpperCase = (givenStr: string | null) => {\n    return givenStr!.toUpperCase()\n}\n```\n\n![img_2.png](img_2.png)\n\n우선적으로 typescript type checker 의 불평을 잠재웠지만, 과연 바람직한 결과일까요? 정말 인자로 `null | undefined` 값이 들어가지 않을 것이라고 확신할 수 있나요?\n\n### 2️⃣ 대안\n\n코드는 길어질 수 있더라도 아래와 같이 `type guard` 를 통해 인자로 `null` 이 들어올 수 있는 상황에 대비할 수 있고, type checker 의 불평또한 해소할 수 있습니다.\n\n```ts\nconst toUpperCase = (givenStr: string | null) => {\n  if (givenStr === null) return null;\n  return givenStr.toUpperCase();\n};\n```\n\n또한 다른 방식으로 `nullish coalescing operator(??)` 를 사용할 수도 있습니다.\n\n```ts\nconst toUpperCase = (givenStr: string | null) => {\n  return givenStr ?? null?.toUpperCase();\n};\n```\n\n다른 방식으로는 Error 를 발생시키는 방법 또한 존재합니다.\n\n```ts\nconst toUpperCase = (givenStr: string | null) => {\n  if (givenStr === null) {\n   throw new Error('unexpected err: givenStr not present') \n  }\n  return givenStr.toUpperCase();\n};\n```\n\n\n---\n\n## Wrapping Up\n\ntypescript 2.0 에서 공개된 `non-null assertion operator(!)` 는 타입스크립트의 type checking system 을 무시하고 느슨한 타입체킹을 유도하기에 정말 어쩔 수 없을떄만 사용해야 하지 않을까? 라는 생각을 했습니다.\n\n---\n\n## References\n\n- https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\n- https://github.com/typescript-eslint/typescript-eslint/blob/v2.34.0/packages/eslint-plugin/docs/rules/no-non-null-assertion.md\n"},{"excerpt":"서론  https://github.com/woowacourse/javascript-lotto 우아한테크코스 두번째 미션인  미션에서 기존에 콘솔 기반으로 구현한 구조를 UI 와 도메인 여역을 분리 할 수 있는 설계로 \n리팩토링하기 위해 고민을 했었다. 그러던 중 element 를 동적으로 생성하여 비출 수 있다면 좋지 않을까 라고 생각했었다. vanill…","fields":{"slug":"/js-global-state-management-vanilla-js/"},"frontmatter":{"date":"February 27, 2023","title":"Vanilla JS 로 간단한 전역 상태 관리 시스템 만들기","tags":["JavaScript","Global State Management"]},"rawMarkdownBody":"\n## 서론\n\n![img.png](img.png)\n\nhttps://github.com/woowacourse/javascript-lotto\n\n우아한테크코스 두번째 미션인 `행운의 로또` 미션에서 기존에 콘솔 기반으로 구현한 구조를 UI 와 도메인 여역을 분리 할 수 있는 설계로 \n리팩토링하기 위해 고민을 했었다. 그러던 중 element 를 동적으로 생성하여 비출 수 있다면 좋지 않을까 라고 생각했었다. vanilla js 로 이를 구현하기 위해 \n필요하다고 생각했던 부분을 정리했었다.\n\n1. element creating system (요소 생성)\n- 인자로 필요한 정보를 받아 DOM 요소를 동적으로 생성할 수 있는 시스템이 필요했다. \n\n2. global state management (전역 상태 관리)\n\n- 동적으로 요소를 생성하면 각각의 요소(component) 는 정보(상태)를 갖게 된다. 하지만 로또 미션에서는 해당 상태를 추합해 결과를 도출해야 했기에, 상태를 \n모든 컴포넌트가 읽고/ 쓸 수 있으며 값에 대해 접근할 수 있어야 했다. 또한 전역 상태를 만들지 않으면 결국 모든 상태는 위로 올라가 최상단인 \n`controller layer` 가 다뤄야 하며, 책임에 위배된다고 생각했다.\n\n물론 나는 해당 방식을 `사용하지 않았다`. 이유는 생각보다 상황에 맞게 동적으로 컴포넌트의 생성 유무(개수)에 영향을 주는 상황은 구매한 로또의 개수 단 한가지의 경우라 생각했기에\n굳이 필요할까? 라는 생각을 했다.\n\n로또를 구매했을 떄, 나머지 컨텐츠가 보이는 등 상황에 맞게 컴포넌트가 되어 화면에 보이게 처리할 수도 있지만, 이는 변화하지 않고 항상 같은 모습을 보여주기에, \n순수하게 CSS로 `display: hidden` 을 적극적으로 이용한다면 문제없이 처리할 수 있다고 생각했다.\n\n그럼에도 불구하고, 위의 이론대로 구현하기 위해 공부하고 시도한 내용을 정리하려 한다. 본고에서는 2번에 해당하는 vanilla js 로 구현한\n`global state management (전역 상태 관리)` 를 다룰것이며, 실제 프로덕션 코드가 아닌, 예시 코드를 통해 가능한 간단하게 풀어보려 한다.\n\n---\n\n## 본론\n\n### 구조\n\n```lua\n      +----------------+           +---------------+\n      |                |           |               |\n+---->+   LottoInput   +----+  +-->+   Store (lotto)+-------+\n|     |                |    |  |   |               |       |\n|     +----------------+    |  |   +---------------+       |\n|                           |  |                           |\n|     +----------------+    |  |   +---------------+       |\n|     |                |    |  |   |               |       |\n+---->+      Lotto     +-------+   |     Index     +<------+\n      |                |           |               |\n      +----------------+           +---------------+\n\n```\n- `Index` 파일은 전역상태 공간에 `subscribe(구독)` 을 한다. 변화가 생기면, `Lotto` 컴포넌트를 새로운 데이터와 함께 `re-render` 한다.\n\n- `Store` 객체는 전체적인 global state management를 담당한다. 이는 전역으로 관리할 모든 데이터를 담고있는 `state` object 를 가지고 있다.\n\n- `LottoInput` 컴포넌트는 유저의 로또 번호와 보너스 번호를 캡쳐해 global state store 에 전달한다.\n\n- `Lotto` 컴포넌트는 전역 상태 객체에 있는 값을 렌더한다.\n\n\n위 구조는 실제 프로덕션 코드가 아니며, 편의상 통계 도출 로직 대신 `Lotto` 컴포넌트를 활용해 전역 상태 값을 보여주기만 하는 예시다.\n\n\n### index.js\n\n```js\nimport Lotto from './Lotto.js';\nimport LottoInput from './LottoInput.js';\nimport store from './store.js';\n\nconst lotto = new Lotto();\nconst lottoInput = new LottoInput();\n\nstore.subscribe('lotto', () => {\n  lotto.render();\n});\n\nlottoInput.render();\n```\n\n### LottoInput.js\n\n```js\nclass LottoInput {\n  constructor() {\n    this.state = {\n      numbers: [],\n      bonus: null\n    };\n  }\n\n  handleSubmit(event) {\n    event.preventDefault();\n    const form = event.target;\n    const numbers = Array.from(form.querySelectorAll('input[name=\"number\"]'))\n      .map(input => Number(input.value))\n      .filter(number => number >= 1 && number <= 45 && !isNaN(number))\n      .slice(0, 6); \n    const bonus = Number(form.querySelector('input[name=\"bonus\"]').value);\n    if (numbers.length === 6 && bonus >= 1 && bonus <= 45 && !isNaN(bonus)) {\n      store.setState('lotto', { numbers, bonus });\n      form.reset();\n    }\n  }\n\n  render() {\n    const container = document.createElement('div');\n    const form = document.createElement('form');\n    const inputContainer = document.createElement('div');\n    \n    for (let i = 1; i <= 6; i++) {\n      const input = document.createElement('input');\n      input.setAttribute('type', 'number');\n      input.setAttribute('name', 'number');\n      input.setAttribute('min', '1');\n      input.setAttribute('max', '45');\n      inputContainer.appendChild(input);\n    }\n    \n    const bonusInput = document.createElement('input');\n    bonusInput.setAttribute('type', 'number');\n    bonusInput.setAttribute('name', 'bonus');\n    bonusInput.setAttribute('min', '1');\n    bonusInput.setAttribute('max', '45');\n    inputContainer.appendChild(bonusInput);\n    form.appendChild(inputContainer);\n    \n    const submitButton = document.createElement('button');\n    submitButton.setAttribute('type', 'submit');\n    submitButton.appendChild(document.createTextNode('Buy Lotto Ticket'));\n    form.appendChild(submitButton);\n    form.addEventListener('submit', this.handleSubmit.bind(this));\n    \n    container.appendChild(form);\n    document.body.appendChild(container);\n  }\n}\n\nexport default LottoInput;\n```\n\n### Lotto.js\n\n```js\nclass Lotto {\n  constructor() {\n    this.state = {\n      numbers: [],\n      bonus: null\n    };\n    store.subscribe('lotto', this.render.bind(this));\n  }\n\n  render() {\n    const { numbers, bonus } = store.getState('lotto');\n    const container = document.createElement('div');\n    const numbersText = document.createTextNode(`Numbers: ${numbers.join(', ')}`);\n    const bonusText = document.createTextNode(`Bonus: ${bonus}`);\n    container.appendChild(numbersText);\n    container.appendChild(document.createElement('br'));\n    container.appendChild(bonusText);\n    document.body.appendChild(container);\n  }\n}\n\nexport default Lotto;\n```\n\n### Store.js\n\n```js\nclass Store {\n  constructor() {\n    this.state = {};\n    this.listeners = {};\n  }\n\n  getState(key) {\n    return this.state[key];\n  }\n\n  setState(key, newState) {\n    this.state[key] = {\n      ...this.state[key],\n      ...newState\n    };\n    this.notify(key);\n  }\n\n  subscribe(key, listener) {\n    if (!this.listeners[key]) {\n      this.listeners[key] = [];\n    }\n    this.listeners[key].push(listener);\n  }\n\n  unsubscribe(key, listener) {\n    if (this.listeners[key]) {\n      const index = this.listeners[key].indexOf(listener);\n      if (index !== -1) {\n        this.listeners[key].splice(index, 1);\n      }\n    }\n  }\n\n  notify(key) {\n    if (this.listeners[key]) {\n      ...this.listeners[key].forEach(listener => listener());\n    }\n  }\n}\n\nconst store = new Store();\n\nexport default store;\n     \n\n```\n\n위의 `Store.js` 의 로직은 본고의 핵심이 되는 로직이다.\n헷갈렸던 로직인 `subscribe`, `unsubscribe`, 그리고 `notify` 메서드에 대해 적어보고자 한다.\n\n- `subscribe` 메서드는 함수(컴포넌트)를 인자로 받아 subscribers 리스트에 추가한다. 쉽게 말해 전역 상태 공간을 \n`구독` 한 컴포넌트의 배열에 새로운 함수(컴포넌트)를 추가한다는 뜻이다. 전역 상태가 변경될 때마다, `notify` 메서드를 통해 구독한 컴포넌트들을\n새로운 상태(new state)와 함께 re-render 한다.\n\n  \n- `unsubscribe` 메서드 또한 함수(컴포넌트)를 인자로 받아 subscribers 리스트에서 제거한다. 이는 더이상 해당 컴포넌트가 전역 상태와 연관이 없는 \n컴포넌트가 될 때 사용한다.\n\n\n- `notify` 메서드는 전역 상태가 바뀔떄마다 호출된다. subscribers(구독한 컴포넌트들) 배열을 순회하며 해당 컴포넌트를 새로운 상태값과 함께 호출한다.\n이는 전역 상태 공간을 구독한 컴포넌트들이 상태가 바뀌었는지 알 수 있는 유일한 방법이다.\n\n---\n\n## 마치며\n\n비록 실제 구현한 코드에는 적용하지 못했지만, 최대한 전역 상태 관리를 사용해보고자 하는 과정에서 배운점도, 느낀점도 많은 것 같다.\n시간이 있을 떄, 실제 `redux` 가 동작하는 방식처럼 만들어보고 싶은 니즈가 있다.\n\n\n"},{"excerpt":"서론  비전공자 출신으로 개발자가 되고자 결정한 순간부터 목표로 잡았던  에 들어갈 수 있게 되었다. 왜 당장 취업이 아닌 우테코를 목표로 잡았는지에 대한 이유는 여러가지가 있었다. 생각보다 목숨을 걸정도로 몰입하여 프론트엔드 개발자가 되고자 하는 사람이 주위에 많지 않았고, 이에 따라 그러한 사람들과 에 대한 니즈가 있었다. 메이저 급에 속하는 개발자 …","fields":{"slug":"/oohtech-success/"},"frontmatter":{"date":"December 28, 2022","title":"우아한 테크코스 5기 프론트엔드 최종합격 후기 및 과정","tags":["우테코"]},"rawMarkdownBody":"\n## 서론\n\n![img.png](img.png)\n\n비전공자 출신으로 개발자가 되고자 결정한 순간부터 목표로 잡았던 `우아한 테크코스 5기` 에 들어갈 수 있게 되었다. 왜 당장 취업이 아닌 우테코를 목표로 잡았는지에 대한 이유는 여러가지가 있었다.\n\n1. 생각보다 목숨을 걸정도로 몰입하여 프론트엔드 개발자가 되고자 하는 사람이 주위에 많지 않았고, 이에 따라 그러한 사람들과 `같이 몰입하여 성장할 수 있는 환경`에 대한 니즈가 있었다.\n2. 메이저 급에 속하는 개발자 양성 기관 중 웹 프론트엔드 코스를 가진 기관은 우테코가 `유일하다`고 생각하였다.  \n3. 여지껏 지속적으로 나만의 방향을 잡아 독학으로 학습을 하였지만, 항상 불안감에 가득찬 채 방향을 잡을수밖에 없었고, 이에따라 `등대`와 같이 길을 잡아줄 수 있는 기관에 대한 니즈가 있었다.\n\n---\n\n## 본론\n\n### 1. 지원서 \n\n![img_1.png](img_1.png)\n\n여러 합격후기에서 말했듯이, 나또한 우테코에 합격하기 위해서는 지원서가 매우 중요하게 작용하는 요소라 생각한다. 우테코는 단순히 개발을 얼마나 잘하는지 역량만을 보지 않고, 지원자가 얼마나 간절한지, 얼마나 폭발적으로 성장할 수 있는지에 대한\n종합적 요소를 판단한다고 생각하였다. 이에따라 지원서가 굉장히 크게 작용한다 생각하였고, 같은 계열은 아니지만, 이미 주변에 지원서를 많이 써본 분들과 이미 취업을 한 분들에게 자문을 구하며 나름대로 지원서에서 중요한 요소들을 공부하려 노력하였다.\n이를 통해 느낀 중요점들을 나열하려 한다.\n\n#### - 최대한 길게 쓰려 노력했다.\n\n지원서는 보통 문항당 `n자 이내` 라고 명시하는 경우가 많다. 하나를 보면 열을 안다고 자신이 얼마나 합격에 목마른 사람인지를 어필하는 영역에 있어서는 반드시 제한 글자수를 꽉 채우는것이 중요하다 생각했다. 물론 문장을 질질 끄며 일부러 길게 만드는 행동은 피했다.\n\n#### - 가독성을 높히려 노력했다.\n\n선발 프로세스를 진행하는 관계자분들은 하루에 몇개의 지원서를 읽을까? 이번 기수의 프론트엔드 파트 지원자만 해도 1200명 정도 되었던 것으로 기억하고, 이 모든 인원이 지원서를 제출했다. 이에따라 무조건 잘 읽히는 지원서가 유리하다고 판단하였고 이에따라 글의 중심 내용이 글의 첫머리에 오는 형태인\n`두괄식` 으로 지원서를 작성해야 한다고 생각하였다. 그리고 최대한 문장들을 간결하게 가져가고자 노력하였다.\n\n#### - 특별한 사람이 되려했다.\n\n지원자 1200명 중 최종합격 인원 50명에 들기 위해서는 얼마나 특별한 사람이라 느껴져야 할까? 합격하기 위해서는, 일관되게 본인을 특별한 사람으로 느껴지게 할 거대한 스토리가 필요하다 느꼈다. 나는 외국에서 중고등학교를 나와 영문학과에 갔지만, 개발자가 되고싶다 생각한 이후로 이를 악물고 독학을 통해 이뤄낸\n멋사 회장, 각종 헤커톤 수상 등 최대한 특별한 경험을 녹여내려 노력하였다. 본인을 어필할 수 있을만한 행보와 증거가 없다면 지금부터라도 만들고 도전하는 것이 중요하다 생각하였다.\n\n### 2. 프리코스\n\n![img_2.png](img_2.png)\n\n나름 취엽시장에 계속 관심을 가지고 분석였고, 주변인들의 후기를 들어볼수록 최근에는 `구현`에 많은 기업들이 점점 초점을 맞춘다고 생각하였다. 5기 지원부터는 처음으로 여지껏 시행되었던 알고리즘 중심의 소위 `코딩 테스트` 가 폐지되었고 해당 부분이 1주차 프리코스에 들어가게 되었다. 7개의 문제가 출제되었으며, 난이도 자체는 \n평이했다고 생각하였고 1주일이라는 기간이 주어졌다. 이를 통해 알고리즘 테스트 자체를 4주에 걸쳐 진행될 우테코 선발 프로세스의 `예열` 느낌으로 사용되었다는 느낌을 받았고 실제로는 2주차부터 진행된 문제들에서 `구현`이 중요하게 여겨졌다고 생각하였다. \n\n앞서 언급한 `구현`은 알고리즘에서 문제 분류에 사용되는 `구현`이 아니다. 이는 언어, 라이브러리, 프레임워크에 대한 깊은 이해를 기반으로 얼마나 주어진 요구사항에 맞추여 정확하고, 가시성이 높고, 효율적인 코드를 정확하게 짤 수 있는지에 대한 능력이라고 생각한다. 실제 프리코스에서는 `vanilla JavaScript` 를 기반으로 \n구현을 해야 했으며, 이는 단순히 스택을 넓히고 광범위하게 얕게 공부하기 보다는 `자바스크립트 Deep Dive` 와 다른 책들을 통해 언어에 대해 학습한 시간들이 도움이 많이 되었다.\n\n문제들 또한, 실제 다수의 프로젝트를 진행했던 경험을 통해 마주한 문제들과 해결을 기반으로 구현할 수 있었으므로, 최대한 많은 경험을 통해 준비를 하면 크게 도움이 될것이라 생각한다. 평소에도 `git` 을 최대한 활용하려 노력하고, 커밋 메세지 및 코드에서도 컨벤션을 지키며 `깔끔함`을 우선가치로 놓고 학습한다면 수월할 것이라 예상한다.\n\n### 3. 최종 테스트\n\n![img_3.png](img_3.png)\n\n지원서와 프리코스를 통해 최종테스트를 치룰 수 있는 기회를 얻는다면, 기존의 프리코스와 유사한 문제를 현장에서 오프라인으로 5시간 내에 구현해야 한다. 기존 1주일의 기간을 투자하여 최선의 코드를 짜려 노력하였지만, 5시간은 처음에는 테스트코드는 커녕 문제에 대한 이해, 구현을 하기에도 빡빡한 시간이라고 생각하였다. 하지만, 그동안 진행했던 \n프리코스를 계속 복습하고 전 기수에 진행된 프리코스를 풀며 시간을 단축하려 노력하였다 준비만 되어있다면 문제 난이도 자체는 5시간 내에 구현할 수 있도록 나오기 때문에 충분히 가능하다고 생각한다.\n\n---\n\n## 결론\n\n나는 우테코에 절박했다. 꼭 하고 싶었고 무엇과도 바꿀 수 없다 생각할 정도로 인생에서 큰 기점으로 느껴졌다. 근 1년 기간을 가지고 우테코에 합격할 수 있는 사람이 되기 위해 최선을 다했다고 생각한다. 또한 선발과정은, 물론 헤커톤 경험들이 있지만 방구석에서 갈고닦은 나를 처음으로 현업 종사자분들께 세세하게 평가받는 자리라 생각하여 매우 큰 부담감을 가지고 하루하루를 \n보냈다. 나도 여러 지원자분들의 후기를 읽으며 받은 부분이 너무나도 많기에 부족하지만 절박한 심정으로 후기를 찾아다닐 누군가를 도와주고 싶다 생각하였다. 합격하여 너무 행복하고 이제 다시 달릴 준비를 하려한다. \n\n\n\n\n"},{"excerpt":"서론  멋쟁이 사자처럼 10기 전체 해커톤에서 우리학교 팀원들과  이라는 물물경매 플랫폼으로 약 900명 / 150팀 중  이라는 좋은 성적을 받게 되었다.  깃헙 링크: https://github.com/bunderLikeLion 하지만 해커톤의 특성상 짧은 시간내로 를 만들어야 했었고, 개발 과정에서 놓치고 지나간 부분이 꽤나 많다는 부분을 인지하고 …","fields":{"slug":"/sellon/"},"frontmatter":{"date":"September 25, 2022","title":"멋쟁이사자처럼 10기 해커톤 이후 회고","tags":["JavaScript","React","React-query","Recoil","회고"]},"rawMarkdownBody":"\n## 서론\n\n![](.index_images/f2a6a028.png)\n\n멋쟁이 사자처럼 10기 전체 해커톤에서 우리학교 팀원들과 `Sellon` 이라는 물물경매 플랫폼으로 약 900명 / 150팀 중 `동상` 이라는 좋은 성적을 받게 되었다. \n\n깃헙 링크: https://github.com/bunderLikeLion\n\n하지만 해커톤의 특성상 짧은 시간내로 `product`를 만들어야 했었고, 개발 과정에서 놓치고 지나간 부분이 꽤나 많다는 부분을 인지하고 있었음에도 불구하고\n시간상의 문제로 인하여 선뜻 오로지 `성능 개선` 이라는 하나의 목표를 위해 충분한 시간을 투자할 수 없었다. 본고에서는 product 개발 과정에서 무엇을 중요시 하였으며, 해커톤이 끝난 후에 문제점을 파악하여 \n가능하다면 해결책 까지 찾는 과정을 다룰 예정이다.\n\n\n---\n\n## 본론\n\n### 1. 전체 구조 (structure)\n\n![](.index_images/e251c3f7.png)\n\n나름 고민하며 지속적인 `restructuring` 을 거친 구조이다. 모두가 알만한 디렉토리를 제외하고 설명이 필요한 부분만 다룰 예정이다.\n\n#### - pages - \n\n![](.index_images/28a0692a.png)\n\n`Navbar.js` 를 제외하고는 실질적인 `router`를 통해 개별의 주소를 가지는 거대한 `page component` 들이다. \n\n#### - components - \n\n![](.index_images/18c62f76.png)\n\n각 `page` 별로 들어가는 세세한 `component` 들이 들어있는 `directory` 이다. 간단한 구조의 page나 시간상 쪼개기 힘들었던 page들에 대한 세세한 컴포넌트들은 \n포함되지 않는 경우도 있다. 특이점은 `Shared` 디렉토리이다.  \n\n```js\nconst ValidationModal = ({\n  handleModal,\n  isModalOpened,\n  mainText,\n  subText,\n  btnText,\n  relatedId,\n  type,\n}) => {\n  const { mutate: allInFunc } = useAllInAuctionItemMutation(relatedId);\n  const { mutate: endDealingFuc } = useEndDealingMutation(relatedId);\n\n  const clickBtnFunc = () => {\n    if (type === 'allIn') {\n      allInFunc();\n    } else if (type === 'endDealing') {\n      endDealingFuc();\n    }\n    handleModal();\n  };\n\n  return (\n    <Modal\n      open={isModalOpened}\n      onClose={handleModal}\n      aria-labelledby=\"modal-modal-title\"\n      aria-describedby=\"modal-modal-description\"\n    >\n      <ModalContainer>\n        <Text>{mainText}</Text>\n        {subText && <SubText>{subText}</SubText>}\n        <ButtonContainer>\n          <ValidationButton onClick={clickBtnFunc}>{btnText}</ValidationButton>\n          <ValidationCancelButton onClick={handleModal}>\n            취소\n          </ValidationCancelButton>\n        </ButtonContainer>\n      </ModalContainer>\n    </Modal>\n  );\n};\n\nexport default ValidationModal;\n```\n\n위는 `ValidationModal` 즉, 확인을 받는 모달에 대한 `component`인데 이는 범용성이 넓고 매 상황에 직접 짜기에는 코드의 반복이 너무 많다고 판단되어 `props` 를 받아\n`customizing` 이 가능한 `재사용` 성이 있는 `component` 들을 모아놓은 디렉토리이다. \n\n\n#### - hooks -\n\n이는 반복되는 기본적인 리액트 로직의 코드 중복을 방지하고자 `input` 을 받는 로직 등 편의성을 위해 만든 `custom hook` 들이 들어있는 디렉토리이다. 아래의 예시와 같다.\n\n```js\nconst useInput = (initialValue = null) => {\n  const [value, setValue] = useState(initialValue);\n  const handler = useCallback((e) => {\n    setValue(e.target.value);\n  }, []);\n  const reset = useCallback(() => {\n    setValue('');\n  }, []);\n  return [value, handler, reset, setValue];\n};\n\nexport default useInput;\n```\n\n#### - apis -\n\n![](.index_images/05e4edf4.png)\n\n큰 기능별로 분류해놓은 `api` 주소이다. 이후에 설명할 `react-query` 문을 따라 결국에 최종적으로 `request`를 보내고 `response`를 받는 파일들이 모여있다.\n단순 요청과 응답 이외에도 `pagination handling` 등 많은 일들이 일어난다.\n\n#### - queries  -\n\n![](.index_images/15c33b90.png)\n\n위에서 다뤘던 `apis` 디렉토리이는 정말 최종적인 `req` & `res` 다루는 종단점일뿐, 실제 `Sellon` 에서의 실질적인 요청과 응답은 `queries`에서 이루어진다.\n`react-query` 를 지속적으로 사용하였으며, 정말 복잡하고 많은 파일들이 있지만, 간단한 경매를 가져오는 쿼리를 예시로 들어보자\n\n```js\nconst useAuctionsQuery = (\n  sort,\n  pageNum,\n  cat,\n  filterKeyword,\n  dealingType,\n  showAll\n) => {\n  return useQuery(\n    ['auctionList', sort, pageNum, cat, filterKeyword, dealingType, showAll],\n    () =>\n      auctionRelatedAPI.getAuctionLists(\n        sort,\n        pageNum,\n        cat,\n        filterKeyword,\n        dealingType,\n        showAll\n      ),\n    {\n      onError: (res) => {\n        toast.dismiss();\n        toast.error(errorMsgHandler(res));\n      },\n    }\n  );\n};\n\nexport default useAuctionsQuery;\n```\n\n위와같이 여러 요소들을 `parameter` 로 받아 지정된 `api address` 로 요청을 보내고 `response` 를 실제 해당 쿼리를 호출한 `component`에 전달한다.\n\n#### - states - \n\n![](.index_images/71fab26f.png)\n\n`states` 는 `client 상태` 를 다루는 디렉토리이며 주로 `recoil`을 사용하였으며, `user` 정보를 다루는데 주로 사용하였다.\n\n\n--- \n\n### 2. 그래서 왜 Recoil? 왜 React-query?\n\n![](.index_images/4c87440b.png)\n\n프로젝트를 시작하기전 최우선적으로 고려할 사항들이 있었다. \n\n- 생각보다 기획단계에서의 `product volume` 에 비해 시간이 부족하였다.\n- 대부분이 `react`를 처음으로 사용하는 인원들로 팀이 구성되어 있었다. \n\n이에 따라 나는 `boiler-plate` 도 너무 방대하고 러닝커브가 존재하는 `redux` 를 과감히 배제하기로 초반에 결정하였다. 그렇다면 이후의 선택지가 기본 `react` 에\n내장되어있는 상태관리를 용이하게 해주는 기능인 `Context api` 와 개인적으로 초반에 배우기 쉽다고 생각하는 상태관리 `third-party-library` 인 `zustand` 가 머릿속에 \n떠올랐으나, 과연 관리해야할 상태가 많다고 판단되는 프로젝트에서 과연 이런식으로 땜빵(?) 하는게 맞나 생각이 들었다.\n\n이후 몇달전에 `우아한 세미나` 에서 봤던 간단한 `상태관리 library + react-query` 의 조합이 머릿속에서 떠올랐다. 당시에는 잘 이해도 안가고 관심도 딱히 없었으나 그래도 혹시몰라 \n공식문서를 뒤져보며 효율성을 따져보기 시작하였다. 처음 `react-query` 공식문서를 쭉 읽어보았을때 왜 사람들이 `react-query` 는 `server state management` 에 특화된 라이브러리라고\n말했는지 이해가 가기 시작했다. 그중에 `읽기(R)` 를 담당하는 `useQuery` 와 `생성(C), 수정(U), 삭제(D)` 를 담당하는 `mutation` 이 나누어져있기에 굉장히 직관적이며 잘 만들어져있다고 생각이 들었다.\n또한, `response` 에 대한 `handling` 도 가능하고 한번 `fetching` 한 데이터에 대해서는 `refetching process` 없이 해당 데이터를 다시 사용 할 수도 있고, `카테고리 불러오기` 같이 \n주지적인 데이터의 변화가 없는 상황에 대해 `staleTime` 을 사용하여 얼마동안 한번 받아온 데이터(`fresh`) 를 `refetching` 없이 유지할 수 있다는 점이 매력적이였다.\n\n`react-query` 를 채택하고 실제 사용한 이유요소는 추가적으로 많지만, 이는 다른 글에서 깊게 다뤄보기로 하고, 서버에서 받아오는 데이터는 `react-query` 를 사용하면 되지만, 실제 `client state`, 예를들어\n`사용자 정보`, `lightMode/darkMode` 과 같은 상태를 관리할 수단이 필요했다. 여기서도 `Context-api` 를 떠올렸지만, 처음 `react` 를 사용하는 팀원들이 실질적으로 사용하기에는 \n내가 `boiler-plate` 와 `상태 저장` 에 대한 로직만 내가 짜놓은 후 사용하는 방식만 가르쳐준다면 오히려 `recoil` 이 사용하기 편하다고 생각하여 `client-state` 를 `react-query` 로 관리하고, \n`server-state` 를 `react-query`로 관리하기로 최종 결정하였다.\n\n---\n\n### 3. 프로젝트 이후 다시 코드를 보다\n\n정신없이 해커톤을 마무리한 후 이틀정도를 쉰 후 다시 책상에 앉아 코드를 까보았다. 당시에 느낀점은 생각보다 코드를 더럽게 짰다, 그리고 생각보다 화면 렌더링 시간이 오래걸린다 \n였다. 첫번째 이슈는 즉시 해결이 가능했지만, 렌더링 시간은 분석이 필요한 상황이였다.\n\n--- \n\n### 4. 처참한 Lighthouse 결과 \n\n무엇이 문제였을까? 라는 생각을 하며 혹시모를 기대감에 `Lighthouse` 로 우리의 product 를 측정해 보았다.\n\n하지만 아래의 사진과 같이 정말 처참한 결과값을 확인할 수 있었다. 내 자신에 대해 매우 큰 실망을 하였고 지금이라도 코드를 갈아엎는 한이 있더라고 무조건적으로 성능 개선을 하고 \n싶다는 생각이 들었다.\n\n![](.index_images/15167e80.png)\n\n우리 서비스의 특성상 매우 많은 사진들이 등록되고 보여주게 된다. 이 과정에서 유저가 사진을 올릴때 사이즈를 조정할 수 있는 별도의 툴을 제공하지 않았고, 사진을 받아 DB 에 바로 저장 후 \n해당 사진에 대한 `imgUrl` 받았을 때 어떻게든 우리의 박스에 우겨넣곤 하였다. 이로인해, 투머치할 정도로 사진들의 사이즈가 너무 컸고, 이로인해 퍼포먼스 저하에 직접적인 제일 큰 요인이 되었다.\n\n![](.index_images/57eb225b.png)\n\n![](.index_images/9a3caf3d.png)\n\n실제로 하나의 이미지를 예로 들어보자면 맥북 기준 보여주어야 할 image content 의 사이즈는 `226 x 168` 이지만, 실제 사이즈의 사진의 크기는 `569 x 832` 였다.\n\n![](.index_images/98e8ee70.png)\n\n만약 보여주어야 하는 이미지의 박스 크기가 120x120 이라면, 그에 상응하는 이미지 사이즈를 렌더링하는 것이 효과적이나, 레티나 디스플레이의 등장으로 인해 2배인 240x240 정도를 가져오는 것으로 \n자리잡는 추세이다. 현재 우리의 서비스는 `server` 로부터 `image url` 을 받아 렌더링 하고 있으며, 대회가 끝난 상황에서 백앤드 팀원들과 다시 전체적 프로젝트 리팩토링을 하기에는 \n무리가 있다 판단되어 내가 방법을 찾아보기로 하였다.\n\n--- \n\n5. 이틀간의 시도\n\n![](.index_images/86a6cf05.png)\n\n이틀간 굉장히 많이 구글링을 하고 방안을 모색해보았다, `imgix` 라는 `img cdn` 을 사용하는 방안에 제일 시간을 많이 쏟았다. `imgix` 는 `imgUrl` 을 전송 후 내가 지정한 \n사이즈를 가진 `img` 를 받을 수 있는 서비스라고 이해했지만, 아무리 이를 사용하여 시도를 해보아도, 왜인지는 모르겠지만 결국 `img size` 는 최적화 하는데 실패하였다.\n\n시도해본 다른 방안은 `jpg` 나 `png` format 으로 으로 이루어진 사진을 `webp` 로 전환하여 렌더링 해준다는 라이브러리를 찾아 이를 적용해 보았지만, 결국 에러만 잔뜩 날뿐, \n실제 효과를 보지 못하였다.\n\n결국 `imgix` 를 다시 사용하는 방식으로 시도해 보았지만, 도중에 과연 기업들은 어떻게 할까? 에 대해 찾아보기 시작하였다. 찾은 답변들의 공통점은 `imgix` 처럼 사이즈를 변환하는\n자체적인 루트를 만들거나 애초에 `img` 를 저장하는 방식에서 `thumbnail` 에 대한 `resizing` 이 들어간 가벼운 사진을 `db` 에 별도로 저장한다는 점이였다. 또한 \n`webp` 에 대한 사용성도 이전보다 많이 늘어난 추세였으며 이를 적절하게 사용한다면 렌더링 속도도 매우매우 늘어날 것이라는 예측도 하게 되었다. 그리하여 나는 현재 상황에서\n이를 해결하기에 어려움이 많다고 생각하여 접어두게 되었다.\n\n해당 문제는 아쉽게 해결하지 못하였지만, 이후 프로젝트를 또 진행한다면 무작정 이러한 서비스를 만들것이고 빨리 개발을 해야해 라는 마음가짐보다는 실제 `최적화` 에 대한 요소를 \n무조건적으로 고려하며 개발을 진행해야한다는 사실을 뼈져리게 느꼈다.\n\n\n---\n\n## 결론\n\n좋은 팀원들을 만나 나름 웃으면서 재밌게 개발을 할 수 있었고, 배운점도 많았기에 만족할 수 있었던 프로젝트였다. 이후 꼭 최적화를 계속 생각하며 개발을 해야한다는 교훈을 \n뼈져리게 느끼기도 하였고 branch 전략을 세워 개발 중간중간 PR code review 를 진행하며 나름 협업에 대한 개념도 어느정도 머릿속에 들어온 것 같다. 다음 글에서는 \n내가 `react-query` 에서 주목한 핵심 개념은 무엇이었으며, 나는 어떻게 사용했는가에 대해 글을 적을 예정이다.\n\n\n\n\n"},{"excerpt":"서론  이란 개발을 할때 매일매일 사용하고 무조건적으로 이해해야 하는 개념이라 생각한다. JavaScript 에서는 데이터 타입을  나눈다. 하나는  이고, 다른 하나는  타입이다.\n본고에서는 이 둘의 차이점에 대해 다룰 예정이다. 본론 자바스크립트의 원시(primitive)타입. 자바스크립트의 원시타입으로는 , , , , ,  와  총 7 개가 존재한다…","fields":{"slug":"/js-primitive-reference-types/"},"frontmatter":{"date":"June 01, 2022","title":"자바스크립트 원시(primitive)타입 vs 참조(reference)타입","tags":["JavaScript"]},"rawMarkdownBody":"\n## 서론\n\n<iframe src=\"https://giphy.com/embed/f16wgrNYaKkBcvOu5r\" width=\"480\" height=\"270\" frameBorder=\"0\" class=\"giphy-embed\" allowFullScreen></iframe><p><a href=\"https://giphy.com/gifs/harlem-f16wgrNYaKkBcvOu5r\"></a></p>\n\n`데이터 타입(data type)` 이란 개발을 할때 매일매일 사용하고 무조건적으로 이해해야 하는 개념이라 생각한다.\n\nJavaScript 에서는 데이터 타입을 `두개로` 나눈다. 하나는 `원시(primitive)타입` 이고, 다른 하나는 `참조(reference)` 타입이다.\n본고에서는 이 둘의 차이점에 대해 다룰 예정이다.\n\n---\n\n## 본론\n\n### 자바스크립트의 원시(primitive)타입.\n\n자바스크립트의 원시타입으로는 `number`, `bigint`, `string`, `boolean`, `null`, `undefined` 와 `symbol` 총 7 개가 존재한다.\n이들의 공통점은은 `object` 가 아니며, 따로 `메서드(method)` 를 가지지 않는다.\n\n![](.index_images/c565307f.png)\n\n\n하지만 여기서,\n\n> 자바스크립트의 \"string 타입\" 은 메서드를 가지는데? 그러면 원시타입이 될수 없지 않은가?\n\n라는 생각이 들수 있다.\n\n이는 자바스크립트의 런타임이 아래와 같은 코드를\n```js\n\"tmp\".concat();\n```\n\n`String` 오브젝트로 생성하기에 메서드를 가질수 있다.\n\n```js\nconst str = new String('tmp');\n```\n\n### 원시타입은 어떻게 작동하는가?\n\n자바스크립트에서 원시타입을 `선언(declare)` 하면, 이는 `스택(stack)` 에 저장된다. 스택이란 `LIFO(Last In First Out)` 구조를 가진 `자료구조(data structure)` 이다. \n저장된 원시타입은 `식별자`를 통해 접근할 수 있고, 원시 데이터와 함께 스택에 저장된다.\n\n```js\nconst numOne = 50;\nconst numTwo = 50;\n```\n\n위와 같이 같은 값을 가진 두개의 변수가 선언 및 할당되었을 때, `numOne` 이 값과 함께 스택에 푸쉬되고, 그 위에 `numTwo` 가 값과 함께 스택에 푸쉬된다.\n같은 값이 있건 말건 전혀 상관없는 두개의 공간이 생성된다.\n\n![](.index_images/816339ff.png)\n\n이때 `numOne` 의 값을 변경한다해도 `numTwo` 에는 전혀 지장이 없다.\n\n```js\nlet numOne = 50;\nlet numTwo = numOne;\nnumOne = 100;\nconsole.log(numOne); // 100\nconsole.log(numTwo); // 50\n```\n\n![](.index_images/370b640b.png)\n\n### 자바스크립트의 참조(reference)타입.\n\n자바스크립트의 참조타입 데이터는 원시타입과 다르게 `동적이다(dynamic)`. 다르게 생각하자면 고정된 크기를 가지지 않는다.\n\n대부분은 `객체(object)` 로 치환되며, 그렇기에 `메서드(method)`를 가진다. 예시로는 `array`, `function`, `object`, `date`, 등 많은 참조 타입 데이터가 있다.\n\n### 원시타입과 객체타입의 차이\n\n차이점은 참조타입 데이터를 저장해야할 때 생긴다. 변수를 선언 후 참조타입의 데이터를 할당하려 할때, 값은 해당 변수에 직접적으로 할당되지 않는다.\n해당 변수에 저장되는 값은 `메모리에 저장되어 있는 참조타입 값의 주소`이다.\n\n![](.index_images/7f90516f.png)\n\n위의 사진을 보면, 두개의 자료구조가 있다. `스택(stack)`과 `힙(heap)`이다. 객체를 선언 및 할당했다고 가정했을 때, 해당 객체는 힙에 저장된다.\n그리고 이의 `포인터`는 스택에 저장된다. `포인터`란 해당 객체의 메모리 주소 값을 가리키는 변수이다.\n\n```js\nconst object1 = {\nname: 'hwani',\nage: 25\n};\nconst object2 = object1;\n\n// object1 업데이트,\nobject1.age = 40;\n\nconsole.log(object2.age); // 40 \n```\n\n`object1` 이란 변수를 선언하였고, 객체를 할당하였다. 이후에 아까 원시타입과 같이 `object2` 를 선언 후 `object1` 를 이에 할당하였다.\n그렇다면 힙에 새로운 객체가 생성될까? 답은 생기지 `않는다`.\n\n해당 객체가 이미 힙에 존재하는한, `object1` 과 `object2` 는 같은 객체를 가리킨다.\n\n다른 차이점은 `object1` 의 프로퍼티를 업데이트 할때 볼 수 있다. 위의 코드와 같이 콘솔을 찍어보면 object2 의 프로퍼티또한 변경된 사실을 확인할 수 있다.\n이는 object1 과 object2 가 힙에 있는 같은 객체를 가리키고 있기에, 서로 영향을 주기 때문이다.\n\n![](.index_images/e42af7e2.png)\n\n---\n\n## 결론\n\n참조 타입은 서로에게 영향을 줄 수 있으므로, 최대한 이를 상기하며 코드를 짜는것이 중요하다 생각한다.\n\n\n\n"},{"excerpt":"서론 Node.js 를 사용해  와 같은 알고리즘을 공부하거나 일반적인  메서드를 사용할때도 종종 두 원소를 \n비교하여 조건문이  라면 순서를 바꿔야 (swap) 하는 상황이 종종 생긴다.  두 원소의  바꾸는 행위를  이라 부르는데, 스와핑은 언어에 따라, 성능에 따라, 또한 개개인의 편의 및 선호도에 따라 적용할 수 있는 많은 방법이 있다. 본고에서는…","fields":{"slug":"/js-array-element-swap/"},"frontmatter":{"date":"May 16, 2022","title":"자바스크립트 배열 원소 swap","tags":["JavaScript"]},"rawMarkdownBody":"\n## 서론\n\n<iframe src=\"https://giphy.com/embed/xUA7b0Klw8Wfor7FWo\" width=\"480\" height=\"360\" frameBorder=\"0\" class=\"giphy-embed\" allowFullScreen></iframe><p><a href=\"https://giphy.com/gifs/loop-play-colors-xUA7b0Klw8Wfor7FWo\"></a></p>\n\nNode.js 를 사용해 `버블 소트(bubble sort)` 와 같은 알고리즘을 공부하거나 일반적인 `.sort()` 메서드를 사용할때도 종종 두 원소를 \n비교하여 조건문이 `참(true)` 라면 순서를 바꿔야 (swap) 하는 상황이 종종 생긴다.\n\n![](.index_images/8fda202c.png)\n\n두 원소의 `순서를(index)` 바꾸는 행위를 `스와핑(swapping)` 이라 부르는데, 스와핑은 언어에 따라, 성능에 따라, 또한 개개인의 편의 및 선호도에 따라 적용할 수 있는 많은 방법이 있다.\n\n본고에서는 JavaScript 에서 스와핑을 할 수 있는 3가지의 방법인 `임시 변수 활용(using temporary virable)`, `구조 분해(desctructuring) 활용`, `splice() 메서드 활용` 을 다룰것이다.\n\n---\n\n## 본론\n\n### 1. 임시 변수 활용(using temporary variable)\n\n임시 변수를 활용하여 원소의 순서를 바꿀 때, 세가지의 스텝만 기억하면 된다.\n\n- 첫번째 스텝은 스와핑할 첫번째 원소를 담을 임시 변수를 `선언(declaration)` 후 `할당(assignment)` 하고,\n- 두번째 스텝으로는 첫번째 원소의 공간에 두번째 원소의 값을 `재할당(reassignment)` 해준다. \n- 마지막 스텝으로는 기존 배열의 첫번째 원소 값을 담고 있던 임시 변수를 배열의 두번째 인덱스에 `재할당` 해주면 비로소 스와핑이 이루어진다.\n\n```js\nconst myArray = [1, 3, 5, 7, 10];\n\nconst tmpVar = myArray[0];\nmyArray[0] = myArray[1];\nmyArray[1] = tmpVar;\n\nconsole.log(myArray); // [3, 1, 5, 7, 10]\n```\n\n위와 같은 방법으로도 가능하지만 위의 로직을 `함수(functionalizaiton)` 시켜 `재사용성(reusability)` 을 크게 향상시킬 수 있다.\n\n```js\nconst elSwapFunc = (arr, idx1, idx2) => {\n  const tmp = arr[idx1];\n  arr[idx1] = arr[idx2];\n  arr[idx2] = tmp;\n};\n\nconst myArr = [1, 2, 3, 4, 5];\nelSwapFunc(myArr, 0, 1);\nconsole.log(myArr); // [2, 1, 3, 4, 5]\n```\n\n얼핏보면 아무값도 리턴하지 않고 함수 내부에서 스와핑이 이루어지기에 이게 가능한가..? 라는 생각을 할 수 있지만,\nJavaScript 의 특성상 인자를 통해 함수에 배열을 전달할 때 값이 아닌 `실제 메모리 주소` 를 전달하기에 원본 배열이 변경된다 `(side effect)` .  \n\n\n### 2. 구조 분해(desctructuring) 활용\n\n구조 분해를 활용하여 스와핑을 진행할 수 있다면 위에 기술한 방법보다 더욱 간단히 한줄만을 사용하여 표현할 수 있다.\n\n단순하게 순서에 맞게 새로운 배열을 만들고, 반대의 순서를 가진 새로운 배열을 할당하면 된다.\n\n```js\nconst myArray = [1, 2, 3, 4];\n\n[myArray[1], myArray[0]] = [myArray[0], myArray[1]];\n\nconsole.log(myArray); // [2, 1, 3, 4]\n```\n\n위의 로직 또한 함수화를 통해 재사용성을 높일 수 있다.\n\n```js\nconst swapElFunc = (array, index1, index2) => {\n  [array[index1], array[index2]] = [array[index2], array[index1]];\n};\n\nconst myArray = [1, 2, 3, 4, 5];\nswapElFunc(myArray, 0, 1);\nconsole.log(myArray); // [2, 1, 3, 4, 5]\n```\n\n### 3. `.splice()` 메서드 활용\n\n`Array.prototype.splice()` 메서드는 mdn 공식문서에 따르면 아래와 같이 나온다.\n\n> The splice() method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place. To access part of an array without modifying it, see slice().\n> - MDN\n\n해석하자면 `splice()` 메서드는 배열의 내부 원소를 제거하거나 대체하거나 원소를 추가할때 쓰인다.\n원본 배열을 훼손하지 않고 배열의 일정 부분에 접근하려면 `slice()` 메서드를 사용하라고 말한다.\n활용법은 이해하기 쉽지만 주요한 점은 `splice()` 메서드는 원본 배열을 변경/회손 한다. 즉, `불변성(immutability)`을 지키주지 않는다.\n\n기본적인 문법은 아래와 같다.\n\n```js\narray.splice(index, howmany, element1, ....., elementX)\n// (영향을 줄 start 인덱스, 몇개의 인덱스(삭제), 추가 할 인덱스)\n```\n\n하나의 원소를 제거 && 대체 해야한다면 아래와 같이 사용할 수 있다.\n\n```js\nconst myArray = [12, -2, 55, 68, 80];\n\n// 제거 \nmyArray.splice(1, 1);\nconsole.log(myArray); // 12,55,68,80]\n\n// 대체\nmyArray.splice(1, 1, 444);\nconsole.log(myArray); // 12,444,68,80]\n```\n\n본론으로 돌아가 `splice()` 를 이용한 스와핑은 아래와 같이 진행할 수 있다.\n\n```js\nconst myArray = [12, -2, 55, 68, 80];\n\nmyArray[0] = myArray.splice(1, 1, myArray[0])[0];\n\nconsole.log(myArray); // [-2,12,55,68,80]\n```\n\n함수화를 하면 아래와 같다.\n\n```js\nconst swapElements = (array, index1, index2) => {\n    myArray[index1] = myArray.splice(index2, 1, myArray[index1])[0];\n};\n\nconst myArray = [12, -2, 55, 68, 80];\nswapElements(myArray, 0, 1);\nconsole.log(myArray); // [-2,12,55,68,80]\n```\n\n---\n\n## 결론\n\nJavaScript 에서 스와핑을 할수 있는 많은 방법이 있지만, \nES6 구조분해를 사용하는 방법이 난의도상으로도, 가독성면으로도 나에게는 제일 잘 맞는다고 생각한다.\n\n\n\n"},{"excerpt":"서론 항상 나는 리액트라는 를 올바르게 사용하고 있는지에 대한 고민이 있다.\n망치를 가지고 있다고 가정하였을때 망치 손잡이를 잡을지 아니면 망치 머리 가까이에 손을 위치할지 결정할 수 있다. \n망치 제작자들은 방법을 하지 않지만, 더  방법은 존재하리라 믿는다. 이는 리액트에도 해당되지 않을까 싶다.  본고에서는 단순히 리액트를 사용한다는 관점을 넘어서 …","fields":{"slug":"/react-4-anti-patterns/"},"frontmatter":{"date":"May 01, 2022","title":"리액트에서 피해야할 안티패턴","tags":["React","패턴"]},"rawMarkdownBody":"\n## 서론\n\n항상 나는 리액트라는 `도구`를 올바르게 사용하고 있는지에 대한 고민이 있다.\n망치를 가지고 있다고 가정하였을때 망치 손잡이를 잡을지 아니면 망치 머리 가까이에 손을 위치할지 결정할 수 있다. \n망치 제작자들은 방법을 `명시`하지 않지만, 더 `효율적인` 방법은 존재하리라 믿는다. 이는 리액트에도 해당되지 않을까 싶다.\n\n![](.index_images/647cf611.png)\n\n본고에서는 단순히 리액트를 사용한다는 관점을 넘어서 어떻게 더 `효율적으로` 리액트를 사용하기 위하여 피해야하는 세가지의 `안티패턴` 에 대하여 다룰 것이다.\n\n![](.index_images/69fdc17c.png)\n\n\n---\n\n## 본론\n\n### 1. 단일 컴포넌트 내부의 거대한 트리 구조 지양\n\n리액트를 처음 시작했을 때 흔히 `구조`와 `구조 정리` 등 많은 부분을 고려하지 않고 로직에 따라 `하나의` 거대한 컴포넌트를 생성 후 내부에 수많은 조건과 로직이 담겨있는 `복잡한` 코드를 짜게 될 수 있다.\n\n![](.index_images/abb52135.png)\n\n척보기에도 보기 거북한? 코드임을 느낄 수 있다. 위 코드에 대하여 몇가지의 개선점을 제시할 수 있다.\n\n- `컴포넌트 트리` 내부 긴 조건문을 따로 `변수`를 사용하는 방식으로 `리팩토링`한다.\n- 트리의 각각의 조각들을 작은 `컴포넌트`로 `분리`한다.\n- 이벤트에 매핑할 `함수` 를 컴포넌트 트리로부터 `분리`한다.\n\n위 사항들을 적용한 개선 코드는 아래와 같다.\n\n![](.index_images/ad8f2640.png)\n\n> 핵심: 컴포넌트 트리의 가독성을 가능한 최대한 향상시켜 해당 컴포넌트가 정확히 무엇을 하는지, 무엇을 렌더링하는지, 언제 하는지에 대해 파악을 쉽게 해야한다.\n\n### 2. 글로벌 스코프 단위의 Context 지양\n\n많은 상황에서 `상태(state)`와 `컨텍스트(context)` 의 경계가 모호해지는 경우가 많다. 하지만 엄연히 이 둘은 다르며 컨텍스트를 `전체 상태관리(global state management)` 용도로 사용하는 구조를 지양해야한다.\n\n> 컨텍스트(context)는 관계있는 컴포넌트간 prop 을 공유할 수 있게 해주고, 프롭 드릴다운 이펙트(prop drill down effect) 에 대한 방어수단으로 사용할 수 있다.\n\n![](.index_images/72c53bbb.png)\n\n실제 리액트 공식문서에서도 컨텍스트의 주된 용도는 다양한 레벨에 네스팅된 컴포넌트들에게 데이터를 전달하는 것이며, 컨텍스트를 사용하면 컴포넌트를 재사용하기 `어려워지므로` 꼭 필요할 때만 쓰라고 명시가 되어있다.\n\n많은 레퍼런스를 찾아본 결과, 글로벌 상태(global state)는 전체 application의 상태들을 관리하기 위해 존재하지만, 전체 상태 관리를 위해 `context provider` 를 통해 전체 application 을 래핑(wrap)하는 구조는 피해야 한다고 하였다.\n\n> 핵심: `전역`으로 상태관리를 해야하는 상황이라면 리덕스(redux), 리코일(recoil)과 같은 3rd party library 를 사용하고, Context API는 경계가 확실한 aplication 에서 각각의 파트에서 범위를 좁혀 사용하여야 한다.  \n\n### 3. 컴포넌트 트리 내에서 `.map()` 의 `키(key)`를 변수 `인덱스(index)` 를 사용하는 렌더링 지양\n\n몇몇 개발자들의 코드를 보면 아래와 같이 `.map()` 을 사용할 때 키 값으로 단순히 요소의 `index` 를 사용하는 경우가 있다. \n\n```js\nfunction ListOfUsers() {\n    const users = ['Pete', 'Jhon', 'Sarah'];\n    return (\n        <ul>\n            {users.map(function(name, index){\n                return <li key={ index }>{name}</li>;\n              })}\n        </ul>\n    )\n}\n```\n\n#### 과연 괜찮은 방법일까...? 아니라고 생각한다.\n\n이유는 보통 컴포넌트 트리 내에서 `.map()` 을 사용할 때, 항상 `불변`의 `간단한` 배열만 사용한다는 보장이 없기 때문이다.\n리액트는 각 요소에 유니크(unique)한 key 값을 부여해 해당 요소가 추가되거나, 변경되거나 삭제되는 상황을 `식별`한다.\n\n예시로 위와 같은 코드 형식에서 리스트에 `첫번째` 인덱스에 요소를 추가한다면 리액트는 예측되지 못한 행동으로 인식하여 매우 혼란스러워 한다. \n가능한 엘리먼트의 index 값보다는 실제 고유의 값을 사용하는 것이 바람직하다.\n\n---\n\n## 결론\n\n리액트는 하나의 문제를 해결할때도 많은 방식을 허용하기에 매력적이지만, 높은 퍼포먼스를 가진 application 을 만들기 위해서는 `안티패턴`을 최대한 피해야한다.  \n\n\n\n\n"},{"excerpt":"서론  는 먼저 온 소비자가 먼저 서비스를 받는 리소스에 대한 소비자 대기열이라 이해하면 편하다.  는 \n의 특징을 가지고 있다.  본론 Queue with normal array 예시 Queue with Linked List 예시","fields":{"slug":"/js-queue/"},"frontmatter":{"date":"April 20, 2022","title":"Queue with JS","tags":["JavaScript","Algo Concepts"]},"rawMarkdownBody":"\n## 서론\n\n`Queue` 는 먼저 온 소비자가 먼저 서비스를 받는 리소스에 대한 소비자 대기열이라 이해하면 편하다. `Queue` 는 `FIFO(선입선출) - First In First Out`\n의 특징을 가지고 있다.\n\n![](.index_images/8ffa4d03.png)\n\n---\n\n## 본론\n\n\n### Queue with normal array 예시\n\n```js\nclass Queue {\n  constructor() {\n    this.queue = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n\n  enqueue(val) {\n    this.queue[this.rear] = val;\n    this.rear++;\n  }\n\n  dequeue() {\n    const val = this.queue[this.front];\n    delete this.queue[this.front];\n    this.front++;\n    console.log(this.queue);\n    return val;\n  }\n\n  peek() {\n    return this.queue[this.front];\n  }\n\n  size() {\n    return this.rear - this.front;\n  }\n\n  getStr() {\n    let str = \"[\";\n    for (let i = this.front; i < this.rear; i++) {\n      str += `${this.queue[i]}, `;\n    }\n    str = str.substr(0, str.length - 2);\n    console.log(str + \"]\");\n  }\n}\n\nconst queue = new Queue();\nqueue.enqueue(1);\nqueue.enqueue(2);\nqueue.enqueue(5);\nqueue.dequeue();\nconsole.log(queue.size()); // 2\nqueue.getStr(); // [2, 5]\n\n```\n\n### Queue with Linked List 예시\n\n```js\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\nclass Queue {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.size = 0;\n  }\n\n  enqueue(val) {\n    const newNode = new Node(val);\n    if (this.head === null) {\n      this.head = this.tail = newNode;\n    } else {\n      this.tail.next = newNode;\n      this.tail = newNode;\n    }\n    this.size++;\n  }\n\n  dequeue() {\n    const val = this.head.val;\n    this.head = this.head.next;\n    this.size--;\n    return val;\n  }\n\n  peek() {\n    return this.head.val;\n  }\n\n  getStr() {\n    let str = \"[\";\n    let currentNode = this.head;\n    while (currentNode) {\n      str += `${currentNode.val} ,`;\n      currentNode = currentNode.next;\n    }\n    str = str.substr(0, str.length - 2);\n    console.log(str + \"]\");\n  }\n}\n\nconst queue = new Queue();\nqueue.enqueue(1);\nqueue.enqueue(2);\nqueue.enqueue(3);\nqueue.dequeue();\nqueue.getStr(); // [2, 3]\n\n```\n\n\n\n---\n\n\n\n\n"},{"excerpt":"서론 거의 모든 응용 프로그램에 존재하는  기능의 작동원리나 웹 브라우저에서의  버튼의 작동원리를 추적한다면, 스택이 사용되었을 것이라 짐작한다.\n은 작업의 이정상태를 메모리에 저장하여 마지막 상태가 먼저 나타나게 한다. 본론 Stack 의 특징 및 사용 메서드 스택은 기본적으로  원리를 따르며 기본적으로 아래의 세 가지의 메서드를 사용한다. Push: …","fields":{"slug":"/js-stack/"},"frontmatter":{"date":"April 15, 2022","title":"Stack with JS","tags":["JavaScript","Algo Concepts"]},"rawMarkdownBody":"\n## 서론\n\n거의 모든 응용 프로그램에 존재하는 `되돌리기` 기능의 작동원리나 웹 브라우저에서의 `뒤로가기` 버튼의 작동원리를 추적한다면, 스택이 사용되었을 것이라 짐작한다.\n`스택`은 작업의 이정상태를 메모리에 저장하여 마지막 상태가 먼저 나타나게 한다.\n\n---\n\n## 본론\n\n### Stack 의 특징 및 사용 메서드\n\n스택은 기본적으로 `LIFO(후입선출) - Last In First Out` 원리를 따르며 기본적으로 아래의 세 가지의 메서드를 사용한다.\n\n- Push: 스택에 요소 추가\n- Pop: 스택에서 요소 제거\n- Peek: 스택의 최상위 요소 가져오기\n\n![](.index_images/78259008.png)\n\n### Stack with normal array 예시\n\n```js\nconst stack = [];\n\n// Push\nstack.push(1);\nstack.push(2);\nstack.push(3);\nconsole.log(stack); // [1, 2, 3]\n\n// Pop\nstack.pop();\nconsole.log(stack); // [1, 2]\n\n// Peek\nconsole.log(stack[stack.length - 1]); // 2\n\n```\n\n### Stack with Linked-List 예시\n\n```js\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\nclass Stack {\n  constructor() {\n    this.top = null;\n    this.size = 0;\n  }\n\n  push(val) {\n    const node = new Node(val);\n    node.next = this.top;\n    this.top = node;\n    this.size++;\n  }\n\n  pop() {\n    const val = this.top.val;\n    this.top = this.top.next;\n    this.size--;\n    return val;\n  }\n\n  peek() {\n    return this.top.val;\n  }\n\n  getSize() {\n    return this.size;\n  }\n}\n\nconst stack = new Stack();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nconsole.log(stack.pop()); // 3\nstack.push(4);\nconsole.log(stack.pop()); // 4\nconsole.log(stack.pop()); // 2\n\n```\n\n\n\n---\n\n\n\n\n"},{"excerpt":"서론 란 과 유사한 선형 데이터 구조이다. 하지만 대표적인 차이로는 배열과 달리 요소가 특정 메모리 위치나 인덱스에 저장되지 않는다.\n각 요소는 해당 List 의 다음 객체에 대한 포인터 또는 링크를 포함하는 별도의 객체이다.  각 에는 저장된 와 다음 노드에 대한 라는 두 가지의 항목이 포함된다. \n연결 리스트의 진입점을 라고 부르고, 헤드는 연결 목록…","fields":{"slug":"/js-linked-list/"},"frontmatter":{"date":"April 11, 2022","title":"Linked-list with JS","tags":["JavaScript","Algo Concepts"]},"rawMarkdownBody":"\n## 서론\n\n`Liked List`란 `배열`과 유사한 선형 데이터 구조이다. 하지만 대표적인 차이로는 배열과 달리 요소가 특정 메모리 위치나 인덱스에 저장되지 않는다.\n각 요소는 해당 List 의 다음 객체에 대한 포인터 또는 링크를 포함하는 별도의 객체이다.\n\n![](.index_images/625d3f29.png)\n\n각 `요소(Node)`에는 저장된 `데이터`와 다음 노드에 대한 `링크`라는 두 가지의 항목이 포함된다. \n연결 리스트의 진입점을 `헤드(head)`라고 부르고, 헤드는 연결 목록의 첫 번째 노드에 대한 참조이다. 목록의 마지막 노드는 null 을 가리키며, 리스트가 비어있다면,\n헤드는 null 을 참조한다. \n\n보통 메모리를 `연속적으로` 저장하는 배열의 특징으로 인해 배열은 n번째 원소를 접근할 때 바로 접근 할 수 있지만, 메모리 사용이 비효율적이며 배열 내의 잦은 \n데이터 추가 및 갓제의 시간복잡도가 O(n)이라는 단점이 존재한다. 반대로 이 글에서 다룰 `linked-list (연결리스트)` 는 메모리를 효울적으로 사용할 수 있고,\n삽입, 삭제를 효율적으로 할 수 있다.\n\n![](.index_images/cf907146.png)\n\n---\n\n## 본론\n\n### Linked List 의 장점\n\n- `Linked List` 는 일반적인 `Array` 와 달리 전체 데이터 구조를 재구성 하지 않고도 연결 목록에서 노드를 쉽게 제거하거나 추가할 수 있다.\n\n### Linked List 의 단점\n\n- `Linked List` 에서는 `탐색` 작업이 일반 배열에 비교해 느리다. 또한, 임의 액세스는 허용되지 않으며, 노드는 첫 번째 노드부터 순차적으로 접근할 수 있다.\n- 포인터의 저장으로 인해 배열보다 더 많은 메모리를 사용한다.\n\n### Linked List 의 유형\n\n- Singly Linked List (단일 연결 리스트): 각 노드에는 다음 노드에 대한 포인터 하나만 포함된다. \n- Doubly Linked List (이중 연결 리스트): 각 노드에는 다음 노드에 대한 포인터와 이전 노드에 대한 포인터 두 개의 포인터가 포함된다.\n- Circular Linked List (순환 연결 리스트): 순환 연결 리스트는 마지막 노드가 첫번째 노드와 그 이전의 다른 노드를 가리키며 루프를 형성하는 연결 리스트의 변형이다.\n\n### Singly Linked List 예시\n\n```js\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass SinglyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  // 값 찾고 해당 Node 반환\n  find(value) {\n    let currNode = this.head;\n    while (currNode.value !== value) {\n      currNode = currNode.next;\n    }\n    return currNode;\n  }\n\n  // 맨 뒤에 Node 생성\n  append(newValue) {\n    const newNode = new Node(newValue);\n    if (this.head === null) {\n      this.head = newNode;\n      this.tail = newNode;\n    } else {\n      this.tail.next = newNode;\n      this.tail = newNode;\n    }\n  }\n\n  // 중간에 Node 끼워넣기\n  insert(node, newValue) {\n    const newNode = new Node(newValue);\n    newNode.next = node.next;\n    node.next = newNode;\n  }\n\n  // Node 삭제\n  remove(value) {\n    let prevNode = this.head;\n    while (prevNode.next.value !== value) {\n      prevNode = prevNode.next;\n    }\n\n    if (prevNode.next) {\n      prevNode.next = prevNode.next.next;\n    }\n  }\n\n  // Linked List 값 보여주기\n  display() {\n    let currNode = this.head;\n    let displayString = \"[\";\n    while (currNode) {\n      displayString += `${currNode.value}, `;\n      currNode = currNode.next;\n    }\n    displayString = displayString.substr(0, displayString.length - 2);\n    displayString += \"]\";\n    console.log(displayString);\n  }\n}\n```\n\n### Doubly Linked List 예시\n\n```js\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\nclass DoublyLinkedList {\n  constructor(value) {\n    this.head = null;\n    this.tail = null;\n    this.size = 0;\n  }\n\n  printList() {\n    const arr = [];\n    let currNode = this.head;\n    while (currNode !== null) {\n      arr.push(currNode.value);\n      currNode = currNode.next;\n    }\n\n    console.log(arr.join(` <--> `));\n    return this;\n  }\n\n  // Insert node at the end of the list\n  append(value) {\n    const newNode = new Node(value);\n\n    if (this.size === 0) {\n      this.head = this.tail = newNode;\n      this.size++;\n      this.printList();\n      return this;\n    }\n\n    this.tail.next = newNode;\n    newNode.prev = this.tail;\n    this.tail = newNode;\n\n    this.size++;\n    this.printList();\n  }\n\n  // Insert node at the start of the list\n  prepend(value) {\n    const newNode = new Node(value);\n\n    if (this.size === 0) {\n      this.head = this.tail = newNode;\n      this.size++;\n      this.printList();\n      return this;\n    }\n\n    newNode.next = this.head;\n    this.head.prev = newNode;\n    this.head = newNode;\n\n    this.size++;\n    this.printList();\n  }\n\n  // find index of specific node in the list with given index\n  getIdxWithVal(value) {\n    let idx = 0;\n    let currNode = this.head;\n    while (currNode !== null && currNode.value !== value) {\n      currNode = currNode.next;\n      idx++;\n    }\n    if (currNode !== null) {\n      return idx;\n    } else {\n      console.log(`Node with given val(${value}) doesn\\'t exist in the list`);\n      throw new Error(\n        `Node with given val(${value}) doesn\\'t exist in the list`\n      );\n    }\n  }\n\n  // Insert node at a given index\n  insert(index, value) {\n    if (!Number.isInteger(value) || index < 0 || index > this.size + 1) {\n      console.log(`Invalid index. Current length is ${this.size}`);\n      throw new Error(`Invalid index. Current length is ${this.size}`);\n    }\n\n    // If idx is 0, prepend\n    if (index === 0) {\n      this.prepend(value);\n      return this;\n    }\n\n    // Reach to the specific index\n    const newNode = new Node(value);\n    let prevNode = this.head;\n\n    for (let i = 0; i < index - 1; i++) {\n      prevNode = this.head.next;\n    }\n\n    const nextNode = prevNode.next;\n\n    newNode.next = nextNode;\n    newNode.prev = prevNode;\n    prevNode.next = newNode;\n    nextNode.prev = newNode;\n\n    this.size++;\n    this.printList();\n  }\n\n  // Remove a Node\n  remove(index) {\n    if (!Number.isInteger(index) || index < 0 || index > this.size) {\n      console.log(\"invalid index\");\n      throw new Error(\"invalid index\");\n    }\n\n    // remove head\n    if (index === 0) {\n      this.head = this.head.next;\n      this.head.prev = null;\n      this.size--;\n      this.printList();\n      return this;\n    }\n\n    // remove tail\n    if (index === this.size - 1) {\n      this.tail = this.tail.prev;\n      this.tail.next = null;\n      this.size--;\n      this.printList();\n      return this;\n    }\n\n    // remove noe at an idx\n    let prevNode = this.head;\n    for (let i = 0; i < index - 1; i++) {\n      prevNode = this.head.next;\n    }\n    const deleteNode = prevNode.next;\n    const nextNode = deleteNode.next;\n\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n\n    this.size--;\n    this.printList();\n    return this;\n  }\n}\n\nconst doublyList = new DoublyLinkedList();\n\ndoublyList.append(5);\ndoublyList.append(16);\ndoublyList.prepend(1);\ndoublyList.insert(2, 99);\ndoublyList.insert(5, 80);\ndoublyList.remove(doublyList.getIdxWithVal(1));\n\n// 5\n// 5 <--> 16\n// 1 <--> 5 <--> 16\n// 1 <--> 5 <--> 99 <--> 16\n// 1 <--> 5 <--> 80 <--> 99 <--> 16\n// 5 <--> 80 <--> 99 <--> 16\n\n```\n\n### Circular Linked List 예시\n\n```js\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass DoublyLinkedList {\n  constructor(value) {\n    this.head = null;\n    this.size = 0;\n  }\n\n  printList() {\n    if (!this.size) return null;\n\n    const arr = [];\n    let currNode = this.head;\n\n    for (let i = 0; i < this.size; i++) {\n      arr.push(currNode.value);\n      currNode = currNode.next;\n    }\n\n    console.log(arr.join(` <--> `));\n    return this;\n  }\n\n  // Insert node at the end of the list\n  append(value) {\n    const newNode = new Node(value);\n\n    if (this.size === 0) {\n      this.head = newNode;\n      this.head.next = this.head;\n      this.size++;\n      this.printList();\n      return this;\n    }\n\n    let currNode = this.head;\n    while (currNode.next !== this.head) {\n      currNode = currNode.next;\n    }\n\n    currNode.next = newNode;\n    newNode.next = this.head;\n    this.size++;\n    this.printList();\n  }\n\n  // Insert node at the start of the list\n  prepend(value) {\n    const newNode = new Node(value);\n\n    if (this.size === 0) {\n      this.head = newNode;\n      this.head.next = this.head;\n      this.size++;\n      this.printList();\n      return this;\n    }\n\n    let currNode = this.head;\n    while (currNode.next !== this.head) {\n      currNode = currNode.next;\n    }\n    currNode.next = newNode;\n    newNode.next = this.head;\n    this.head = newNode;\n    this.size++;\n    this.printList();\n  }\n\n  // find index of specific node in the list with given index\n  getIdxWithVal(value) {\n    let idx = 0;\n    let currNode = this.head;\n    while (currNode !== null && currNode.value !== value && idx < this.size) {\n      currNode = currNode.next;\n      idx++;\n    }\n\n    if (currNode.value === value) {\n      return idx;\n    } else {\n      console.log(`Node with given val(${value}) doesn\\'t exist in the list`);\n      throw new Error(\n        `Node with given val(${value}) doesn\\'t exist in the list`\n      );\n    }\n  }\n\n  // Insert node at a given index\n  insert(index, value) {\n    if (!Number.isInteger(value) || index < 0 || index > this.size + 1) {\n      console.log(`Invalid index. Current length is ${this.size}`);\n      throw new Error(`Invalid index. Current length is ${this.size}`);\n    }\n\n    // If idx is 0, prepend\n    if (index === 0) {\n      this.prepend(value);\n      return this;\n    } else if (index === this.size) {\n      this.append(value);\n      return this;\n    }\n\n    // Reach to the specific index\n    const newNode = new Node(value);\n    let prevNode = this.head;\n\n    for (let i = 0; i < index - 1; i++) {\n      prevNode = this.head.next;\n    }\n\n    const nextNode = prevNode.next;\n\n    newNode.next = nextNode;\n    prevNode.next = newNode;\n    this.size++;\n    this.printList();\n  }\n\n  // Remove a Node\n  remove(index) {\n    if (!Number.isInteger(index) || index < 0 || index > this.size) {\n      console.log(\"invalid index\");\n      throw new Error(\"invalid index\");\n    }\n\n    // remove head\n    if (index === 0) {\n      let currNode = this.head;\n      while (currNode.next !== this.head) {\n        currNode = currNode.next;\n      }\n      currNode.next = this.head.next;\n      this.head = this.head.next;\n      this.size--;\n      this.printList();\n      return this;\n    }\n\n    // remove tail\n    if (index === this.size - 1) {\n      let currNode = this.head;\n      while (currNode.next !== this.head) {\n        currNode = currNode.next;\n      }\n      currNode.prev.next = this.head;\n      this.size--;\n      this.printList();\n      return this;\n    }\n\n    let currNode = this.head;\n\n    // remove noe at an idx\n    let prevNode = this.head;\n    for (let i = 0; i < index - 1; i++) {\n      prevNode = this.head.next;\n    }\n    const deleteNode = prevNode.next;\n    const nextNode = deleteNode.next;\n\n    prevNode.next = nextNode;\n\n    this.size--;\n    this.printList();\n    return this;\n  }\n}\n\nconst doublyList = new DoublyLinkedList();\n\ndoublyList.append(1);\ndoublyList.append(2);\ndoublyList.prepend(0);\ndoublyList.insert(2, 99);\ndoublyList.insert(5, 80);\ndoublyList.remove(doublyList.getIdxWithVal(1));\n\n// 1\n// 1 <--> 2\n// 0 <--> 1 <--> 2\n// 0 <--> 1 <--> 99 <--> 2\n// 0 <--> 1 <--> 80 <--> 99 <--> 2\n// 0 <--> 80 <--> 99 <--> 2\n\n```\n\n---\n\n\n\n\n"},{"excerpt":"서론 Javascript  메서드란  각 요소에 대한 주어진  를 실행하고,\n하나의 결과값을 반환한다. 나에게는 애증의 관계에 있는 메서드 중 하나이다. 생각보다 복잡한 것 같아서 기피하다가도,\n실제 사용해보면 이는 JS 에서 얼마나 강력한 기능을 가졌는지 매번 느끼게 된다. 보통  는 보편적으로  위와 같이 배열의 전체 합을 구할때 쓰이지만, 익숙해진다…","fields":{"slug":"/js-reduce-break/"},"frontmatter":{"date":"March 28, 2022","title":"자바스크립트 reduce break","tags":["JavaScript"]},"rawMarkdownBody":"\n## 서론\n\nJavascript `Reduce` 메서드란 `배열의` 각 요소에 대한 주어진 `reducer 함수` 를 실행하고,\n하나의 결과값을 반환한다.\n\n나에게는 애증의 관계에 있는 메서드 중 하나이다. 생각보다 복잡한 것 같아서 기피하다가도,\n실제 사용해보면 이는 JS 에서 얼마나 강력한 기능을 가졌는지 매번 느끼게 된다.\n\n보통 `reduce()` 는 보편적으로 \n\n```js\nconst arr = [1,2,3,4];\nreturn arr.reduce((acc, cur) => acc + cur);\n```\n\n위와 같이 배열의 전체 합을 구할때 쓰이지만, 익숙해진다면 적재적소에 필요한 custom reducer 를 직접\n만들어 사용할 수 있다.\n\n기존의 `for/while` 반복문을 사용할때는, 메모리 낭비 방지 및 소요시간 감소를 위해 원하는 해답 혹은 결과물이 나오면\n반복을 중단해야 한다고 생각한다.\n\n```js\nconst arr = [1, 2, 3, 4, 5, 6];\n\nfor (let num of arr) {\n  if (num === 5) break;\n  console.log(num); // 1, 2, 3, 4\n}\n```\n\n위와같이 `for/while` 반복문은 `break` 를 사용하여 반복을 중단할 수 있고,\n\n```js\nconst arr = [1, 2, 3, 4, 5, 6];\n\nfor (let num of arr) {\n  if (num === 5) continue;\n  console.log(num); // 1, 2, 3, 4, 6;\n}\n```\n\n`continue` 를 사용하여, 현재의 순환부를 종료하고 다시 순회표현식으로 이동하는 기능을 쉽게 구현할 수 있다.\n\n\n하지만, 위의 반복문같이 실행 중, 멈춤(break), 넘기기(continue) 는 `reduce()` 메서드에서 똑같이 사용 할 수 없고, 조금 더\n복잡한 로직을 사용해야 한다.\n\n---\n\n## 본론\n\n### 리듀서(reducer) 함수의 인자\n\n1. 누산기 (acc)\n2. 현재 값 (cur)\n3. 현재 인덱스 (idx)\n4. 원본 배열 (src)\n\n리듀서 함수는 위의 4개의 인자를 가진다.\n\n`누산기(acc):` 누산기는 콜백의 반환값을 누적\n콜백의 첫 번째 호출이면서 initialValue를 제공한 경우에는 initialValue의 값\n\n`현재값(cur):` 처리할 현재 요소\n\n`현재 인덱스(idx):` 처리할 현재 요소의 인덱스, initialValue를 제공한 경우 0, 아니면 1\n\n`원본 배열(src):` 원본 배열\n\n### reduce break\n\n본론으로 돌아가서, break 를 사용하려면 어떻게 해야할까?\n\n```js\nconst arr = [1, 2, 3, 4, 5];\n\nconst ans = arr.reduce((acc, cur, idx, src) => {\n  if (cur === 3) {\n    break; // wrong\n  } else {\n    return acc + cur;\n  }\n})\n```\n\n앞서 언급했듯이 이렇게 `break` 를 사용하면 당연히 작동하지 않는다. 해결법은\n\n```js\nconst arr = [1, 2, 3, 4, 5];\n\nconst ans = arr.reduce((acc, cur, idx, src) => {\n  if (cur === 3) {\n    src.splice(1);\n    return acc;\n  } else {\n    return acc + cur;\n  }\n})\n\nconsole.log(ans); // 3\nconssole.log(arr); // [1]\n```\n\n위의 코드를 보면 reduce function 은 4번째 인자인 `arr` 을 `mutating` 하기에,\n`slice()` 를 이용하여 강제 종료할 수 있다.\n\n하지만 여기에서 문제점은 `slice()` 를 사용하게 되면 원본 배열인 `arr` 에게도 영향을 미치기 때문에, \n위와 같은 방식을 사용하려면 해당 배열을 `deepcopy` 를 통해 새로운 배열을 만든 후 사용하는 방식이 바람직하지 않을까? 라고 생각한다.\n\n### reduce continue\n\n마지막으로 reduce function 내부에서 continue 와 같은 기능을 사용하려면 어떻게 해야할까?\n\n```js\nconst arr = [1, 2, 3, 4, 5];\n\nconst ans = arr.reduce((acc, cur, idx, src) => {\n  if (cur === 5) {\n    continue; // wrong\n  } else {\n    return acc + cur;\n  }\n})\n```\n\n당연히 위와 같이 하면 제대로 작동되지 않는다.\n\n```js\nconst arr = [1, 2, 3, 4, 5];\n\nconst ans = arr.reduce((acc, cur, idx, src) => {\n  if (cur === 5) {\n    return acc;\n  } else {\n    return acc + cur;\n  }\n})\n\nconsole.log(ans); // 10  \n```\n\n넘기고 싶은 loop 일때의 조건문을 걸어, 단순하게 여태까지 누산된 값인 `acc` 을 return 해주면 된다.\n\n---\n\n## 결론\n\n`reduce function` 내부에서 간단한 스킬을 사용하여, `for/while` 문의 `break / continue` 기능을 사용하는 것을 알아보았다.\n\n"},{"excerpt":"서론 일반적으로 나는 보통 Vanilla JS 로 프로젝트를 진행할때 \n 태그를 사용하여 \n 파일에  파일을   하는 방식을 일방적으로 떠올렸다.  \n하지만, 보통  태그 내부에  위와 같이 일반적인 방법으로 쓰곤 하였는데, 이때 브라우저의 동작방식은 \n\"엔진 자체가 위에서부터  을  하다가  태그를 만나면, \nHTML 의 Parsing 을 잠시 멈추고 …","fields":{"slug":"/js-async-defer/"},"frontmatter":{"date":"February 22, 2022","title":"자바스크립트 script 태그 async & defer 속성","tags":["JavaScript"]},"rawMarkdownBody":"\n## 서론\n\n일반적으로 나는 보통 Vanilla JS 로 프로젝트를 진행할때 <br>\n`<script>` 태그를 사용하여 \n`HTML` 파일에 `Javascript` 파일을 <br> `import` 하는 방식을 일방적으로 떠올렸다. <br> \n하지만, 보통 `<head>` 태그 내부에 <br>\n```html\n<!DOCTYPE html>\n<html lang=\"ko\"\n      <head>\n        <meta charset=\"UTF-8\" />\n        <title>이승환</title>\n        <script src=\"app.js\"></script>\n      </head>\n</html>\n```\n위와 같이 일반적인 방법으로 쓰곤 하였는데, 이때 브라우저의 동작방식은 <br>\n\"엔진 자체가 위에서부터 `HTML` 을 `parsing` 하다가 `script` 태그를 만나면, <br>\nHTML 의 Parsing 을 잠시 멈추고 `JS` 파일을 `fetching`  후 `execute` 한다.\" <br>\n\n정도인 것으로 알고 있었다. 이를 단순하게 보면, <br>\n\n`parse HTML` => <br>\n`HTML parsing temporarily blocked` => <br>\n`fetch js` => <br>\n`execute js` => <br>\n`continue parsing HTML` => <br>\n`Done!!` <br>\n\n라고 생각할 수 있다. <br>\n이때 만일 해당 `web application` 이 `js file` 에 <br>\n지나치게 많이 의존하고 있는 상황이거나, 인터넷의 속도가 느려 js file 의 `fetching` 및 \n`executing process` 시간이 길어지면 사용자는 아무 화면조차 볼 수 없는 상황에 직면할 수 밖에 없다.\n\n이에따른 해결점에 대해 구글링을 해보았다.\n\n---\n\n## 본론\n\n### body 내부에 script 태그 작성\n\n```html\n<!DOCTYPE html>\n<html lang=\"ko\"\n      <head>\n        <meta charset=\"UTF-8\" />\n        <title>이승환</title>\n      </head>\n      <body>\n        <p>이승환입니다</p>\n        <script src=\"app.js\"></script>\n      </body>\n</html>\n```\n\n그렇다면 `body` 태그 내부에, 또한 `최하단에` `script` 태그를 사용하는 방식을 <br>\n고려해 볼 수 있다. 이때의 웹브라우저의 동작 방식을 생각해본다면,\n\n`parse HTML` => <br>\n`when HTML is all ready then fetch js` => <br>\n`execute js` => <br>\n`Done!!`\n\n위와 같이 HTML parsing 이 끝나면, <br>\njs fetching 을 시작하고, 해당 작업이 끝나면, <br>\njs file 을 실행한다.\n\n이때, 인터넷이 느린 사용자는 긴 시간을 기다릴 필요 없이 <br>\n비교적 짧은 시간안에 페이지를 볼 수 있지만, <br>\n문제는 사용자의 `action` 이 `js file` 과 깊은 연관성이 있거나,\n요소의 `styling` 이 `js` 로 이루어져 있다면, <br>\n그야말로 빈 껍대기 뿐인 화면을 보는 상황에 직면하게 된다는 점이다.\n\n### head 태그 내부에 async 를 사용\n\n```html\n<!DOCTYPE html>\n<html lang=\"ko\"\n      <head>\n        <meta charset=\"UTF-8\" />\n        <title>이승환</title>\n        <script async src=\"app.js\"></script> //async\n      </head>\n      <body>\n        <p>이승환입니다</p>\n      </body>\n</html>\n```\n\n`head` 태그 내부에, `async` 를 사용하여 `js file` 을 `import` 한다면, <br>\n웹 브라우저의 동작 방식은\n\n`parse HTML & fetch js` => <br>\n`when js is all fetched block HTML parsing and execute js` => <br>\n`continue parsing HTML` => <br>\n`Done!` <br>\n\n위의 방식을 설명하자면, <br>\n초기 `HTML` 을 `parsing` 하다 `async` property 가 붙은 `script` 태그를 발견하면,\n`병렬적으로` `HTML parsing` 과 `js fetching` 을 `동시에` 한다. <br>\n그후, `js fetching` 이 끝난다면, `HTML parsing` 을 멈춘뒤 `js file` 을 실행한다. <br>\n이후에 마지막으로 멈췄던 `HTML parsing` 을 지속한다.\n\n뭔가 프로세스 자체가 굉장히 혁신적으로 병렬적 처리를 하며, 완벽해 보이지만, \n이 방식은 HTML parsing 이 끝나기도 전에, js file 이 실행되므로, js file 이\nHTML DOM 요소를 컨트롤 하는 코드가 있다면, 이는 실행되지 않거나 에러를 유발할 수 있다.\n\n더 이상적인 방식은 없을까?\n\n### head 태그 내부에 defer 를 사용\n\n```html\n<!DOCTYPE html>\n<html lang=\"ko\"\n      <head>\n        <meta charset=\"UTF-8\" />\n        <title>이승환</title>\n        <script defer src=\"app.js\"></script> //defer\n      </head>\n      <body>\n        <p>이승환입니다</p>\n      </body>\n</html>\n```\n\n`head` 태그 내부에, `defer` 를 사용하여 `js file` 을 `import` 한다면, <br>\n웹 브라우저의 동작 방식은\n\n`parse HTML & fetch js` => <br>\n`when HTML is all parsed execute js` => <br>\n`Done!` <br>\n\n일단 한눈에 보기에도 process 자체가 확실히 줄었다! <br>\n설명을 하자면, `HTML parsing` 을 하던 중 `script defer` 를 만나게 되면,\n`병렬적으로` HTML parsing 과 js fetching 을 진행한다. <br>\n그후, HTML parsing 이 완료되면, js file 을 실행한다.\n\n이 얼마나, 획기적인 방식인가. 사용자가 아무것도 못보는 시간을 단축하면서도,\njs 파일을 병렬적으로 fetching 하면서도, HTML parsing 이 끝나서야 js file 을 실행한다니.\n\n\n### 위 세개의 방식의 함축\n\n![](.index_images/2c239f8e.png)\n\n---\n\n## 결론\n\n하다못해 js file 을 import 하는 과정에도 상황에 맞는 방식을 택해야 하며, 고려할 상황이 \n꽤 많다는 점을 캐치하게 되었다. 해당 글을 작성했다고 무조건 `defer` 를 써야지! 라고 생각할 것이 아닌,\n모든 방식에 각각의 장단점과 동작원리를 알고 사용하는것이 중요하다고 다시 한번 생각한다.\n"},{"excerpt":"서론 내 개발환경을 보자면,  를 클렘쉘 모드로 덮어놓고, , ,  를 연결하여\n사용하고 있다. 하지만 줌(Zoom) 을 사용한다던가, 내가 사용하는 무거운? IDE 인 Webstorm 으로 개발을하며, 따로 서버까지 여는경우에는 타자치기가 힘들정도로\n버벅이고 맥북에서는 비행기 이륙하는 소리가 났다. 이러한 현상이 하루에도 수십번 일어나다 보니 도저히 나…","fields":{"slug":"/mac-kernal-task/"},"frontmatter":{"date":"February 16, 2022","title":"맥북 kernel_task 과점유 현상","tags":["Mac"]},"rawMarkdownBody":"\n## 서론\n\n내 개발환경을 보자면, `2019(Late) Macbook Pro 16'` 를 클렘쉘 모드로 덮어놓고, `외장모니터 2개`, `외장 키보드`, `외장 마우스` 를 연결하여\n사용하고 있다.\n\n하지만 줌(Zoom) 을 사용한다던가, 내가 사용하는 무거운? IDE 인 Webstorm 으로 개발을하며, 따로 서버까지 여는경우에는 타자치기가 힘들정도로\n버벅이고 맥북에서는 비행기 이륙하는 소리가 났다. 이러한 현상이 하루에도 수십번 일어나다 보니 도저히 나의 인내심이 견딜 수 없는 지경까지 도달하였다.\n\n`Activity Monitor` 를 사용하여 무슨 문제가 있나 확인해보니 `kernel_task` 란 녀석이 \ncpu 사용량을 무려 900% 를 사용하고 있다고 떡하니 적혀있었다.\n\n---\n\n## 본론\n\n### 커널테스크 (kernal_task) 는 무엇일까?\n\n커널테스크란 `linux` 의 최상위 제어권자이자 핵심 기능이다. </br>\ncpu 의 온도센서 중 하나라도 일정 수치를 넘게되면 내부적인 발열로 인하여\n컴퓨터의 고장을 방지하기위해 임의로 가상으로 커널테스크 프로세스 자체에 과부화를 걸게된다. </br>\n이로인하여 컴퓨터는 `쓰로틀링(throttling)` 이 걸리게 되며, 정상적인 작동을 할 수 없는 환경을 마주치게 되며, cpu 를 점유하고 있던 다른 프로세서들의 \n작동에 제한이 걸리며 cpu 의 온도가 정상적으로 돌아오게 만드는 녀석이라고도 부를 수 있다.\n\n### 통상적이지만 효과가 없거나 불가능한 해결책들\n\n그렇다면 커널테스크가 점유율을 높여 다른 프로세스들의 작동을 제한하면, </br>\n우리는 매번 하루에 수십번씩 '그렇구나~ 그럼 잠시 작업을 멈춰야 겠다!' 하지 않을것이지 않은가? \n\n이를 위해 인터넷을 뒤져보니 \n\n1. SMC (시스템 관리 컨트롤러) `초기화`\n2. 비정상적인 OS 접근으로 kernel_task 의 `자체적인 작업을 제한`\n3. 하판 오픈 (뚜따?) 이후 `써멀패드 부착`\n\n1번의 초기화를 Apple 공식홈페이지의 안내에 따라 실행하보았지만 효과는 전혀 없었다. </br>\n\n2번은 만일 차후에 무거운 작업을 돌리다 과도하게 cpu 의 온도가 치솟았을때 이를 제어해줄 kernel_task 가 없다면 고장을 야기할 수 있다.\n\n3번은 Apple 정책상 임의로 개인이 하판을 오픈하게 될경우 AS 를 받을 수 없게된다.\n\n\n이로인해, 나는 다른 방법을 생각해야 했으며, <br>\n단순하게 생각하면, 결국 `kernal_task` 의 과점유 현상은 즉, `온도` 와 밀접하게 관련이 있다. <br>\n온도를 잡으면 모든것이 해결되는 것 아닌가? <br>\n지금부터 내가 외장모니터 2개, 외장 키보드, 외장 마우스 를 사용하며 webstorm 으로 작업을 하는 도중에도 \n발열관리를 완벽히 잡은 개인적인 경험에 대해 써보려고 한다.\n\n### 나만의 진짜 해결책\n\n1. 맥북프로는 팬이 내부에서 돌아감에 따라 열이 뒤쪽 힌지부분으로 나오게 되며, <br>\n하판 자체에는 구멍이 일절 없다. 즉, 일반적인 `노트북용 쿨러` 는 저어어엉말 코딱지만한 효과밖에\n줄 수 없다. <br>\n하지만 이점을 이용하여 `물리적으로` 지우개 등을 이용하여 바닥에서 맥북을 공중으로 띄워놓는다.\n이정도만 해줘도 발열이 어느정도 잡힐 것이라고 나는 확신한다.\n \n\n2. `Macs Fan Control` 이라는 프로그램을 사용하여 임의로 맥북의 팬 속도를 일정하고 강하게 \n조절할 수 있다. 나는 무거운 프로그램을 돌릴때는 항상 `Full blast` 에 맞추어두고 사용한다.\n\n\n3. 물론 장점이겠지만 맥북 프로에 들어간 `Intel Processor` 는 `Turbo Boost` 기능을 가지고 있고, \n이를 자기 마음대로 적재적소에 활용한다. <br> \n주로 무거운 프로세스를 돌릴때 사용하는데 문제는 Turbo Boost 가 작동될 시점에 cpu 의 온도는 순간적이지만 기하급수적으로 상승하고, \n이는 곧 cpu 의 온도 상승으로 직결된다. 이를 방지하기 위해 `Turbo Boost Switcher` 라는 프로그램을 사용하여 꼭 필요한 경우를 \n제외하고는 항상 Turbo boost mode 기능을 꺼준다. 이로인하여 작업이 느려졌다고 채감한적은 단 한번도 없었다.\n---\n\n## 결론\n\n정말 마음먹고 거금을 들여 산 나의 맥북이 산지 반년도 지나지 않았는데 항상 끙끙대고 힘들어 하는 모습에\n정말 몇달동안 속상함을 넘어 분노가 치밀었다. 이로인해, 나는 거의 한달동안 모든 리소스를 찾아가며 이에대한 해결책을 찾으려 노력했고, \n이 과정에서도 개발적인 지식이 아니더라도 꽤 많은 지식을 얻었다고 생각한다. 이 글을 읽고 한분이라도 어서 광명을 찾으시길 기원하며...\n"},{"excerpt":"서론 아래의 링크에서 내가 왜 리액트같은 SPA 에서  을 해야하는지에 대해 서술하였지만, 이번에는 내가 현재 진행하고 있는 프로젝트\n내부에서 코드분할 전 후 를 비교하며 결과를 기록하려한다.  https://hwani.dev/react-code-splitting/  본론 SPA (Single Page Application) 의 특성상 맨처음 페이지에 진…","fields":{"slug":"/react-real-code-splitting/"},"frontmatter":{"date":"February 14, 2022","title":"리액트 Code-splitting 실적용 사례","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n아래의 링크에서 내가 왜 리액트같은 SPA 에서 `코드분할 (code-splitting)` 을 해야하는지에 대해 서술하였지만, 이번에는 내가 현재 진행하고 있는 프로젝트\n내부에서 코드분할 전 후 를 비교하며 결과를 기록하려한다. \n\nhttps://hwani.dev/react-code-splitting/ \n\n\n\n---\n\n## 본론\n\nSPA (Single Page Application) 의 특성상 맨처음 페이지에 진입하게되면 웹팩에서 압축한 bundle file 을 다운받게 된다. 즉, 전체 리소스를 \n`한번에` 다운받게 된다. \n\n이 개념이 이상적으로 보일 수 있으나, 결국 client (사용자) 는 전체 리소스의 bundle file 을 다운받기 전에는 화면을 볼수 없다는 뜻이기도 하다.\n한국이나 인터넷 속도가 빠른 환경에서는 크게 문제점을 느낄수 없을지도 모르나, 인터넷 환경이 느릴경우에는 이와같은 방식은 사용자 경험을 저하시키는 요인이 될 수 있다.\n\n이를 방지하기위해 `코드분할 (code-splitting)` 을 해준다. 코드분할이란 client (사용자) 에게 현재 불필요한 코드, 중복되는 코드 없이 적절한\n사이즈의 코드가 적절한 타이밍에 `동적으로` 로드되도록 하는것이다.\n\n이제 이 글을 읽는 독자를 위하여 실제 코드분할을 하면 어떠한 효과를 가져오는지 실 예시사례와 함께 보여주겠다.\n\n### 개선 전\n\n```js\nimport {\n  Home,\n  Solve,\n  Problems,\n} from './pages/index';\n\nconst App = () => {\n  return (\n    <Switch>\n      <Route exact path=\"/\">\n        <Home />\n      </Route>\n      <Route exact path=\"/solve\">\n        <Solve />\n      </Route>\n      <Route exact path=\"/problems\">\n        <Problems />\n      </Route>\n    </Switch>\n  )\n}\n```\n\n물론 실제 진행하고 있는 프로젝트의 일부분만 가져왔지만 기본적으로 위와같이 컴포넌트를 상위컴포넌트인 `App.js` 에서 불러와 routing 처리를 하고있다.\n\n이 경우에는 하나의 번들사이즈에 모든 페이지들이 포함되게 되며 번들 파일의 다운이 완료되기 전까지는 사용자는 실제 화면을 볼 수 없다.\n\n![](.index_images/d9949446.png)\n\n해당 번들을 실제로 analyze 해봤을때 위와같은 `하나의` 거대한 chunk file 로 구성되어있고 이의 stat size 는 자그마치 `6.74MB` 를 차지하고 있었다.\n\n![](.index_images/89daab0c.png)\n\n또한 `light house` 를 돌려보았을때도 해당 이유로 인하여 퍼포먼스 점수가 53점으로 매우 낮게 평가되는 모습을 볼 수 있었다.\n\n### 개선 후\n\n```js\nimport { WaveLoading } from 'react-loadingg';\nimport { lazy, Suspense } from 'react';\n\nconst Home = lazy(() => import('./pages/Home/Home'));\nconst Solve = lazy(() => import('./pages/Solve/Solve'));\nconst Problems = lazy(() => import('./pages/Problems/Problems'));\n\nconst App = () => {\n  return (\n    <Suspense fallback={<WaveLoading />}>\n        <Switch>\n          <Route exact path=\"/\">\n            <Home />\n          </Route>\n          <Route exact path=\"/solve\">\n            <Solve />\n          </Route>\n          <Route exact path=\"/problems\">\n            <Problems />\n          </Route>\n        </Switch>\n    </Suspense>\n  )\n}\n```\n\n위와같이 `lazy` 와 `Suspense` 를 사용하여 코드분할을 통해 번들을 쪼개어 사용자가 필요한 시점에 동적으로 다운을 받게 리팩토링을 해주었다.\n\n![](.index_images/e4c9d43f.png)\n\n위와같이 초기 필요한 번들의 사이즈는 물론 개선이 필요하지만 `2.1MB` 로 감소되었고 사용자의 액션에 따라 동적으로 필요한 코드를 다운로드 받게 된다.\n\n![](.index_images/4030a7db.png)\n\n물론 `lazy`와 `Suspense` 를 사용함으로써 `render-blocking` 요소를 사용함에 따라 접근성 점수는 저하되었지만, 퍼포먼스 점수는 전과 비교하면 매우 큰 \n폭으로 향샹되었다.\n\n해당 점수의 폭만 봐도 이정도의 노력만 들이더라도 전반적인 퍼포먼스를 대폭 늘릴 수 있다면 `코드 분할` 을 사용해야할 이유는 충분하지 않을까 생각한다.\n\n---\n\n## 결론\n\n`코드 분할 (code-splitting)` 은 단순 \"지연시간동안 사용자에게 로딩화면을 보여준다\" 라는 이유 이외로도 실제 SPA 의 성능 향상에 대폭 영향을 끼친다.\n\n\n\n"},{"excerpt":"2021년 11월 말부터 블로그 작성을 시작하여 어느덧 3개월 정도가 지난것 같다. 원래는  에 강의를 듣고 이를 정리하는 식으로 진행하고 있었지만, 문뜩 든 생각이,  '이걸 누가 못하는가?' '저작권 법에 정말 문제가 없는가?'  '나에게 어떠한 방식으로 성장의 밑거름이 되었는가?' 정도가 있었다. 결론은, 강의를 듣고 정리하는 글들은 이미 잘하시는 …","fields":{"slug":"/2021-retrospect/"},"frontmatter":{"date":"February 10, 2022","title":"2021년 블로그 운영 회고","tags":["회고"]},"rawMarkdownBody":"\n\n\n2021년 11월 말부터 블로그 작성을 시작하여 어느덧 3개월 정도가 지난것 같다.\n\n원래는 `Velog` 에 강의를 듣고 이를 정리하는 식으로 진행하고 있었지만,\n\n문뜩 든 생각이, \n\n- '이걸 누가 못하는가?'\n- '저작권 법에 정말 문제가 없는가?' \n- '나에게 어떠한 방식으로 성장의 밑거름이 되었는가?'\n\n정도가 있었다.</br> 결론은, 강의를 듣고 정리하는 글들은 이미 잘하시는 분들도 많고, </br> 나는 단순히 `이승환의 개발블로그` 라는 타이틀을 가지고\n강의 정리 내용으로 내 블로그의 정체성을 정하고 싶지 않았다.\n\n--- \n\n저작권법에 관해서는 이미 다른분들도 충분히 알아보고 괜찮다고 하시는 분들도 많았지만 개인적으로는 강의자가 어떠한 문제에 대해 해결책을 내리고 이를 이용하여\n수익창출을 함에도 불구하고 `똑같은` 내용을 원작자의 동이 없이 그대로 다른이에게 무단으로 해당 강의자의 견해를 전달하는 블로그가 되고싶지 않았다.\n\n단순히 강의에대한 정리를 쓰는 행위자체가 나의 성장에 어떻게 도움을 주었는가에 대한 질문은 물론 해당 과정에서 더욱 머리에 정리되는 느낌이 들었고,\n실제 배운 내용을 기반으로 글을 씀으로써 새로운 궁금증이 생기는 긍정적 효과가 있었지만, 위와같은 이유로 강의 내용이 빽빽히 찬 블로그를 만들고 싶지는\n않았다.\n\n---\n\n\n그후, 나름 나만의 방법으로 새로운 블로그에 새 출발을 하기로 결정하였다. \n\n글을 쓸때, 아래와 같은 프로세스를 통해 작성하기로 결심하였다.\n\n- 공부 혹은 프로젝트중 항상 새로운 궁금증, 문제에 직면한다.\n- 해당 궁금증을 해결하거나 문제를 해결하기위해 구글링을 통해 여러 사람의 의견 및 자료를 추합하여 나만의 해답을 내놓는다.\n- 글을 쓸때, 서론, 본론, 결론에 의거하여 왜 이런 문제에 직면했는가, 어떤 해결방법 혹은 원리가 들어갔는가, 그래서 결론은 무엇인가? 에 꼭 입각하여 작성한다.\n\n하지만 이렇다보니 미천한 나의 실력에 비해 내 견해가 너무 많이 뭍을 수 있는 글을 쓰기 시작하였고, 과연 이런 성질의 글을 사람들이 봐줄까..? 라는 생각이 들며 \n글을 쓰고 있었다.\n\n![](.index_images/6009a6a2.png)\n\n하지만 예상과 달리 생각보다 실제 지표는 가파른 상승세를 보여줬고 단 한분이라도 내 글을 읽어주면 좋겠다\n라는 생각과 달리 꽤 많은분들이 내 글들을 읽어주셨다.\n\n비록 자주는 못하더라도 멈추지 않고 계속 공부를 이어나가며 글들을 쓸 계획이다.\n"},{"excerpt":"서론 알고리즘을 연습하고 탐구하다 여지껏 쓴 코드들을 보며  에 대해 생각을 해보았다. 적어도 빅오표기법 기준  어쩔 수 없지 라고 생각하며 마구잡이 식으로  내부에  메소드를 남발하고 있었다.   위의 코드를 비교하며 나는 헷갈리기 시작했다.  메소드가 단순히 마법처럼 해당 value 의 index 를 뿅 하고 찾아 리턴해줄까..? \n만일 그렇다면 두개…","fields":{"slug":"/js-indexOf/"},"frontmatter":{"date":"January 29, 2022","title":"자바스크립트 indexOf() 와 시간 복잡도의 상관관계에 대한 고찰","tags":["JavaScript"]},"rawMarkdownBody":"\n## 서론\n\n알고리즘을 연습하고 탐구하다 여지껏 쓴 코드들을 보며 `시간복잡도` 에 대해 생각을 해보았다.\n\n적어도 빅오표기법 기준 `O(n)` 어쩔 수 없지 라고 생각하며 마구잡이 식으로 `for문` 내부에 `indexOf()` 메소드를 남발하고 있었다.  \n\n```javascript\nconst arr = [1, 2, 3];\n\n\nfor (let elIdx in arr) {\n  return elIdx; // 0, 1, 2\n} \n\n// O(n)\n\nfor (let el of arr) {\n  return arr.indexOf(el); // 0, 1, 2\n}\n\n// O(n) ????????????????????\n```\n\n위의 코드를 비교하며 나는 헷갈리기 시작했다. `indexOf()` 메소드가 단순히 마법처럼 해당 value 의 index 를 뿅 하고 찾아 리턴해줄까..? \n만일 그렇다면 두개의 예시의 공통된 시간복잡도는 `O(n)` 일것이다.\n\n만일 아니라면? indexOf() 의 동작방식이 element 들을 순차적으로 모두 돌며 체크한다면? 그렇다면 두번째 예시의 시간복잡도는 `O(n^2)` 이지 않을까\n라며 생각했다.\n\n---\n\n## 본론\n\n결론부터 말하자면, `indexOf()` 는 모든 element search 하지 않는다. 하지만 위의 두번째 예시의 시간복잡도는 `O(n^2)` 으로 표기된다.\n\nhttps://tc39.es/ecma262/#sec-array.prototype.indexof\n\n해답은 `ECMAScript` 의 공식문서에서 찾을 수 있었다.</br> 이에 따르면, `indexOf()` 는 인자로 `fromIndex` 를 별도로 받지 않았을 경우, \n물론 받아도 마찬가지이지만, 받지 않았을 경우 0 index 부터 순차적으로 탐색을 시작하며, 찾을경우 즉시 해당값을 `return` 해준다.<br/> 받았을 경우에도\n해당 index 부터 탐색을 시작하며, 찾을 경우 곧바로 값을 `return` 해준다. \n\n키포인트는 값을 찾을경우 `즉시` return, 즉 탐색을 끝낸다는 뜻이다.<br/> 이는 곧 '`indexOf()` 는 모든 element search 하지 않는다.' 로 해석된다.\n\n그렇다면 `indexOf()` 의 단순 시간복잡도는 `O(1)` 일까? 그렇지 않다. 시간복잡도를 계산할때는 항상 `최악`의 상황을 고려해야한다. `indexOf()` 의\n최악의 상황이라 꼽자면, array 에는 99999999999999999999999999개의 3이라는 element 가 존재하지만 ( [3,3,3,3,3,3,3........) ], 코더가\narray.indexOf(1) 이라고 작성 후 실행하는 상황이라 생각된다. 이경우에는 0 index 부터 array.length-1, 값을 찾을 수 없기때문에 처음부터 끝까지 탐색을 \n하게된다. 과연 이 경우에도 시간복잡도를 `O(1)` 이라고 표현할 수 있을까?\n\n이에따른 해답을 찾기위해 부끄럼움을 무릅쓰고 `stackOverflow` 에 직접 질문을 하게 된다.\n\nhttps://stackoverflow.com/questions/70902661/does-indexof-in-js-searches-all-the-elements-of-an-array-to-execute\n\n이에따른 사람들의 답은, 위에 같은 상황때문에 `indexOf()` 의 시간복잡도는 `O(n)` 으로 표기된다고 한다. 그러므로 최악의 경우를 피하기 위해, 무분별한\n`indexOf()` 의 사용 보다는 `binary search` 를 통한 `O(log n)` 을 노려볼 수도 있다 라고 답한분도 있었다.\n\n---\n\n## 결론\n\nQ1. `indexOf()` 는 모든 element 를 탐색하여 값을 도출해낼까?\n\nA1. 아니다. `indexOf()` 는 `startIndex` 를 따로 인자로 받지 않는상황에서는 index 0 부터 해당 value 값을 찾을때까지 search 를 진행하고, 찾을경우\n바로 값을 return 한다.\n\nQ2. 그렇다면 `indexOf()` 를 사용해 1번의 search 를 통해 정상적인 값을 리턴받았다면 단순 시간복잡도는 `O(1)` 으로 표기될수 있지 않은가?\n\nA2. 아니다. 시간복잡도를 표현할때는 항상 `최악의` case 에 입각하여 계산을 해야하기에, 무한개의 element 를 가진 array 에 탐색하고자 하는 값이 없다면? \n과 같은 상황이 있기에, `O(n)` 으로 표기된다.\n\n\n\n"},{"excerpt":"서론 자바스크립트는 하나의  과 하나의  을 가진 \n 이다. 그러므로 당연히 위에서부터 순차적으로 코드를\n실행하고 다음 코드로 넘어가기 전 실행하고 있는 코드를 끝내야만 한다. 맞다.  는 . 허나, 내 머리를 지끈거리게 만든 점은 코르를 작성하다보면 의도적으로 코드를  하는 행위를 \n심심치 않게 해왔지만,  '도대체 어떻게 싱글스레드인  자바스크립트는 …","fields":{"slug":"/js-single-thread/"},"frontmatter":{"date":"January 24, 2022","title":"싱글스레드인 자바스크립트는 어떻게 비동기 처리를 하는가","tags":["JavaScript"]},"rawMarkdownBody":"\n## 서론\n\n자바스크립트는 하나의 `call stack` 과 하나의 `memory heap` 을 가진 \n`single threaded language` 이다. 그러므로 당연히 위에서부터 순차적으로 코드를\n실행하고 다음 코드로 넘어가기 전 실행하고 있는 코드를 끝내야만 한다. 맞다. `자바스크립트(js)` 는 `동기적이다(synchronous)`.\n\n허나, 내 머리를 지끈거리게 만든 점은 코르를 작성하다보면 의도적으로 코드를 `비동기 처리` 하는 행위를 \n심심치 않게 해왔지만, \n\n'도대체 어떻게 싱글스레드인  자바스크립트는 코드를 비동기적으로 실행시킬까?' 에서 머리가 복잡해졌다.\n\n\n---\n\n## 본론\n\n고맙게도 자바스크립트 엔진은(V8, Spidermonkey, JavascriptCore 등등..)은 \n이와같은 task 들을 병렬적으로 background 에서 동작시키기 위해 필요한 `Web API` 를 가지고 있다.\n\ncall stack 은 Web API 의 함수들을 인지하고 필요에 의해 브라우저에게 task를 맡긴다.\n맡겨진 task가 끝난 후에는, 브라우저는 해당 task를 다시 반환 후 callback 으로써 다시 스택에 밀어넣는다.\n\n브라우저 콘솔에서 `window` 를 쳐본다면 ajax calls, 이벤트 리스너, fetch API, setTimeout 등 \nWeb API 가 제공하는 모든것들을 확인할 수 있다. 이제 어떻게 자바스크립트가 브라우저에서 `비동기적으로` 동작하는지 예시와 함께 알아보자.\n\n```javascript\nconsole.log(\"first\")\nsetTimeout(() => {\n    console.log(\"second\")\n}, 1000)\nconsole.log(\"third\")\n```\n\n위의 코드를 적어내면\n\n```javascript\nfirst\nthird\nundefined\nsecond\n```\n\n위의 결과가 나온다. 벌써 머리가 어질어질하다. 'first', 'third', 'second' 의 결과가 나와야 하지 않나? 하지만 이는 에러로 인해 해당 결과가 나온것이 아니다. 한줄한줄 추적해보자.\n\n1. `console.log(first)` 가 처음 스택에 쌓이게 되고 콘솔에 찍힌다. \n\n2. 엔진은 자바스크립트에서 동작하지 않는 `setTimeout()` 을 발견하고는 비동기적인 처리를 위해 `Web API` 에게 보내버린다.\n\n3. 2번의 동작을 신경쓰지 않은체 `console.log(three)` 를 스택에 쌓고 실행시킨다. \n\n4. 자바스크립트의 엔진의 `event loop`이 개입하여 '우리 이제 끝난거야..?' 하고 물어본다.\n\n5. `web API` 가 '아니? 아직인데? 줄 value 가 없어!' 라고 대답을 하자 디폴트 값인 `undefined` 를 콘솔에 찍는다.\n\n6. 비동기처리를 하던 task 가 완료 후, callback 으로써 스택에 들어오게 되고, 이는 실행되어 콘솔에 second 를 찍는다.\n\n---\n\n## 결론\n\n결국 내가 생각하던게 어느정도는 맞다. 자바스크립트는 single threaded language 이고, 하나의 \n콜스택과 하나의 힙스택을 가지고 있기에 동기적으로 task 를 처리한다. 하지만 이는 브라우저에서 실행될때\nWeb API 라는 녀석을 사용하여 비동기적으로 task 를 처리할 수 있다.\n\n\n\n"},{"excerpt":"서론 위의 코드는 자바스크립트를 학습한 사람이라면 누구나 에러를 예상할 수 있는 코드이다.\n이유라 하면 변수  은 const 키워드를 사용한 즉, 변하지 않는  을  후 우항의 표현식에 따른 값(1) 을\n 하였기 때문에 값을 변경할 수 없다. 아무런 생각없이 평소에 작성하던 위의 예시와 같은 코드에 대해 생각해보다가 정말 머리가 터지고, 자바스크립트에 대…","fields":{"slug":"/js-const/"},"frontmatter":{"date":"January 23, 2022","title":"자바스크립트 const(constant) 키워드 에 대한 고찰","tags":["JavaScript"]},"rawMarkdownBody":"\n## 서론\n\n```javascript\nconst num = 1;\nnum = 2 // Uncaught TypeError: Assignment to constant variable.\n```\n\n위의 코드는 자바스크립트를 학습한 사람이라면 누구나 에러를 예상할 수 있는 코드이다.\n이유라 하면 변수 `num` 은 const 키워드를 사용한 즉, 변하지 않는 `변수(메모리 공간)` 을 `선언` 후 우항의 표현식에 따른 값(1) 을\n`할당` 하였기 때문에 값을 변경할 수 없다.\n\n```javascript\nconst arr = [];\narr.push('foo');\nconsole.log(arr); // ['arr']\n```\n\n아무런 생각없이 평소에 작성하던 위의 예시와 같은 코드에 대해 생각해보다가 정말 머리가 터지고, 자바스크립트에 대해\n의구심을 가지기 시작했다. `const` 즉, `constant` 의 줄임말, 한글로 해석하면 `상수`, 상수란 `변하지 않는 값`.\n하지만 상수의 값을 바꾸는 코드를 실행했는데 에러가 나지 않았다? 미친듯이 구글링을 하기 시작했다.\n\n---\n\n## 본론\n\n물론 이에 대해 반박하시는 분들의 의견은 거의 일치했고 이에따라 근거는 항상 거의 같았다.\n\n우선 공식문서에 의거하면 \n\n- 상수는 `재할당` 에 의해 변경될 수 없다.\n- 상수는 `재선언` 될 수 없다.\n\n결국 cost keyword 를 사용해 선언한 배열(arry) 혹은 객체(object)를 조작하는 행위는,\n재할당 및 재선언에 의해 값을 변경하는 것이 아닌, 해당 상수가 가리키고 있는 list 를 수정하는 행위이기에 \n맞는 행위이다.\n\n위의 내용은 아래의 그림을 보면 더 이해가 빠르다.\n\n![](.index_images/e0a941cc.png)\n\n![](.index_images/12773e0d.png)\n\n첫번째 그림은 변수 선언 후 원시타입의 값의 할당을 표현한 그림이다. 두번째 그림은 변수 선언 후\n객체타입의 값의 할당을 표현한 그림이다.\n\n우선 이 둘의 근본적인 차이는 데이터 타입이다. 원시타입의 값은 실제 메모리에 값이 바로 저장되게 되며, 변수는 \n해당 메모리의 주소를 참조한다. 또한, 원시타입의 값은 변경 불가능한 값(immutable value) 이다.\n그에반해 두번째 그림을 보게되면 변수가 참조하는 메모리 주소는 실제 값이 저장된 다른 메모리주소를 가리키며 쉽게 말해 \n하나의 메모리 주소가 생성이 되는 것이 아니라는 소리다. 실제 값은 객체(참조) 타입의 값이며 이는 변경 가능한 값(mutable value) 이다.\n\n이를 더 풀어보자면, \n\n```javascript\nconst num = 1;\nnum = 2; // Uncaught TypeError: Assignment to constant variable.\n```\n위의 원시타입의 데이터 값은 실제 하나의 메모리 주소를 참조하고 해당 메모리 주소는 본질의 `값`을 저장하고 있기에,\n`상수`의 의미론적으로도 변경이 불가하다.\n\n```javascript\nconst arr = [];\narr.push('foo');\nconsole.log(arr); // ['arr']\n```\n하지만 위의 변수(arr)는 한개의 메모리주소을 참조하고 있고 참조하고 있는 해당 메모리 공간은 실제 데이터인 array 타입의 값이 들어가 있다.\n'const 로 선언된 변수가 참조하고 있는 메모리 주소가 참조하고 있는 해당 배열의 값' 을 어떻게 변경할 수 있는지에 대해 생각을 해보자면\n해당 배열의 값이 변경되어도 실질적으로 `arr` 변수가 참조하고 있는 메모리 공간에는 실제 값을 가지고 있는 메모리 공간을 `참조하는 값` 이 들어있으며,\n이는 실질적인 데이터가 변경되어도 바뀌지 않는다.\n\n---\n\n## 결론\n\n머리가 꼬여가던 상황이 겨우 풀어졌다. \n해당 개념을 학습했다 해도, 결국 사람이 이해해야 하는데 이를 `상수` 라는 키워드를 쓰는것은 \n진입장벽을 높이는 상황이 아닐까..? 하고 조심스럽게 생각해본다.\n\n\n\n"},{"excerpt":"서론 리액트 프로트를 진행하다보면 위와같은 코드를 심심치 않게 쓴다. 나는 보통 url 을 통해 데이터를 fetching\n하였을때 비동기 처리를 위해 데이터가 있을때만 해당 코드가 동작하게 하는  이구나 하고 \n아무생각 없이 사용하곤 하였다. 그러던 중 해당 코드는 자바스크립트의  라는 개념을\n사용한다는 것을 알게되었고 이에대해 정리하려고 한다. 본론 논…","fields":{"slug":"/js-short-circuit-evaluation/"},"frontmatter":{"date":"January 20, 2022","title":"자바스크립트 단축 평가","tags":["JavaScript"]},"rawMarkdownBody":"\n## 서론\n\n```javascript\n\n// ... 생략\nreturn (\n  <Root>\n    {data && <p>{data.name}</p>}\n  </Root>\n)\n```\n\n리액트 프로트를 진행하다보면 위와같은 코드를 심심치 않게 쓴다. 나는 보통 url 을 통해 데이터를 fetching\n하였을때 비동기 처리를 위해 데이터가 있을때만 해당 코드가 동작하게 하는 `예외처리` 이구나 하고 \n아무생각 없이 사용하곤 하였다. 그러던 중 해당 코드는 자바스크립트의 `논리연산자를 사용한 단축 평가` 라는 개념을\n사용한다는 것을 알게되었고 이에대해 정리하려고 한다.\n\n---\n\n## 본론\n\n- 논리곱(&&) 연산자는 두개의 피연산자가 모두 true 로 평가될 때 true 를 반환한다. 논리곱 연산자는 좌항에서 우항으로 평가가 진행된다.\n- 논리합(||) 연산자는 두개의 피연산자 중 하나만 true 로 평가되어도 true 를 반환한다. 논리합 연산자 또한 좌항에서 우항으로 평가가 진행된다.\n\n논리곱 연산자와 논리합 연산자는 `논리 연산의 결과를 결정하는 피연산자` 를 타입 변환하지 않고 그대로 반환한다. 이를 단축 평가라 한다.\n단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 뜻한다.\n\n```javascript\n// 논리곱(&&) 연산자\n'a'   && 'b'   // => 'b'\nfalse && 'b'   // => false\n'a'   && false // => false\n\n// 논리합(||) 연산자\n'a'   || 'b'   // => 'a'\nfalse || 'b'   // => 'b'\n'a'   || false // => 'a'\n```\n\n단축 평가를 사용하면 if 문을 대체할 수 있다. 어떤 조건이 true 여야 실행되어야 한다면, 논리곱(&&) 연산자 표현식으로 \n이를 대체하고, 조건이 false 여야 실행되어야 한다면 논리합(||) 연산자 표현식으로 이를 대체할 수 있다.\n\n```javascript\nlet finished = true;\nlet message = '';\n\nmessage = finished && '완료';\nconsole.log(message); // => '완료'\n\nfinished = false;\n\nmessage = finished || '미완료';\nconsole.log(message); // => '미완료'\n```\n\n---\n\n## 결론\n\n단축평가에 대해 처음 알아보기 전에는 그냥 비교연산자와 같이 비교하여 true / false 를 반환하는거 아니였나..? 라고 막연하게\n생각하였는데 그렇지 않고 논리 연산의 결과를 `결정` 하는 피연산자를 그대로 타입 변환 없이 그대로 반환한다는 특징을 가지고 있다.\n이를 잘만 사용한다면 리액트를 사용할때, 논리식을 사용하여 데이터가 없거나 아직 비어있을때 에러를 방지하는 처리를 해줄 수 있겠다는 결론에 다달았다.\n\n\n"},{"excerpt":"서론 자바스크립트 내에서 세미콜론(;) 은 언제 사용해야할까? 왜 사용해야할까?  언제 사용해야할까? 나는 흔히 인터넷에서 돌아다니는 말중에 '자바스크립트를 사용할때 \n세미콜론을 생략해도 되지만, 사용하도록 버릇을 들이는게 좋을것이다.' \n라는 대다수의 조언을 받아드려 마구잡이로 사용하고 있었다. 내가 세운 나만의 기준은 당시 '문장의 끝에 단다.' 정도…","fields":{"slug":"/js-semicolon/"},"frontmatter":{"date":"January 18, 2022","title":"자바스크립트 내에서의 세미콜론(;) 사용","tags":["JavaScript"]},"rawMarkdownBody":"\n## 서론\n\n자바스크립트 내에서 세미콜론(;) 은 언제 사용해야할까?\n\n왜 사용해야할까? \n\n언제 사용해야할까?\n\n나는 흔히 인터넷에서 돌아다니는 말중에 '자바스크립트를 사용할때 \n세미콜론을 생략해도 되지만, 사용하도록 버릇을 들이는게 좋을것이다.' \n라는 대다수의 조언을 받아드려 마구잡이로 사용하고 있었다.\n\n내가 세운 나만의 기준은 당시 '문장의 끝에 단다.' 정도였지만 조금더 \n정확한 이유와 개념을 알 필요가 있다고 생각했다.\n\n---\n\n## 본론\n\n세미콜론(;)은 `문` 의 종료를 나타낸다. \n\n`문` 이란 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. \n문의 집합으로 이루어진 것이 `프로그램` 이며, 문을 작성하고 순서에 맞게\n나열하는 행위가 `프로그래밍` 이다.\n\n```javascript\nconst num = 1 + 3;\n```\n\n예시로, 위의 내가 생각하던 '문장'은 키워드를 사용한 `변수의 선언`, `표현식의 평가`,`값을 할당`\n이 이루어진 하나의 `문` 이다. 즉 자바스크립트는 세미콜론을 기준으로 문이 종료한 위치를 파악 후 순차적으로 하나씩 문을 실행한다.\n\n허나 여기에서 내가 생각하던 문제가 있다. 나는 주로 `ESLint` 와 `Prettier` 같은 정적 분석 도구를 사용하였지만,\n보통 문의 종료라고 생각되는 지점에는 자동적으로 세미콜론을 붙여주였지만, `if문`, `for문`, `함수` 뒤에는 세미콜론을 자동으로 붙이지 않아주었다.\n\n나는 여지껏 해당 정적 분석 도구 자체의 하나의 오류이거나 해당 행위는 optional 하지 않을까..? 라고 어림짐작만 하고 있던 상태였다.\n\n하지만, if문, for문, 함수등의 코드 불록 뒤에는 세미콜론을 붙이지 않으며 이유는, 이러한 코드 블록은 언제나 문의 종료를 의미하는\n`자체 종결성 (self closing)` 을 가지고 있기 때문이다.\n\n또한, 자바스크립트 엔진은 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 \n`ASI` 가 자동으로 실행되지만 왜 대다수의 개발자들은 세미콜론을 반드시 붙여야한다는 의견이 대다수일까?\n\n![](.index_images/2c803f76.png)\n\n위의 한 개발자가 말하기를, C# 을 사용할때는 문의 끝에 반드시 세미콜론을 붙여야한다는 문법적 강제성이 따른다.\n하지만 말그대로 자바스크립트에서 런타임 동작시 우리가 붙인 세미콜론은 아무런 의미를 찾을 수 없다는 의견을 내포한다고 나는 이해하였다.\n\n반대로 써야한다는 개발자들의 의견의 대다수는, 보통 다른언어에서도 그래왔기 때문에 `가독성` 면에서 다른이가 나의 코드를 읽었을때,\n세미콜론을 사용한다면 해당 문의 끝이 어디인지 정확히 알 수 있기도 하고, 인터프리터의 ASI 기능에 100프로 의존하며 자발적으로 불안감을 느낄 수 있는 행위를 \n도대체 왜 옹호하냐는 의견이 많았다.\n\n---\n\n## 결론\n\n세미콜론은 문의 종료를 나타낸다. 문이란 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 하지만, 자바스크립트에서는\n개발자가 세미콜론을 붙이지 않더라도 ASI 를 통해 자동적으로 문의 끝의 예측지점에 세미콜론을 부여한다.\n\n세미콜론의 사용 비사용 의견에 나의 의견을 말하자면, 결국 우리의 소스코드를 인터프리터가 해석한다고 하지만, 결국 소스코드란\n개발자가 쓰고, 유지하고 보수하는 하나의 `문서` 라고 생각이 든다. 그 뜻은, 해당 소스코드를 작성한 개발자 및 해당 소스코드를 \n읽고 사용,유지 및 보수해야하는 다른 개발자 또한 지속적으로 해당 소스코드를 보아야 하는데, 인간이 글을 작성할때 가독성을 위해 \n문장의 끝에 마침표를 넣듯이, 결국 안정성 및 가독성을 위해 세미콜론을 사용해야 하지 않을까?  \n\n"},{"excerpt":"서론 외부 api 를 사용하는 상황에서 Docs 를 읽어본다 한들 실제 데이터의 형태가 어떻게 구성되어있는지 정확히 예상하고 코드를 짜는 행위는 불가능에 가깝다고 생각하고 에러를 유발한다. 나는 데이터 구성을 확인하기 위해 데이터 fetching 후 직접 콘솔로 찍어 확인하는 방법을 사용하였는데, 이는 차후에 코드의 에러를 유발할 수 있고, 자칫 까먹고 …","fields":{"slug":"/react-debugging/"},"frontmatter":{"date":"January 09, 2022","title":"리액트 크롬 데브툴 디버깅(debugging)","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n외부 api 를 사용하는 상황에서 Docs 를 읽어본다 한들 실제 데이터의 형태가 어떻게 구성되어있는지 정확히 예상하고 코드를 짜는 행위는 불가능에 가깝다고 생각하고 에러를 유발한다. 나는 데이터 구성을 확인하기 위해 데이터 fetching 후 직접 콘솔로 찍어 확인하는 방법을 사용하였는데, 이는 차후에 코드의 에러를 유발할 수 있고, 자칫 까먹고 체크하는 코드를 없애는 행위를 까먹는 상황을 방지하기 위해 직접 콘솔을 찍기 보다는 `Chrome Dev Tool` 을 사용하여 `디버깅` 하는 방법을 채택하였다.\n\n---\n\n## 본론\n\n`디버깅(debugging)` 은 스크립트 내 에러를 검출해 제거하는 일련의 과정을 의미한다. 모던 브라우저의 환경 대부분은 개발자 도구 내부에 UI 형태로 디버깅 툴을 가지고 있다. 디버깅 툴을 사용하면 실행 단계마다 어떤 일이 일어나는지를 코드 단위로 추적할 수 있다.\n\n![](2022-01-09-16-32-59.png)\n\n구글크롬에서 `F12` 를 누르면 `Chrome Dev Tool` 을 사용할 수 있다. 이후 탭에서 `Sources` 를 누르면 위와같은 화면이 보인다. \n\nSource 패널의 좌측은 `파일 탐색 영역` 으로 페이지에 쓰인 리소스를 트리 형태로 보여준다.\n\n중앙은 `코드 에디터 영역` 으로 파일 탐색 영역에서 선택한 파일의 소스 코드를 보여준다.\n\n우측은 `JS debugging` 영역으로 디버깅에 관련된 기능을 제공한다.\n\n내가 서론에서 서술한 문제를 해결하기 위해 사용한 `breakpoint` 는 매우 중요한 개념이며 말 그대로 JS 의 실행이 중단되는 코드 내 지점을 의미한다. 중단점을 이용하면 실행이 중지된 시점에 변수가 어떤 값을 담고 있는지 알 수 있고, 중지된 시점을 기준으로 명령어를 실행할 수도 있다.\n\n 위의 사진을 자세히 보면 나는 55번줄, 즉 외부 api 로부터 price 를 fetching 한 후 해당 값을 전역 state 에 할당하는 과정 바로 전에 데이터가 어떠한 형태로 들어왔는지 확인하기 위해 breakpoint 를 걸었다.\n\n 우측에 `Scope` 항목에 실제로 prices 애 array 가 들어왔고 해당 데이터를 자세히 확인할 수 있게 되었다. \n\n\n---\n\n## 결론\n\nChrome Dev Tool 에서 breakpoint 를 걸음으로서 스크립트 실행이 중지되면 중단 시점을 기준으로 변수에 어떤 값이 들어가 있는지 확인할 수 있다. 또한 단계별로 코드를 실행해 가며, 어디서 문제가 발생했는지 추적할 수도 있습다. 이런 식으로 디버깅을 진행할 수 있다.\n"},{"excerpt":"서론 가상화폐를 다루는 사이드 프로젝트를 하다가 사용자의  을 받아 검색결과에 맞는 가상화폐들만 보여주어야 하는 Search Input 을 구현하고 있었다.  해당 과정에서 사용자가 input 을 넣은 결과에 따라 output 을 도출해야 하지만, 사용자가 input 을 끝냈는지(마무리했는지) 에 대한 로직을 내가 직접 예측하기에는 무리라 생각이 들었다.…","fields":{"slug":"/react-debouncing/"},"frontmatter":{"date":"January 08, 2022","title":"리액트 디바운싱(debouncing)","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n가상화폐를 다루는 사이드 프로젝트를 하다가 사용자의 `Input` 을 받아 검색결과에 맞는 가상화폐들만 보여주어야 하는 Search Input 을 구현하고 있었다. \n\n해당 과정에서 사용자가 input 을 넣은 결과에 따라 output 을 도출해야 하지만, 사용자가 input 을 끝냈는지(마무리했는지) 에 대한 로직을 내가 직접 예측하기에는 무리라 생각이 들었다. \n\n그리하여 `onKeyUp` 을 활용하여 필터링을 하는 함수를 실행시키려 하였지만, 여기서 문제점은 사용자가 한글자를 타이핑 할때마다 해당 필터링 함수가 실행된다.\n\n여끼까지는 문제점이 크게 없지만 만약 해당 필터링 함수가 `외부 유로 api` 로부터 data 를 fetching 해야하는 동작을 한다면? 각각의 query 는 즉 돈이기 때문에 매우 비효율적인 동작으로 보인다. 물론 위와같은 경우에는 한번만 fetching 한 후 `global state` 로 관리를 하면 된다만 위의 예시 이외에도 다양한 resource 의 낭비를 초래하는 이유들이 많다.\n\n나는 이 문제를 해결하고자 `debounce`를 사용하였다.\n\n![](2022-01-08-20-30-25.png)\n\n\n\n---\n\n## 본론\n\n이벤트 발생과 그에따른 콜백함수를 다루는데 `debounce` 는 중요한 개념중의 하나라고 생각이 든다.\n\n단순 클릭이벤트처럼 단순하지 않고, 검색폼처럼 사용자의 키보드 입력이 지속적으로 발생하면 처리를 하지 않으면 과도한 api 요청을 보낼 수 있고 이는 곧 서버의 과부화까지 이어질 수 있다.\n\n위의 문제를 처리하기 위해 `debounce` 라는 개념을 사용하였다.\n\n> debouncing 은 연속된 이벤트 중 마지막 이벤트의 콜백함수만을 실행한다.\n\n리액트의 내장훅 중 하나인 `useEffect` 를 사용하여 직접 debouncing 을 구현하는 방법이 있지만, `lodash` 는 디바운싱을 사용하기 쉽게 만든 메소드가 존재하기에 이방식을 선택하였다.\n\n```js\nconst filterCoins = (e, setFilteredCoins, coinList) => {\n  let inputValue = e.target.value;\n//   handleFilter(inputValue, coinList, setFilteredCoins);\n    console.log(inputValue)\n};\n\nconst Search = () => {\n  return (\n    <AppContext.Consumer>\n      {({ setFilteredCoins, coinList }) => (\n        <SearchGrid>\n          <h2>Search all coins</h2>\n          <SearchInput\n            onKeyUp={(e) => filterCoins(e, setFilteredCoins, coinList)}\n          />\n        </SearchGrid>\n      )}\n    </AppContext.Consumer>\n  );\n};\n```\n\n위는 예시로 만든 debouncing 을 적용하지 않은 상태이며 만일 내가 'abc' 를 input 에 넣으면 콘솔에 'a', 'ab', 'abc' 즉 3번이 찍힌다.\n\n```js\nconst handleFilter = _.debounce((inputValue, coinList, setFilterCoins) => {\n  console.log(inputValue);\n}, 500);\n\nconst filterCoins = (e, setFilteredCoins, coinList) => {\n  let inputValue = e.target.value;\n  handleFilter(inputValue, coinList, setFilteredCoins);\n};\n```\n\n이를위해 debouncing 을 사요하는 `handleFilter` 함수를 추가로 만들어주었다. 결과적으로는 abc 를 타이핑하였을때 콘솔에 'abc' 한번만 찍히게 되었다.\n \n---\n\n## 결론\n\n사용자의 input 에 따른 함수를 실행할 때, 특히 해당 함수가 유료 API를 사용한다면 쿼리를 무분별하게 날리기 때문에, 비용적인 문제를 초래할 수 있기에 이를 방지하기 위해 debouncing 을 사용할 수 있다. debouncing 은 연이은 이벤트의 마지막에만 실행할 수 있는 환경을 만들어 준다. \n"},{"excerpt":"서론 Javascript 를 사용할때, 특정 DOM 을 선택하여 정보를 얻거나 임의로 조작해야 할때,  혹은  과 같은 DOM Selector 함수를 사용하여 DOM 을 선택하였다. 하지만, React 는 이 기능을 대체할 수 있는  훅을 제공한다. 본론 useRef는 .current 프로퍼티로 전달된 인자(initialValue)로 초기화된 변경 가능한…","fields":{"slug":"/useRef/"},"frontmatter":{"date":"January 04, 2022","title":"리액트 useRef","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\nJavascript 를 사용할때, 특정 DOM 을 선택하여 정보를 얻거나 임의로 조작해야 할때, `getElementById` 혹은 `querySelector` 과 같은 DOM Selector 함수를 사용하여 DOM 을 선택하였다. 하지만, React 는 이 기능을 대체할 수 있는 `useRef` 훅을 제공한다.\n\n---\n\n## 본론\n\n> useRef는 .current 프로퍼티로 전달된 인자(initialValue)로 초기화된 변경 가능한 ref 객체를 반환합니다. 반환된 객체는 컴포넌트의 전 생애주기를 통해 유지될 것입니다. 본질적으로 useRef는 .current 프로퍼티에 변경 가능한 값을 담고 있는 상자와 같습니다.\n\n리액트 공식문서에는 위와 같이 나와있고, 결국 나는 useRef 는 특정 DOM node 와 변수 자체를 담을 수 있는 상자라고 해석했다.\n\n그렇다면 왜 기존에 vanilla JS 에서 사용하던 친숙한 `querySelector` 를 지양하고 이를 대체하는 `useRef` 를 사용할까? 에 대해 검색을 해보았다.\n\n내가 해석한 결론은 React에서 `querySelector` 를 사용하게되면, 실제 DOM의 요소를 가져오게 된다. 하지만 React는 Virtual DOM을 통해 Real DOM을 그리기 때문에, React가 제어하고있는 Virtual DOM 안에 있는 요소가 더 신뢰할만하다. DOM API로 Real DOM에 있는 node 를 담았지만, 이게 현재 Virtual DOM을 통해 Real DOM에 존재하는 node 인지 아닌지 확신할 수 없다는 점이 크리티컬 하다고 생각한다.\n\n또한, React를 사용하게되면, 가장 중요한 개념 중 하나가 `State` 이다. React 내부에서 데이터는 컴포넌트 내의 State으로 조작된다. 즉, React가 State를 컨트롤(제어)하고 있다. 만약 이러한 React 시스템을 벗어나 DOM을 직접적으로 건드리게되면 이 내용들은 React가 제어하는 영역에서 벗어나게 되고, 이렇게 React의 제어를 벗어나게 되면, React에서 제공하는 이점들을 사용할 수 없게 된다.\n\n위에서 `useRef` 를 사용 이유에 대해 알아보았다면, 내가 생각하기에 `useRef` 의 이점은 `무분별한 react component 의 re-rendering 을 방지한다` 이다.\n\nReact 내에서 `re-rendering` 은 컴포넌트가 자신의 `state` 가 변경되거나, 부모에게서 받는 `props` 가 변경될 때마다\n컴포넌트를 다시 호출하여 실행하는 현상을 말한다. re-rendering 시에 컴포넌트 내부의 state 과 function 또한 `재선언` 이\n이루어지기에, 무분별한 re-rendering은 결국 resource 낭비라고 생각이 든다.\n\n결국 `useRef` 가 어떻게 `무분별한 re-rendering` 을 방지하는가에 대해서는 useRef 가 담을 수 있는 변수에 답이 있다.\n이는 독단적인 `변수` 그 자체이기에, 값이 바뀐다고 해도 컴포넌트가 re-rendering 되는 트리거로 작동하지 않는다.\n\n```js\nimport \"./App.css\"\nimport { useState } from \"react\"\n\nfunction App() {\n  const [username, setUsername] = useState(\"\")\n  const handleChange = e => {\n    setUsername(e.target.value)\n    console.log(username)\n  }\n\n  console.log(\"rendered\")\n\n  return (\n    <div className=\"box\">\n      <input type=\"text\" onChange={handleChange} />\n      {username}\n    </div>\n  )\n}\n\nexport default App\n```\n\n위의 예시는 컴포넌트의 re-rendering 을 감지하기 위해 예시로 짠 코드이다. `console.log('rendered')` 로 인하여\n컴포넌트가 초기에 렌더링될때 한번 콘솔에 찍히고, re-rendering 될때마다 매번 rendered 가 찍히게 된다.\n또한, input 에 넣는 값에따라 handleChange 함수로 인하여 username 의 state 를 변경하게 된다. 즉, 값이 변경될 때마다\nstate 가 변하게 되고 이는 즉, re-rendering 을 일으킨다는 것이다.\n\n![](2022-01-04-18-34-15.png)\n\n위와같이 테스트 결과 state 이 변할때마다 re-rendering 이 일어났다.\n\n```js\nimport \"./App.css\"\nimport { useRef, useState } from \"react\"\nimport React from \"react\"\n\nfunction App() {\n  const inputRef = useRef(0)\n  const [user, setUser] = useState([])\n\n  const addUser = () => {\n    setUser([...user, { name: inputRef.current.value }])\n  }\n\n  console.log(\"rendered\")\n\n  return (\n    <div className=\"box\">\n      <input type=\"text\" ref={inputRef} />\n      <button onClick={addUser}>add user</button>\n      <div>\n        {user.map((user, idx) => {\n          return <h4 key={idx}>{user.name}</h4>\n        })}\n      </div>\n    </div>\n  )\n}\n\nexport default App\n```\n\n이를 위해 위와 같이 `useRef` 를 사용하는 방식으로 리팩토링 해보았고, 직접 값을 추출하여 유저를 추가 및, `map()` 을\n사용하여 화면에 유저들을 띄우는 코드로 바꾸었다.\n\n![](2022-01-04-19-04-04.png)\n\n테스트 결과, 처음 렌더링 될때 한번, 3명의 유저를 추가하였을때 각각 한번씩, 총합 4번의 'rendered' 콘솔이 찍혔다.\n\n---\n\n## 결론\n\n리액트는 `virtual DOM` 을 사용하기 때문에 특정 DOM 을 선택할때 Vanilla JS 에서 사용하던 방식인 `querySelector`\n를 사용하는 방식을 지양해야 한다. 이를 대체하기 위해 `useRef` 를 사용하게 되는데, 개념은 비슷하지만 내부에 따로 변수또한\n담을 수 있고, 이를 유용하게 사용할 수 있다.\n"},{"excerpt":"서론 나는  을 사용하다가 유료이기도 하고, 나름 에 비교하면 무겁다고 체감이 되어 다시  로 돌아왔는데, \nwebstorm 에서는 훅을 사용할때 따로 import 를 해주지 않더라도 자동적으로 import 를 해주어 이 기능이 대단하단것을 몰랐다.\n따라서, VSC 에서도  기능을 사용 할 수 없는지에 대해 구글링을 해보았다. 본론 결론적으로는 쉽게 가능…","fields":{"slug":"/vsc-react-autoimport/"},"frontmatter":{"date":"January 03, 2022","title":"VSC 리액트 auto import","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n나는 `webstorm` 을 사용하다가 유료이기도 하고, 나름 `VSC`에 비교하면 무겁다고 체감이 되어 다시 `VSC` 로 돌아왔는데, \nwebstorm 에서는 훅을 사용할때 따로 import 를 해주지 않더라도 자동적으로 import 를 해주어 이 기능이 대단하단것을 몰랐다.\n따라서, VSC 에서도 `auto import` 기능을 사용 할 수 없는지에 대해 구글링을 해보았다.\n\n---\n\n## 본론\n\n결론적으로는 쉽게 가능하다. 루트 디렉토리에 `jsconfig.json` 파일을 생성한 후 아래의 내용을 넣어주면 된다.\n\n```json\n{\n\t\"compilerOptions\": {\n\t\t\"module\": \"commonjs\",\n\t\t\"target\": \"es6\",\n\t\t\"checkJs\": true,\n\t\t\"jsx\": \"react\"\n\t},\n\t\"exclude\": [\"node_modules\"]\n}\n\n```\n\n\n"},{"excerpt":"서론 종종 리액트 공부를 하다보면  문법을 사용할 것이기 때문에  와 같이 리액트를\nimport 해주어야 한다는 말들을 들었다. 하지만 생각해보면 나는 딱히 리액트로 프로젝트를 진행할때, JSX 문법을 사용해야 한다 하더라도 컴포넌트마다 리액트를 import 하는\n행위는 따르지 않고도 문제가 발견되지 않았었다. 본론 이에따라  와  을 통하여 찾아보니, …","fields":{"slug":"/import-react/"},"frontmatter":{"date":"January 02, 2022","title":"importing React 와 JSX 사용의 상관관계","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n종종 리액트 공부를 하다보면 `JSX` 문법을 사용할 것이기 때문에 `import React from 'react'` 와 같이 리액트를\nimport 해주어야 한다는 말들을 들었다.\n\n하지만 생각해보면 나는 딱히 리액트로 프로젝트를 진행할때, JSX 문법을 사용해야 한다 하더라도 컴포넌트마다 리액트를 import 하는\n행위는 따르지 않고도 문제가 발견되지 않았었다.\n\n---\n\n## 본론\n\n이에따라 `stack overflow` 와 `구글링` 을 통하여 찾아보니, 결국 이는 과거에 행해졌던 일종의 `관습` 이라고 나는 판단하였다.\n\n리액트 공식문서에 따르면, JSX 를 사용할때 더는 import react 를 하지 않아도 된 이유는 결국 새로운 `JSX Transform` 때문이라고 한다.\n\n리액트 17버전 부터 새로운 `JSX Transform` 을 사용할 수 있는데,\n\n이는 React 를 import 하지 않고도 JSX 문법을 사용 가능하게 해주며,\n\n세팅에 따라서, bundle size 자체를 미세하게 나마 줄여줄 수 있다.\n\n### 이전 방식과의 차이\n\n```javascript\nimport React from \"react\"\n\nfunction App() {\n  return <h1>Hello World</h1>\n}\n```\n\n이전의 방식으로는 위와같은 JSX 코드를 컴파일러가 브라우저가 이해할 수 있게 컴파일을 해주었다.\n\n```js\nimport React from \"react\"\n\nfunction App() {\n  return React.createElement(\"h1\", null, \"Hello world\")\n}\n```\n\n이를 (Old JSX Transform), 자바스크립트 방식으로 바꾼다면 위와 같은 모양을 띄울 것이다.\n\n```js\nfunction App() {\n  return <h1>Hello World</h1>\n}\n```\n\n```js\nimport { jsx as _jsx } from \"react/jsx-runtime\"\n\nfunction App() {\n  return _jsx(\"h1\", { children: \"Hello world\" })\n}\n```\n\n하지만 `React 17`에 포함되어있는 `New JSX Transform` 으로 인하여, 더는 리액트는 JSX 를 `React.createElement` 로 변환하지 않고, 리액트 패키지 자체의 함수를 불러와 위와같이 작동하게된다.\n\n---\n\n## 결론\n\n리액트 17버전 이전에는, JSX 문법을 사용하기 위하여 React 를 import 했던것은 사실이다.\n\n하지만, 리액트 17버전에 출시된 NEW JSX Transform 으로 인하여, 기존에 JSX 코드를 React.createElement 로 변환하여 사용하는 방식이 아닌, 자체적으로 리액트 패키지의 엔드포인트로부터 변환하는 함수를 호출하여 변환하기에 리액트 17 버전 이상을 사용한다면, JSX 문법을 사용하기위해 더이상은 React 를 굳이 import 해줄 필요는 없다.\n"},{"excerpt":"서론 평소 프로젝트를 진행할때, 리액트를 사용한 Client 단만을 만들었는데, 나는 Express.js 에 대한 이해가 어느정도 있긴 하였다. 하지만 항상 느꼈던 점은 어떻게 Server(Node.js) 단과, Client(React ) 단을 동시에 연결할지를 몰랐었고, 알게된 과정을 기록하려 한다. 본론 내가 사용한 모듈 : Express nodemo…","fields":{"slug":"/connecting-server-client/"},"frontmatter":{"date":"December 27, 2021","title":"React && Node.js 연결하기","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n평소 프로젝트를 진행할때,\n\n리액트를 사용한 Client 단만을 만들었는데, 나는 Express.js 에 대한 이해가 어느정도 있긴 하였다.\n\n하지만 항상 느꼈던 점은 어떻게 Server(Node.js) 단과, Client(React ) 단을 동시에 연결할지를 몰랐었고, 알게된 과정을 기록하려 한다.\n\n---\n\n## 본론\n\n###내가 사용한 모듈 : \n - Express\n - nodemon\n - cocurrently\n - react\n - http-proxy-middleware\n \n##### Express :\n\n`Express`란 Node.js를 사용하여 쉽게 서버를 구성할 수 있게\n만든 클래스와 라이브러리의 집합체 이다.\n\n##### nodemon:\n\n`nodemon`이란 Node.js에 기반한 웹 어플리케이션을 개발할 때, 파일에 변경사항이 발생했을 때마다, 저절로 어플리케이션이 재실행되도록\n도와주는 패키지이다. \n\n##### cocurrently:\n\n`cocurrenly`란 명령어를 동시에 실행시켜주는 모듈이다.\n\n##### http-proxy-middleware:\n\n`http-proxy-middleware`란 여러 개의 프록시를 등록하고 옵션을 줄 때 편리하게 도와주는 모듈이다.\n\n![](.index_images/71c59333.png)\n\n---\n\n### 디렉토리 생성 및 필요 모듈 설치\n\n```\n$ mkdir my-app\n$ cd my-app\n$ echo node_modules > .gitignore\n$ npm init -y\n$ npm install express nodemon concurrently\n```\n\n서버로 사용할 `index.js` 파일을 생성 후 아래 내용을 입력해준다.\n\n```javascript\n// express 모듈 불러오기\nconst express = require(\"express\");\n\n// express 객체 생성\nconst app = express();\n\n// 기본 포트를 app 객체에 설정\nconst port = process.env.PORT || 5000;\napp.listen(port);\n\n// 미들웨어 함수를 특정 경로에 등록\napp.use(\"/api/data\", function (req, res) {\n  res.json({ greeting: \"Hello World\" });\n});\n\nconsole.log(`server running at http ${port}`);\n```\n\n루트 디렉토리의 `package.json` 파일에 아래의 script 를 추가해준다.\n\n```javascript\n\"scripts\": {\n  \"start\": \"nodemon index.js\"\n}\n```\n\n### CRA 를 사용한 Client단 생성 및 초기화\n\n```\n$ create-react-app client --use-npm --template typescript\n```\n\n### 프록시 설정\n\n`client` 디렉토리로 이동하여 `http-proxy-middleware` 를 설치한다.\n\n```\n$ cd client\n$ npm install http-proxy-middleware\n```\n\n설치 후 `/client/src` 디렉토리에 `setupProxy.js` 파일을 생성 후 아래의 내용을 작성한다.\n\n```javascript\nconst { createProxyMiddleware } = require(\"http-proxy-middleware\");\n\nmodule.exports = function (app) {\n  app.use(\n    createProxyMiddleware(\"/api/data\", {\n      target: \"http://localhost:5000\",\n      changeOrigin: true,\n    })\n  );\n};\n```\n\n### 서버(Express), 클라이언트(React) 동시 시작 설정\n\n루트 디렉토리의 `package.json` 의 스크립트를 다음과 같이 수정한다.(cocurrently 사용)\n\n```\n\"scripts\": {\n  \"start\": \"nodemon index.js\",\n  \"dev\": \"concurrently \\\"npm run dev:server\\\" \\\"npm run dev:client\\\"\",\n  \"dev:server\": \"npm start\",\n  \"dev:client\": \"cd client && npm start\"\n}\n```\n\n### 검색 폼 및 리스트 추가(임시 컴포넌트)\n\n`/client/src/` 디렉토리에 components 폴더를 생성하고 SearchForm.tsx, SearchList.tsx 파일을 생성하고 각각 아래처럼 입력해 준다.\n\n#### SearchForm.tsx\n\n```javascript\nconst fetchApi = () => {\n  fetch('api/data')\n    .then((res) => {\n      return res.json();\n    })\n    .then((data) => {\n      console.log(data);\n    });\n};\n\nconst SearchForm = () => {\n  return (\n    <div className=\"form\">\n      <input type=\"text\" className=\"form-text\" />\n      <button type=\"button\" className=\"form-btn\" onClick={fetchApi}>\n        search\n      </button>\n    </div>\n  );\n};\n\nexport default SearchForm;\n```\n\n#### SearchList.tsx\n\n```javascript\nimport React from \"react\";\n\nconst SearchList = () => {\n  return (\n    <div className=\"card-list\"></div>\n  );\n};\n\nexport default SearchList;\n```\n\nApp.tsx 변경\n\n```javascript\nimport React from \"react\";\nimport SearchForm from \"./components/SearchForm\";\nimport SearchList from \"./components/SearchList\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SearchForm />\n      <SearchList />\n    </div>\n  );\n}\n\nexport default App;\n```\n`search` 버튼을 클릭하면 `fetch` 함수로 `서버(http://localhost:5000/api/data)`에 요청을 하게 되고 응답값으로 콘솔창에 `{ greeting: \"Hello World\" }`가 출력되는 것을 확인할 수 있다.\n\n\n\n\n\n\n---\n\n\n\n\n\n\n\n"},{"excerpt":"서론 대부분 React 앱들은 ,  또는  같은 Bundling Tool 을 사용하여 여러 파일을 하나로 병합한  을 웹 패이지에 포함하여 \n한번에 전체 앱을 로드 할 수 있다. 예시) App Bundle 위의 예시는 어떠한 방식으로 Bundling 을 하는지에 대한 예시일 뿐이다. (실제와는 많이 다르다)\n 나  와 같은 툴을 사용한다면 이미 App 자…","fields":{"slug":"/react-code-splitting/"},"frontmatter":{"date":"December 18, 2021","title":"React - 코드 분할","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n대부분 React 앱들은 `Webpack`, `Rollup` 또는 `Browserify` 같은 Bundling Tool 을 사용하여 여러 파일을 하나로 병합한 `Bundled file` 을 웹 패이지에 포함하여 \n한번에 전체 앱을 로드 할 수 있다.\n\n#### 예시)\n\n##### App\n\n```javascript\n// app.js\nimport { add } from './math.js';\n\nconsole.log(add(16, 26)); // 42\n```\n\n```javascript\n// math.js\nexport function add(a, b) {\n  return a + b;\n}\n```\n\n##### Bundle\n\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n\nconsole.log(add(16, 26)); // 42\n```\n\n위의 예시는 어떠한 방식으로 Bundling 을 하는지에 대한 예시일 뿐이다. (실제와는 많이 다르다)\n`CRA` 나 `Next.js` 와 같은 툴을 사용한다면 이미 App 자체에 `Webpack` 이 설치되어 있을것이다.\n\n'흩어져 있는 파일들을 압축하여 bundling size 를 줄인다.' 라는 명목 자체는 매우 훌륭하지만, 앱이 커질수록 \n해당 번들도 커질 가능성이 농후하다. 특히 큰 사이즈의 3rd party library 를 사용하였을떄는 번들 사이즈 또한 커지기 때문에\n로드 시간이 길어지고 이는 곧 웹서비스의 성능에 악영향을 끼친다.\n\n번들이 거대해지는 것을 방지하기 위해서 `code splitting` 을 고민해보아야 한다. 코드분할은 앱을 `지연로딩` 하게 도와주고, 이는 \n앱의 코드 양을 줄이지 않고도 사용자가 필요하지 않은 코드를 불러오지 않게 하며 앱의 initializing 에 필요한 loading resource 자체를 줄여준다.\n\n---\n\n## 본론\n\n### import()\n\nApp 에 code splitting 을 도입하는 방식중 하나는 `동적 import()` 를 사용하는 것이다.\n\n#### Before\n\n```javascript\nimport { add } from './math';\n\nconsole.log(add(16, 26));\n```\n\n#### After \n\n```javascript\nimport(\"./math\").then(math => {\n  console.log(math.add(16, 26));\n});\n```\n\n`Webpack` 이 해당 구문을 만나게 되면 자체적으로 앱의 Code 를 Splitting 한다.\n\n하지만, `Babel` 을 사용한다면 Babel 은 위와같은 동적 import 를 `인식` 할수는 있지만, 자체적으로 `분할` 하지는 않는다.\n그에따라, `babel-plugin-synyax-dynamic-import` 를 사용해야만 한다.\n\n\n### React.lazy\n\n`React.lazy` 함수를 사용하 동적 import 를 사용하여 컴포넌트를 렌더링 할 수 있다.\n\n#### Before\n\n```javascript\nimport ExpampleConponent from './ExpampleConponent';\n```\n\n#### After\n\n```javascript\nconst Main = lazy(() => import(\"./components/Main\"));\nconst AboutPage = lazy(() => import(\"./components/AboutPage\"));\nconst MySkillsPage = lazy(() => import(\"./components/MySkillsPage\"));\n```\n\n### Entire Code\n\n```javascript\nconst Main = lazy(() => import(\"./components/Main\"));\nconst AboutPage = lazy(() => import(\"./components/AboutPage\"));\nconst MySkillsPage = lazy(() => import(\"./components/MySkillsPage\"));\nconst BlogPage = lazy(() => import(\"./components/BlogPage\"));\nconst WorkPage = lazy(() => import(\"./components/WorkPage\"));\nconst SoundBar = lazy(() => import(\"./subComponents/SoundBar\"));\n\nfunction App() {\n  const location = useLocation();\n\n  return (\n    <>\n      <GlobalStyle />\n\n      <ThemeProvider theme={lightTheme}>\n        <Suspense fallback={<Loading />}>\n          <SoundBar />\n\n          <AnimatePresence exitBeforeEnter>\n            <Switch location={location} key={location.pathname}>\n              <Route exact path=\"/\" component={Main} />\n\n              <Route exact path=\"/about\" component={AboutPage} />\n\n              <Route exact path=\"/blog\" component={BlogPage} />\n\n              <Route exact path=\"/work\" component={WorkPage} />\n\n              <Route exact path=\"/skills\" component={MySkillsPage} />\n            </Switch>\n          </AnimatePresence>\n        </Suspense>\n      </ThemeProvider>\n    </>\n  );\n}\n```\n\n`App` Component 가 처음 rendering 될때, 내부에 속한 번들을 자동으로 불러온다.\n\n`React.lazy` 는 동적 import() 를 호출하는 함수를 인자로 가진다. 이 함수는 React 컴포넌트를 포함하여 `default export ` 를 \n가진 모둘로 결정되는 `Promise` 를 반환해야 한다.\n\n또한, `lazy component` 는 `Suspense component` 하위에서 rendering 되어야하며, `Suspense` 는 `lazy component`  \n가 로드되길 기다리는 동안 로딩 화면과 같은 예비 컨텐츠를 보여줄 수 있게 해준다.\n\n마지막의 Entire Code 에서 주목해야 할 점은, 그래서 Code Splitting 을 도대체 어느 곳에 도입하여야 한다는 점이다.\n나는 이를 시작하는 좋은 장소는  `Route` 라고 생각하여 해당 코드를 작성하였다. 아무리 `SPA` 라고 할지라도,  page transition 이 발생하는 부분에서\nloading 시간은 필연적으로 발생하며 대부분의 페이지를 한번에 렌더링하기에 사용자가 페이지를 렌더링 하는 동안 다른 요소와 상호작용 또한 하지 않기 때문이다.\n\n---\n\n## 결론\n\nBundling 툴은 보통 코드를 압축하기에 이에따른 import 하는 과정에서 너무 많은 리소스를 낭비 할 수 있기에,\n이부분에 대해서는 code splitting 이 유용하게 쓰인다. \n\n이 과정에서 동적으로 import() 함수를 쓰는 방법이 존재하지만, page transition 시간에 다른 예비 요소를 사용할 수 있기에\n나는 주로 Route 에 Suspense 와 lazy 를 사용하는 방법을 좋아한다.\n\n\n\n\n"},{"excerpt":"Intro 5번째 Mini Vanilla Js Project 이다. 이번에는  라는  를 사용하여 개인자산 체크 기능을 만들어보았다! Main 소스코드 liveDemo  Conclusion JS 에서 가장 흔하게 사용되는? 메서드인 , , , 를 주축으로 구현을 해보았다. 간편화를 위해, input 으로 user 정보를 받는것이 아닌, 외부 api 를 사…","fields":{"slug":"/personal-information-list/"},"frontmatter":{"date":"November 28, 2021","title":"개인자산 체크 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n5번째 Mini Vanilla Js Project 이다.\n\n이번에는 `Random User Generator-API` 라는 `Third-party api` 를 사용하여 개인자산 체크 기능을 만들어보았다!\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Personal-Information-List)\n- [liveDemo](https://hwani-vanillajs.netlify.app/personal-information-list/)\n\n\n![](personal.gif)\n\n---\n\n## Conclusion\n\nJS 에서 가장 흔하게 사용되는? 메서드인 `sort`, `filter`, `reduce`, 를 주축으로 구현을 해보았다.\n\n간편화를 위해, input 으로 user 정보를 받는것이 아닌, 외부 api 를 사용하여 쉽게 예시 user 를 추가 할 수 있게 했고,\n\n이를 좌축의 aside button 들에 event mapping 해놓았다.\n\n가장 고민했던 부분은, event 가 실행되어 유저가 추가되었을때, 유저의 데이터가 변할때 어떤 방식으로 DOM 자체를 refresh 없이 re-rendering 시킬것인가 였다.\n\nReact 는 Virtual DOM 을 사용하여 Diff 를 파악한 후, 변경점이 필요한 부분만 바꾸어주는 방식을 사용하지만, Vanilla JS 로 이를 직접 구현하기에는 나중에 내 기준에서는 (대형..?) 프로젝트 및 과제로 미루어두고,\n\n우선은 state 를 가지고 있는 화면단을 하나의 배열로 관리하며, 해당 state 가 변경될 때, 통째로 re-rendering 하는 방식으로 구현하였다. \n\n이번에도 느낀것이지만, vanillaJS 프로젝트를 진행할때마다, framework 이 자체적으로 가지고 있는 기능 혹은 library 가 대신 해주었던 기능들을 직접 사소하나마 찾아가며 구현하며 내 프로젝트와의 차이점을 찾고, 해당 framework 이나 library 의 기능들의 작동 방식을 차차 알아갈 수 있다는 점이 아직은 재밌게 느껴졌다!"},{"excerpt":"Intro 6번째 Mini Vanilla Js Project 이다. 이번에는 순수  와  를 사용하여 Sidebar 와 Modal 을 직접 구현해보았다. Main 소스코드 liveDemo  Conclusion 사실 내가 프로젝트를 진행할때  를 사용했던 이유는 style 적인 이유보다는 JS? 적인 이유가 더 컸다.\n이 뜻은, UI Library 를 사용…","fields":{"slug":"/menu-sidebar-modal/"},"frontmatter":{"date":"November 28, 2021","title":"사이드바, 모달 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n6번째 Mini Vanilla Js Project 이다.\n\n이번에는 순수 `css` 와 `vanilla JS` 를 사용하여 Sidebar 와 Modal 을 직접 구현해보았다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Menu-Sidebar-Modal)\n- [liveDemo](https://hwani-vanillajs.netlify.app/menu-sidebar-modal/)\n\n\n![](modal.gif)\n\n---\n\n## Conclusion\n\n사실 내가 프로젝트를 진행할때 `UI Library` 를 사용했던 이유는 style 적인 이유보다는 JS? 적인 이유가 더 컸다.\n이 뜻은, UI Library 를 사용할때도 보통 style 적인 부분은 모두 갈아엎으며 나의 입맛대로 꾸몄지만, 예를 들어,\n\n- 'x' 표시를 누르면 모달이 닫힌다.\n- 모달 바깥의 영역을 누르면 부드럽게 animation 과 함께 자연스럽게 닫힌다.\n- 사이드바 햄버거 아이콘을 누르면 자연스럽게 화면이 이동하며 sidebar 가 펼쳐진다\n\n와 같은 기능적인 부분에 대해 무지했기때문에 이런부분은 주로 library 에 의존하곤 했다.\n\n하지만, 지속적인 구글링과 공부 끝에, 이번 기회에 노력하면 해볼 수 있지 않을까? 라는 결론에 도달했고, \n나의 기대치에 맞는 화면을 직접 구성 할 수 있게 되었다. \n\n결론적으로는, 사실 JS 부분은 복잡하지 않고 간단하지만, 주로 CSS 적인 변화와 움직임을 toggle 로 컨트롤하면서 여러가지 상황에 대처할 수 있게 구현하는 방식을 택하였다."},{"excerpt":"Intro 4번째 Mini Vanilla Js Project 이다. 이번에는  라는  를 사용하여 환전 기능을 만들어보았다! Main 소스코드 liveDemo  Conclusion 처음으로 vanillaJS 를 사용하며, third-party api 를 사용해보았다. 기존에 리액트를 배우고 사용했을때는 데이터를 요청하는 방식 자체에 대해서 당연하게 고민도…","fields":{"slug":"/exchange-rate-calculator/"},"frontmatter":{"date":"November 27, 2021","title":"환전기 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n4번째 Mini Vanilla Js Project 이다.\n\n이번에는 `ExchangeRate-API` 라는 `Third-party api` 를 사용하여 환전 기능을 만들어보았다!\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Exchange-Rate-Calculator)\n- [liveDemo](https://hwani-vanillajs.netlify.app/exchange-rate-calculator/)\n\n\n![](exchange-cal.gif)\n\n---\n\n## Conclusion\n\n처음으로 vanillaJS 를 사용하며, third-party api 를 사용해보았다.\n\n기존에 리액트를 배우고 사용했을때는 데이터를 요청하는 방식 자체에 대해서 당연하게 고민도 하지 않은채 마구잡이로 남들이 사용하는 방식대로 `request` 나 `axios` 를 썼었는데,\n\n이번 프로젝트를 진행하며, 브라우저가 자체적으로 `fetch()` 함수를 지원한다는 것을 배웠고, 이를 사용해보았다. 결과는 내 기준에서는 성공적이였고, 고민을 해보았던 점은, 결국 `request`, `axios` 도 같은 `Http 비동기 통신 library` 일텐데\n\n이들을 대체할 수 있는 내장 함수인 `fetch()` 를 main 으로 사용한다면 `js bundling size` 면에서 유리하지 않을까 였다.\n\n이 문제에 대해 찾아본 결과, 내 생각대로라면 `fetch()` 를 main 으로 쓰는것이 바람직 할 수 있겠지만, \n\n- 지원하지 않는 브라우저가 있다  (...IE11)\n- 네트워크 에러 발생 시 response timeout 없이 기다려야한다.\n- JSON 으로 변환해주는 과정이 필요하다.\n\n위 세가지의 단점때문에 아직 외부 라이브러리들을 사용을 한다는 의견이 많고,  나의 실력으로써는 더 많이 경험하고 써보면서 각자의 장단점을 몸소 직접 체험하는 수밖에 없을 것 같다."},{"excerpt":"Intro 새번째 Mini Vanilla Js Project 이다. video api 를 사용하여 비디오 플레이어를 만들어 보았다. Main 소스코드 liveDemo  Conclusion 각 버튼들과 상황에 따른 전반적인 동작 원리와 기능들을 직접 공부하고 구현하려다 보니, 간단할지라도 배우는점이 많았다.  이제 앞으로 프로젝트를 진행하며  태그를 사용해…","fields":{"slug":"/custom-video-player/"},"frontmatter":{"date":"November 27, 2021","title":"비디오 플레이어 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n새번째 Mini Vanilla Js Project 이다.\n\nvideo api 를 사용하여 비디오 플레이어를 만들어 보았다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Custom-Video-Player)\n- [liveDemo](https://hwani-vanillajs.netlify.app/custom-video-player/)\n\n\n![](vid-player.gif)\n\n---\n\n## Conclusion\n\n각 버튼들과 상황에 따른 전반적인 동작 원리와 기능들을 직접 공부하고 구현하려다 보니, 간단할지라도 배우는점이 많았다. \n\n이제 앞으로 프로젝트를 진행하며 `video` 태그를 사용해야 할때 겁먹지 않기를 바라며 ㅎㅎ"},{"excerpt":"Intro 두번째 Mini Vanilla Js Project 이다. 이번에는 간단하게 영화 좌석 선택을 만들어보았고, 전과 다른점이 있다면, 이번에는  를 사용하여,  된 후에도 데이터가 남아있게 하였다. Main 소스코드 liveDemo  Conclusion Vanilla JS 프로젝트를 진행하면서,  를 사용할때도,  속성을 사용할 수 있다는 것을 배…","fields":{"slug":"/movie-seat-booking/"},"frontmatter":{"date":"November 26, 2021","title":"영화 좌석 선택 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n두번째 Mini Vanilla Js Project 이다.\n\n이번에는 간단하게 영화 좌석 선택을 만들어보았고, 전과 다른점이 있다면,\n\n이번에는 `localStorage` 를 사용하여, `refresh` 된 후에도 데이터가 남아있게 하였다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Movie-Seat-Booking)\n- [liveDemo](https://hwani-vanillajs.netlify.app/form-validator/)\n\n\n![](movie-seat.gif)\n\n---\n\n## Conclusion\n\nVanilla JS 프로젝트를 진행하면서, `document.querySelector` 를 사용할때도, `not()` 속성을 사용할 수 있다는 것을 배웠고, \n\nlocalStorage 에서 데이터가 어떤식으로 들어가고 나오는지에 대해 깨달은 점도 존재하다. 더불어 CSS 공부도 나름 열심히 하게 되는 것 같다!\n\n"},{"excerpt":"Intro 리액트를 공부하거나, 프로젝트를 했으로때 주로 간단한 ui 적인 부분은 라이브러리를 사용하여 해결 했었지만, vanilla JS 를 사용하여 내가 직접 가능한 부분은 공부하여 만들어 보려고 하였다. Main 소스코드 liveDemo  HTML JS","fields":{"slug":"/vainllajs-registration-form/"},"frontmatter":{"date":"November 24, 2021","title":"회원가입 폼 with Vanilla JS","tags":["VanillaJS"]},"rawMarkdownBody":"\n## Intro\n\n리액트를 공부하거나, 프로젝트를 했으로때 주로 간단한 ui 적인 부분은 라이브러리를 사용하여 해결 했었지만, vanilla JS 를 사용하여 내가 직접 가능한 부분은 공부하여 만들어 보려고 하였다.\n\n---\n\n## Main\n\n- [소스코드](https://github.com/sh981013s/Projects-with-VanillaJs/tree/main/Form-Validator)\n- [liveDemo](https://hwani-vanillajs.netlify.app/form-validator/)\n\n\n![](form_val.gif)\n\n---\n\n## HTML\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\"\n        content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <link rel=\"stylesheet\" href=\"./styles.css\">\n  <title>Form Validator</title>\n</head>\n<body>\n<div class=\"container\">\n  <form action=\"\" id=\"form\" class=\"form\">\n    <h2>Register With Us</h2>\n    <div class=\"form-control\">\n      <label for=\"username\">Username</label>\n      <input type=\"text\" id=\"username\" placeholder=\"Enter username\">\n      <small>Error message</small>\n    </div>\n    <div class=\"form-control\">\n      <label for=\"email\">Email</label>\n      <input type=\"text\" id=\"email\" placeholder=\"Enter email\">\n      <small>Error message</small>\n    </div>\n    <div class=\"form-control\">\n      <label for=\"password\">Password</label>\n      <input type=\"password\" id=\"password\" placeholder=\"Enter password\">\n      <small>Error message</small>\n    </div>\n    <div class=\"form-control\">\n      <label for=\"password\">Confirm Password</label>\n      <input type=\"password\" id=\"password2\" placeholder=\"Enter password again\">\n      <small>Error message</small>\n    </div>\n    <button>Submit</button>\n  </form>\n</div>\n<script src=\"script.js\"></script>\n</body>\n</html>\n```\n\n## JS\n\n```javascript\nconst form = document.getElementById('form');\nconst username = document.getElementById('username');\nconst email = document.getElementById('email');\nconst password = document.getElementById('password');\nconst password2 = document.getElementById('password2');\n\n// Show input error message\nconst showError = (input, message) => {\n  const formControl = input.parentElement;\n  formControl.className = 'form-control error';\n  const small = formControl.querySelector('small');\n  small.innerText = message;\n}\n\n// Show success outline\nconst showSuccess = (input) => {\n  const formControl = input.parentElement;\n  formControl.className = 'form-control success';\n}\n\n// Check email is valid\nconst isValidEmail = (email) => {\n  const re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  if (re.test(email.value)) {\n    showSuccess(email)\n  } else {\n    showError(email, 'Email is not valid');\n  }\n}\n\n// Get field name\nconst getFieldName = (input) => {\n  return input.id.charAt(0).toUpperCase() + input.id.slice(1);\n}\n\n// Check required fields\nconst checkRequired = (inputArr) => {\n  inputArr.forEach(input => {\n    if (input.value.trim() === '') {\n      showError(input, `${getFieldName(input)} is required`);\n    } else {\n      showSuccess(input);\n    }\n  })\n}\n\n// Check input length\nconst checkLength = (input, min, max) => {\n  if (input.value.length < min) {\n    showError(input, `${getFieldName(input)} must be at least ${min} characters`)\n  } else if (input.value.length > max) {\n    showError(input, `${getFieldName(input)} must be at less than ${max} characters`)\n  }\n}\n\n// Check passwords match\nconst checkPasswordsMatch = (input1, input2) => {\n  if(input1.value !== input2.value) {\n    showError(input2, 'Password do not match');\n  }\n}\n\n// Event listeners\nform.addEventListener('submit', e => {\n  e.preventDefault();\n\n  checkRequired([username, email, password, password2]);\n  checkLength(username, 8, 15);\n  checkLength(password, 6, 25);\n  isValidEmail(email);\n  checkPasswordsMatch(password, password2);\n});\n```"},{"excerpt":"백준 1653번 링크 풀이 처음에는 해멧지만, 이후에 \n전형적인 이분탐색 문제라고 판단이 들었다. 이분탐색이란, 탐색 범위를 두 부분으로 분할해서 찾는 방식으로,    값을 잡아서 탐색한다.","fields":{"slug":"/baekjoon-1654/"},"frontmatter":{"date":"November 22, 2021","title":"[BOJ] 1654 랜선 자르기 (Node.js)","tags":["BOJ"]},"rawMarkdownBody":"\n<a href=\"https://www.acmicpc.net/problem/1654\" target=\"_blank\">백준 1653번 링크</a>\n\n## 풀이\n\n처음에는 해멧지만, 이후에 \n전형적인 이분탐색 문제라고 판단이 들었다.\n\n이분탐색이란, 탐색 범위를 두 부분으로 분할해서 찾는 방식으로, `max` `min` `mid` 값을 잡아서 탐색한다.\n\n```javascript\n'use strict';\n\n(() => {\n\tconst fs = require('fs');\n\tconst input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');\n\n\tconst [n, k] = input\n\t\t.shift()\n\t\t.split(' ')\n\t\t.map((a) => +a);\n\tconst lines = input.map((a) => +a).sort();\n\n\tlet max = Math.max(...lines);\n\tlet min = 1;\n\n\twhile (min <= max) {\n\t\tlet mid = parseInt((max + min) / 2);\n\t\tlet howManyPieces = lines\n\t\t\t.map((line) => parseInt(line / mid))\n\t\t\t.reduce((a, b) => a + b, 0);\n\t\tif (howManyPieces >= k) {\n\t\t\tmin = mid + 1;\n\t\t} else {\n\t\t\tmax = mid - 1;\n\t\t}\n\t}\n\n\tconsole.log(max);\n})();\n\n```"},{"excerpt":"SEO 란? SEO 는  의 약자로써, 구글 등 여러 Search Engine 의 상위 노출을 위한  검색엔진 최적화이다. 과정 SEO 를 위해 위와 같이 필요한 정보들을 입력해주었고,  에서 데이터 분석 및, 동작이 제대로 되는지에 대한   정보를 위해,  또한 추가해주었다.  또한,  을 작성하고 제출하여, 정상적으로 search engine 이 나의…","fields":{"slug":"/blog-SEO/"},"frontmatter":{"date":"November 21, 2021","title":"블로그 SEO","tags":["Blog"]},"rawMarkdownBody":"\n## SEO 란? \n\nSEO 는 `Search Engine Optimization` 의 약자로써, 구글 등 여러 Search Engine 의 상위 노출을 위한 \n\n검색엔진 최적화이다.\n\n---\n## 과정\n\nSEO 를 위해\n\n```javascript\nconst SEO = ({ title, description, url }) => {\n  return (\n    <Helmet>\n      <title>{title}</title>\n      <meta property=\"og:url\" content={url} />\n      <meta property=\"og:title\" content={title} />\n      <meta property=\"og:image\" content={`${siteUrl}/og-image.png`} />\n      <meta name=\"google-site-verification\" content=\"hidden\" />\n      {description && <meta name=\"description\" content={description} />}\n      {description && <meta property=\"og:description\" content={description} />}\n    </Helmet>\n  )\n}\n```\n\n위와 같이 필요한 정보들을 입력해주었고, `Google Search Console` 에서 데이터 분석 및, 동작이 제대로 되는지에 대한 \n\n`tracking` 정보를 위해, `google-site-verification` 또한 추가해주었다.\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\" xmlns:mobile=\"http://www.google.com/schemas/sitemap-mobile/1.0\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\n<url> <loc>https://hwani.dev/about-hoodie-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/quick-start-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/writing-guide-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/other-tips-kr/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/no-var/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/no-global/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/starbucks-menu-1/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/series/gatsby-starter-hoodie-로-블로그-시작하기</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/series/JS_CleanCode</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/search/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/series/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n<url> <loc>https://hwani.dev/tags/</loc> <changefreq>daily</changefreq> <priority>0.7</priority> </url>\n</urlset>\n```\n\n![](b478fca6.png)\n\n또한, `sitemap` 을 작성하고 제출하여, 정상적으로 search engine 이 나의 `sitemap` 을 참고하도록 설정해주었다.\n\n```txt\nUser-agent: *\nAllow: /\nSitemap: https://hwani.dev/sitemap/sitemap-index.xml\nHost: https://hwani.dev\n\n```\n\n마지막으로는 Robot.txt 파일 또한 수정하고, `Root` 디렉토리에 위치하게 하였다.\n\n---\n\n## 결과\n\n![](ef3b1b5e.png)\n\n네이버를 통한 SEO 간단 체크 결과 모든 항목이 정상적으로 체크되어있었다.\n\n하지만 SEO 부분에서는 아직 모르는 것 투성이고 아직 improved 시킬 수 있다는 판단이 섰다.\n\n추가 사항이 있다면, 추가적으로 연재할 계획이다! \n\n---\n\n## Reference\n\n<a href=\"https://neilpatel.com/what-is-seo/\" target=\"_blank\">What Is SEO? (Learn How to Do It in 5 Minutes)</a>\n\n"}]}},"pageContext":{}},"staticQueryHashes":[]}