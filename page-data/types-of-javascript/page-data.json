{"componentChunkName":"component---src-templates-post-jsx","path":"/types-of-javascript/","result":{"data":{"site":{"siteMetadata":{"title":"hwani.dev"}},"markdownRemark":{"id":"9c8002eb-dd07-5e2a-9975-e372314ee212","excerpt":"서론 간단한 앱을 개발할때도 타입검사를 흔하게 사용한다. JS 에서 타입을 검사할때 제일먼저 떠오르는 것은  연산자 이다. typeof 는 우항에 있는 피연산자를 평가한 후, 문자열로 반환해준다.\n하지만, typeof 는 치명적인 단점이 있는데, 모든것을 커버해주지 못한다는 것이다. 이뜻은, Primitive 원시값, Reference 자료형에 해당하는 …","html":"<h2>서론</h2>\n<p>간단한 앱을 개발할때도 타입검사를 흔하게 사용한다. JS 에서 타입을 검사할때 제일먼저 떠오르는 것은 <code class=\"language-text\">typeof</code> 연산자 이다.</p>\n<p>typeof 는 우항에 있는 피연산자를 평가한 후, 문자열로 반환해준다.\n하지만, typeof 는 치명적인 단점이 있는데, 모든것을 커버해주지 못한다는 것이다.</p>\n<p>이뜻은, Primitive 원시값, Reference 자료형에 해당하는 객체들이 존재하는데, 원시값은 불변하기에 타입검사를 할때, 괜찮을 수 있지만, <code class=\"language-text\">array</code>, <code class=\"language-text\">function</code>, <code class=\"language-text\">date</code> 등이 Reference type 에 해당하는 object 로 치부되기에, <code class=\"language-text\">typeof</code> 연산자로 타입검사를 할 때 모순점이 생긴다.</p>\n<hr>\n<h2>본론</h2>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">myFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">myClass</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">'문자열'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">typeof</span> myFunc <span class=\"token comment\">// 'function'</span>\n<span class=\"token keyword\">typeof</span> myClass <span class=\"token comment\">// 'function'</span>\n<span class=\"token keyword\">typeof</span> str <span class=\"token comment\">// 'object'</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token string\">'문자열'</span> <span class=\"token comment\">// 'string'</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token number\">123</span> <span class=\"token comment\">// 'number'</span></code></pre></div>\n<p>위와같이 primitive type 은 typeof 연산자로 검사가 가능하지만, typeof 연산자로 reference type 을 검사 할 때는 굉장히 많은 위험을 동반한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">typeof</span> <span class=\"token keyword\">null</span> <span class=\"token comment\">// 'object'</span></code></pre></div>\n<p>가장 문제가 되는 녀석은 <code class=\"language-text\">null</code> 이다. null 의 type 을 object 로 찍어내는 것은 이해가 안가는 부분이 존재하고, 사실 이는 javascript 가 공식적으로 인정한 <code class=\"language-text\">오류</code> 이다. js 가 발전을 하면서 언어적으로 이는 수정을 할 수 없다고 판단을 하였다고 한다.</p>\n<p>Javascript 는 <code class=\"language-text\">동적</code> 으로 변하는 언어이지만, 위험성은 <code class=\"language-text\">type</code> 까지 동적이 된다는 점이다.</p>\n<p><code class=\"language-text\">typeof</code> 의 단점을 커버하기위해 <code class=\"language-text\">instanceof</code> 라는 일종의 연산자의 한 종류를 사용 할 수 있는데, 이 연산자는 객체의 prototype chain 을 검사 할 수 있게 해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> age</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> Hwani <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hwani'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">24</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> Lee <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'hwani'</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">24</span>\n<span class=\"token punctuation\">}</span>\n\nHwani <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Person</span> <span class=\"token comment\">// true</span>\nLee <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Person</span> <span class=\"token comment\">// false</span></code></pre></div>\n<p>여기에서 감을 잡을 수 있다. typeof 는 불변한 primitive value 들을 검사 할 수 있는데, instanceof 는 객체에 대해 확인하기에 요긴하다.</p>\n<p>하지만 여기서도 함정이 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">func</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> date <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\narr <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Array</span> <span class=\"token comment\">// true</span>\nfunc <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Function</span> <span class=\"token comment\">// true</span>\ndate <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Date</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>이렇게만 보면 instaceof 라는 연산자를 사용하여 좌항과 우항을 잘 비교하고 있는것처럼 보이지만</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">func</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> date <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\narr <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span> <span class=\"token comment\">// true</span>\nfunc <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span> <span class=\"token comment\">// true</span>\ndate <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>결국 reference type 이기 때문에 <code class=\"language-text\">prototype chain</code> 을 타보면 최상위는 <code class=\"language-text\">object</code> 라는 결론에 도달하게 된다.</p>\n<p>때문에, 더더욱 타입 검사를 하기에 어려움이 생긴다.</p>\n<p>위의 <code class=\"language-text\">typeof</code> 연산자와 <code class=\"language-text\">instanceof</code> 연산자의 단점 때문에 다른 하나의 방법이 더 존재한다.\n<code class=\"language-text\">object 의 prototype chain</code> 자체를 역이용하는 방법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">func</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> date <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nObject\n  <span class=\"token punctuation\">.</span>prototype\n  <span class=\"token punctuation\">.</span><span class=\"token function\">toString</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// '[object String]'</span>\n\nObject\n  <span class=\"token punctuation\">.</span>prototype\n  <span class=\"token punctuation\">.</span><span class=\"token function\">toString</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// '[object Array]'</span>\n\nObject\n  <span class=\"token punctuation\">.</span>prototype\n  <span class=\"token punctuation\">.</span><span class=\"token function\">toString</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// '[object Function]'</span>\n\nObject\n  <span class=\"token punctuation\">.</span>prototype\n  <span class=\"token punctuation\">.</span><span class=\"token function\">toString</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// '[object Date]'</span></code></pre></div>\n<p>이런식으로 reference type 까지 검사 할 수 있다.</p>\n<p>하지만 이 방식또한 무적이라고 말 할 수 없기 때문에 타입을 검사할 때 하나하나 노하우를 쌓아가는 것이 중요하다.</p>\n<p>주로 나는 <code class=\"language-text\">stack overflow</code> 를 이용하는데 이때, 검색 키워드는 </p>\n<ul>\n<li>javascript is array</li>\n<li>javascript is function</li>\n<li>javascript is date</li>\n</ul>\n<p>와 같이 검색하면 주로 많은 답변이 나온다.</p>\n<hr>\n<h2>결론</h2>\n<p>자바스크립트는 동적을 타입을 가진 언어이다.</p>\n<p>그렇기 때문에 타입 검사가 어렵다. </p>\n<p>많은 타입 검사가 존재하기 때문에 다 외우기 보다는 검색을 통하여 타입 검사를 체크하는 방법을 추천한다.</p>\n<p>타입 검사를 할 때에는 항상 <code class=\"language-text\">primitive type</code> 과 <code class=\"language-text\">reference type</code> 을 잘 생각하며 유의해야하며 </p>\n<p><code class=\"language-text\">typeof</code> 연산자는 무적이 아니다. </p>","frontmatter":{"title":"JS - 타입 검사","date":"November 29, 2021","update":"November 29, 2021","tags":["JS_CleanCode"],"series":"JS_CleanCode"},"fields":{"slug":"/types-of-javascript/","readingTime":{"minutes":5.085}}},"seriesList":{"edges":[{"node":{"id":"3ad93a4b-ef31-52e2-98ff-40052aff7ae5","fields":{"slug":"/no-var/"},"frontmatter":{"title":"JS - var 를 지양하자"}}},{"node":{"id":"ac5983fa-822c-56a4-840b-2d47c94bfc0f","fields":{"slug":"/no-global/"},"frontmatter":{"title":"JS - 전역 공간 사용 최소화"}}},{"node":{"id":"7e67a6be-a154-540b-9e7f-1596601d252d","fields":{"slug":"/no-temporary-variable/"},"frontmatter":{"title":"JS - 임시변수 제거하기"}}},{"node":{"id":"785e2a98-e2eb-581a-bdaf-bb516ee9fab2","fields":{"slug":"/no-hoisting/"},"frontmatter":{"title":"JS - 호이스팅 주의하기"}}},{"node":{"id":"9c8002eb-dd07-5e2a-9975-e372314ee212","fields":{"slug":"/types-of-javascript/"},"frontmatter":{"title":"JS - 타입 검사"}}},{"node":{"id":"5fad31a0-fb35-5c1d-9eaa-4ad3101ae8a3","fields":{"slug":"/undefined-null/"},"frontmatter":{"title":"JS - undefined & null"}}},{"node":{"id":"2ac21fc2-48c2-5c71-8f4f-1bfd1b5892ed","fields":{"slug":"/no-eqeq/"},"frontmatter":{"title":"JS - eqeq 줄이기"}}},{"node":{"id":"82fbaec1-d348-5249-8ecc-a75c1aefc233","fields":{"slug":"/careful-typecast/"},"frontmatter":{"title":"JS - 형변환 주의하기"}}}]},"previous":{"fields":{"slug":"/menu-sidebar-modal/"},"frontmatter":{"title":"사이드바, 모달 with Vanilla JS"}},"next":{"fields":{"slug":"/undefined-null/"},"frontmatter":{"title":"JS - undefined & null"}}},"pageContext":{"id":"9c8002eb-dd07-5e2a-9975-e372314ee212","series":"JS_CleanCode","previousPostId":"364ae05f-101b-5720-9ec6-d692d55e0062","nextPostId":"5fad31a0-fb35-5c1d-9eaa-4ad3101ae8a3"}},"staticQueryHashes":[]}