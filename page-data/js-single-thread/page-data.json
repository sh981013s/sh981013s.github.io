{"componentChunkName":"component---src-templates-post-jsx","path":"/js-single-thread/","result":{"data":{"site":{"siteMetadata":{"title":"hwani.dev"}},"markdownRemark":{"id":"2ed793fe-3639-5ada-af50-48c4e4882fce","excerpt":"서론 자바스크립트는 하나의  과 하나의  을 가진 \n 이다. 그러므로 당연히 위에서부터 순차적으로 코드를\n실행하고 다음 코드로 넘어가기 전 실행하고 있는 코드를 끝내야만 한다. 맞다.  는 . 허나, 내 머리를 지끈거리게 만든 점은 코르를 작성하다보면 의도적으로 코드를  하는 행위를 \n심심치 않게 해왔지만,  '도대체 어떻게 싱글스레드인  자바스크립트는 …","html":"<h2>서론</h2>\n<p>자바스크립트는 하나의 <code class=\"language-text\">call stack</code> 과 하나의 <code class=\"language-text\">memory heap</code> 을 가진\n<code class=\"language-text\">single threaded language</code> 이다. 그러므로 당연히 위에서부터 순차적으로 코드를\n실행하고 다음 코드로 넘어가기 전 실행하고 있는 코드를 끝내야만 한다. 맞다. <code class=\"language-text\">자바스크립트(js)</code> 는 <code class=\"language-text\">동기적이다(synchronous)</code>.</p>\n<p>허나, 내 머리를 지끈거리게 만든 점은 코르를 작성하다보면 의도적으로 코드를 <code class=\"language-text\">비동기 처리</code> 하는 행위를\n심심치 않게 해왔지만, </p>\n<p>'도대체 어떻게 싱글스레드인  자바스크립트는 코드를 비동기적으로 실행시킬까?' 에서 머리가 복잡해졌다.</p>\n<hr>\n<h2>본론</h2>\n<p>고맙게도 자바스크립트 엔진은(V8, Spidermonkey, JavascriptCore 등등..)은\n이와같은 task 들을 병렬적으로 background 에서 동작시키기 위해 필요한 <code class=\"language-text\">Web API</code> 를 가지고 있다.</p>\n<p>call stack 은 Web API 의 함수들을 인지하고 필요에 의해 브라우저에게 task를 맡긴다.\n맡겨진 task가 끝난 후에는, 브라우저는 해당 task를 다시 반환 후 callback 으로써 다시 스택에 밀어넣는다.</p>\n<p>브라우저 콘솔에서 <code class=\"language-text\">window</code> 를 쳐본다면 ajax calls, 이벤트 리스너, fetch API, setTimeout 등\nWeb API 가 제공하는 모든것들을 확인할 수 있다. 이제 어떻게 자바스크립트가 브라우저에서 <code class=\"language-text\">비동기적으로</code> 동작하는지 예시와 함께 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"first\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"second\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"third\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위의 코드를 적어내면</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">first\nthird\n<span class=\"token keyword\">undefined</span>\nsecond</code></pre></div>\n<p>위의 결과가 나온다. 벌써 머리가 어질어질하다. 'first', 'third', 'second' 의 결과가 나와야 하지 않나? 하지만 이는 에러로 인해 해당 결과가 나온것이 아니다. 한줄한줄 추적해보자.</p>\n<ol>\n<li><code class=\"language-text\">console.log(first)</code> 가 처음 스택에 쌓이게 되고 콘솔에 찍힌다. </li>\n<li>엔진은 자바스크립트에서 동작하지 않는 <code class=\"language-text\">setTimeout()</code> 을 발견하고는 비동기적인 처리를 위해 <code class=\"language-text\">Web API</code> 에게 보내버린다.</li>\n<li>2번의 동작을 신경쓰지 않은체 <code class=\"language-text\">console.log(three)</code> 를 스택에 쌓고 실행시킨다. </li>\n<li>자바스크립트의 엔진의 <code class=\"language-text\">event loop</code>이 개입하여 '우리 이제 끝난거야..?' 하고 물어본다.</li>\n<li><code class=\"language-text\">web API</code> 가 '아니? 아직인데? 줄 value 가 없어!' 라고 대답을 하자 디폴트 값인 <code class=\"language-text\">undefined</code> 를 콘솔에 찍는다.</li>\n<li>비동기처리를 하던 task 가 완료 후, callback 으로써 스택에 들어오게 되고, 이는 실행되어 콘솔에 second 를 찍는다.</li>\n</ol>\n<hr>\n<h2>결론</h2>\n<p>결국 내가 생각하던게 어느정도는 맞다. 자바스크립트는 single threaded language 이고, 하나의\n콜스택과 하나의 힙스택을 가지고 있기에 동기적으로 task 를 처리한다. 하지만 이는 브라우저에서 실행될때\nWeb API 라는 녀석을 사용하여 비동기적으로 task 를 처리할 수 있다.</p>","frontmatter":{"title":"싱글스레드인 자바스크립트는 어떻게 비동기 처리를 하는가","date":"January 24, 2022","update":"January 24, 2022","tags":["Javascript"],"series":null},"fields":{"slug":"/js-single-thread/","readingTime":{"minutes":3.895}}},"seriesList":{"edges":[{"node":{"id":"a3e16011-856b-598c-88ca-ceebc8364f95","fields":{"slug":"/starbucks-menu-1/"},"frontmatter":{"title":"스타벅스 메뉴관리 with vanilla JS"}}},{"node":{"id":"92ebb2fd-e60e-5a93-88dc-ec9c28596843","fields":{"slug":"/baekjoon-1654/"},"frontmatter":{"title":"[BOJ] 1654 랜선 자르기 (Node.js)"}}},{"node":{"id":"b3bae6a0-d405-5d05-a043-d8638b60e890","fields":{"slug":"/vainllajs-registration-form/"},"frontmatter":{"title":"회원가입 폼 with Vanilla JS"}}},{"node":{"id":"104e0e28-4cfe-50ae-b9b8-3fb3dfc3ad04","fields":{"slug":"/movie-seat-booking/"},"frontmatter":{"title":"영화 좌석 선택 with Vanilla JS"}}},{"node":{"id":"e88b46a1-2475-5adc-80e7-55e7e252e9bd","fields":{"slug":"/exchange-rate-calculator/"},"frontmatter":{"title":"환전기 with Vanilla JS"}}},{"node":{"id":"ae0897e7-cc41-5c3a-89df-0273fdcb487e","fields":{"slug":"/custom-video-player/"},"frontmatter":{"title":"비디오 플레이어 with Vanilla JS"}}},{"node":{"id":"24e65c9a-a50e-5145-b39d-6108376629be","fields":{"slug":"/personal-information-list/"},"frontmatter":{"title":"개인자산 체크 with Vanilla JS"}}},{"node":{"id":"5ba84f09-135a-5975-b10f-4bf758e5f32e","fields":{"slug":"/menu-sidebar-modal/"},"frontmatter":{"title":"사이드바, 모달 with Vanilla JS"}}},{"node":{"id":"b1bd56b2-bd16-58f2-a750-2f0ffd138cb8","fields":{"slug":"/connecting-server-client/"},"frontmatter":{"title":"React && Node.js 연결하기"}}},{"node":{"id":"5cd51722-bb20-58ff-ad03-0d4210931109","fields":{"slug":"/import-react/"},"frontmatter":{"title":"importing React 와 JSX 사용의 상관관계"}}},{"node":{"id":"5f1c97cb-0242-5c0b-8037-626e2ee635de","fields":{"slug":"/vsc-react-autoimport/"},"frontmatter":{"title":"VSC 리액트 auto import"}}},{"node":{"id":"e741c309-2360-56d3-af48-f65bfae7253a","fields":{"slug":"/useRef/"},"frontmatter":{"title":"리액트 useRef"}}},{"node":{"id":"aaaedd63-6139-5da1-8196-3098ae216714","fields":{"slug":"/react-debouncing/"},"frontmatter":{"title":"리액트 디바운싱(debouncing)"}}},{"node":{"id":"b4b91b64-56ec-5f6c-8fc3-5f754204f3a0","fields":{"slug":"/react-debugging/"},"frontmatter":{"title":"리액트 크롬 데브툴 디버깅(debugging)"}}},{"node":{"id":"b030ebe6-631d-5927-b411-78b9a3bf9e85","fields":{"slug":"/js-semicolon/"},"frontmatter":{"title":"자바스크립트 내에서의 세미콜론(;) 사용"}}},{"node":{"id":"540e9709-5b2c-5702-af14-f1344e83c064","fields":{"slug":"/js-short-circuit-evaluation/"},"frontmatter":{"title":"자바스크립트 단축 평가"}}},{"node":{"id":"ac4bb014-16a9-5795-b805-28c631aeb58f","fields":{"slug":"/js-const/"},"frontmatter":{"title":"자바스크립트 const(constant) 키워드 에 대한 고찰"}}},{"node":{"id":"2ed793fe-3639-5ada-af50-48c4e4882fce","fields":{"slug":"/js-single-thread/"},"frontmatter":{"title":"싱글스레드인 자바스크립트는 어떻게 비동기 처리를 하는가"}}},{"node":{"id":"83b07909-0921-5c80-8198-093ac91c69c2","fields":{"slug":"/js-indexOf/"},"frontmatter":{"title":"자바스크립트 indexOf() 와 시간 복잡도의 상관관계에 대한 고찰"}}},{"node":{"id":"b4e2ec83-3483-5fd8-9faa-1390549e9d2f","fields":{"slug":"/2021-retrospect/"},"frontmatter":{"title":"2021년 블로그 운영 회고"}}},{"node":{"id":"16258bc3-0d2f-5d9b-8093-8d37111f8cd4","fields":{"slug":"/react-real-code-splitting/"},"frontmatter":{"title":"리액트 Code-splitting 실적용 사례"}}}]},"previous":{"fields":{"slug":"/js-const/"},"frontmatter":{"title":"자바스크립트 const(constant) 키워드 에 대한 고찰"}},"next":{"fields":{"slug":"/js-indexOf/"},"frontmatter":{"title":"자바스크립트 indexOf() 와 시간 복잡도의 상관관계에 대한 고찰"}}},"pageContext":{"id":"2ed793fe-3639-5ada-af50-48c4e4882fce","series":null,"previousPostId":"ac4bb014-16a9-5795-b805-28c631aeb58f","nextPostId":"83b07909-0921-5c80-8198-093ac91c69c2"}},"staticQueryHashes":[]}